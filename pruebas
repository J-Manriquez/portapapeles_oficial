import tkinter as tk
from tkinter import ttk

class ThemeManager:
    def __init__(self, manager):
        self.manager = manager
        self.colors = {
            'dark': {
                'bg': '#1e1e1e',
                'fg': '#ffffff',
                'button_bg': '#333333',
                'button_fg': '#ffffff',
                'listbox_bg': '#2d2d2d',
                'listbox_fg': '#ffffff',
                'card_bg': '#333333'
            },
            'light': {
                'bg': '#f0f0f0',
                'fg': '#000000',
                'button_bg': '#e0e0e0',
                'button_fg': '#000000',
                'listbox_bg': '#ffffff',
                'listbox_fg': '#000000',
                'card_bg': '#ffffff'
            }
        }

    def toggle_theme(self):
        self.manager.is_dark_mode = not self.manager.is_dark_mode
        self.manager.theme_button.config(text="üåô" if self.manager.is_dark_mode else "‚òÄÔ∏è")
        self.apply_theme()

    def apply_theme(self):
        theme = self.colors['dark'] if self.manager.is_dark_mode else self.colors['light']
        
        self.manager.root.configure(bg=theme['bg'])
        self.manager.main_frame.configure(style='Main.TFrame')
        self.manager.title_frame.configure(bg=theme['bg'])
        self.manager.title_label.configure(bg=theme['bg'], fg=theme['fg'])
        
        self.manager.clear_button.configure(
            bg=theme['button_bg'],
            fg=theme['button_fg'],
            activebackground=theme['button_bg'],
            activeforeground=theme['button_fg']
        )
        self.manager.theme_button.configure(
            bg=theme['button_bg'],
            fg=theme['button_fg'],
            activebackground=theme['button_bg'],
            activeforeground=theme['button_fg']
        )
        
        self.manager.close_button.configure(
            bg=theme['button_bg'],
            fg=theme['button_fg'],
            activebackground=theme['button_bg'],
            activeforeground=theme['button_fg']
        )

        self.manager.button1.configure(
            bg=theme['button_bg'],
            fg=theme['button_fg'],
            activebackground=theme['button_bg'],
            activeforeground=theme['button_fg']
        )

        self.manager.button2.configure(
            bg=theme['button_bg'],
            fg=theme['button_fg'],
            activebackground=theme['button_bg'],
            activeforeground=theme['button_fg']
        )

        self.manager.button3.configure(
            bg=theme['button_bg'],
            fg=theme['button_fg'],
            activebackground=theme['button_bg'],
            activeforeground=theme['button_fg']
        )

        self.manager.canvas.configure(bg=theme['bg'])
        self.manager.cards_frame.configure(bg=theme['bg'])
        
        self.manager.functions.refresh_cards()

        style = ttk.Style()  
        style.theme_use('clam')  
        style.configure('Main.TFrame', background=theme['bg'])
        
        
        
import time


def measure_time(func):
        def wrapper(*args, **kwargs):
            start_time = time.time()
            result = func(*args, **kwargs)
            end_time = time.time()
            print(f"{func.__name__} tom√≥ {(end_time - start_time) * 1000:.2f} ms")
            return result
        return wrapper
    

# main.py

import tkinter as tk
from structure import ClipboardManager

def main():
    root = tk.Tk()
    app = ClipboardManager(root)
    root.mainloop()

if __name__ == "__main__":
    main()
    

# structure.py

import tkinter as tk
from tkinter import ttk
import time
import threading
from datetime import datetime
import keyboard # type: ignore
import sys
import win32gui # type: ignore
from functions import Functions
from navigation import Navigation
from theme_manager import ThemeManager

class ClipboardManager:
    def __init__(self, root):
        self.root = root
        self.root.title("Portapapeles")

        window_width = 295
        window_height = 400
        
        self.window_width = window_width

        self.root.geometry(f"{window_width}x{window_height}+0+0")
        self.root.overrideredirect(True)
        
        self.root.withdraw()
        self.is_visible = False

        self.previous_window = None

        self.clipboard_items = {}  # Diccionario para almacenar los items del portapapeles
        self.current_clipboard = ""
        self.selected_index = None
        self.is_visible = False
        self.current_selection = {'type': 'button', 'index': 0}  # type puede ser 'button', 'card' o 'icon'
        self.is_dark_mode = True
        
        self.paste_with_format = True
        
        self.previous_window = None
        self.last_active_window = None
        self.selected_button = None  # Para la navegaci√≥n de botones
        self.selected_card = None    # Para la navegaci√≥n de cards
        self.selected_icon = None    # Para la navegaci√≥n de iconos en una card
        self.total_buttons = 3
        self.icons_per_card = 3

        self.functions = Functions(self)
        self.navigation = Navigation(self)
        self.theme_manager = ThemeManager(self)

        self.create_gui()
        self.theme_manager.apply_theme()

        self.root.bind('<Return>', self.navigation.activate_selected)
        self.root.bind('<Up>', self.navigation.navigate_vertical)
        self.root.bind('<Down>', self.navigation.navigate_vertical)
        self.root.bind('<Left>', self.navigation.navigate_horizontal)
        self.root.bind('<Right>', self.navigation.navigate_horizontal)
        self.root.bind('<FocusIn>', self.navigation.handle_focus)

        self.monitor_thread = threading.Thread(target=self.functions.monitor_clipboard, daemon=True)
        self.monitor_thread.start()

        keyboard.add_hotkey('alt+j', self.navigation.toggle_window)
        keyboard.add_hotkey('up', lambda: self.root.after(0, lambda: self.navigation.handle_global_key('Up')))
        keyboard.add_hotkey('down', lambda: self.root.after(0, lambda: self.navigation.handle_global_key('Down')))
        keyboard.add_hotkey('left', lambda: self.root.after(0, lambda: self.navigation.handle_global_key('Left')))
        keyboard.add_hotkey('right', lambda: self.root.after(0, lambda: self.navigation.handle_global_key('Right')))
        keyboard.add_hotkey('enter', lambda: self.root.after(0, lambda: self.navigation.handle_global_key('Return')))    
        
        self.root.after(1000, self.navigation.check_window_state)

    def create_gui(self):
        self.main_frame = ttk.Frame(self.root, style='Main.TFrame')
        self.main_frame.pack(fill=tk.BOTH, expand=True)

        self.title_frame = tk.Frame(self.main_frame, bg=self.theme_manager.colors['dark']['bg'])
        self.title_frame.pack(fill=tk.X, padx=5, pady=(0, 5))

        self.title_label = tk.Label(self.title_frame, text="Portapapeles", font=('Segoe UI', 10, 'bold'), bg=self.theme_manager.colors['dark']['bg'], fg=self.theme_manager.colors['dark']['fg'])
        self.title_label.pack(side=tk.LEFT, padx=5)

        buttons_frame = tk.Frame(self.title_frame, bg=self.theme_manager.colors['dark']['bg'])
        buttons_frame.pack(side=tk.RIGHT, padx=4)

        self.clear_button = tk.Button(buttons_frame, text="      üóëÔ∏è", command=self.functions.clear_history, font=('Segoe UI', 10), bd=0, padx=10, width=5, height=2)
        self.clear_button.pack(side=tk.LEFT)

        self.theme_button = tk.Button(buttons_frame, text="üåô", command=self.theme_manager.toggle_theme, font=('Segoe UI', 10), bd=0, padx=10, width=5, height=2)
        self.theme_button.pack(side=tk.LEFT)

        self.close_button = tk.Button(buttons_frame, text="‚ùå", command=self.functions.exit_app, font=('Segoe UI', 10, 'bold'), bd=0, padx=10, width=5, height=2)
        self.close_button.pack(side=tk.LEFT)

        main_buttons_frame = tk.Frame(self.main_frame, bg=self.theme_manager.colors['dark']['bg'])
        main_buttons_frame.pack(fill=tk.X, padx=8, pady=(5, 0))

        self.button1 = tk.Button(main_buttons_frame, text="Bot√≥n 1", font=('Segoe UI', 10), bg=self.theme_manager.colors['dark']['button_bg'], fg=self.theme_manager.colors['dark']['button_fg'])
        self.button1.pack(side=tk.LEFT, fill=tk.X, expand=True)

        self.button2 = tk.Button(main_buttons_frame, text="Bot√≥n 2", font=('Segoe UI', 10), bg=self.theme_manager.colors['dark']['button_bg'], fg=self.theme_manager.colors['dark']['button_fg'])
        self.button2.pack(side=tk.LEFT, fill=tk.X, expand=True)

        self.button3 = tk.Button(main_buttons_frame, text="Con formato", command=self.functions.toggle_paste_format, font=('Segoe UI', 10), bg=self.theme_manager.colors['dark']['button_bg'], fg=self.theme_manager.colors['dark']['button_fg'])
        self.button3.pack(side=tk.LEFT, fill=tk.X, expand=True)

        self.canvas = tk.Canvas(self.main_frame, bd=0, highlightthickness=0)
        self.canvas.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)
        self.cards_frame = tk.Frame(self.canvas, bg=self.theme_manager.colors['dark']['bg'])  
        self.canvas.create_window((0, 0), window=self.cards_frame, anchor='nw')

        self.scrollbar = ttk.Scrollbar(self.main_frame, orient=tk.VERTICAL, command=self.canvas.yview)
        self.scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        self.scrollbar.pack_forget()

        self.canvas.bind('<Configure>', self.functions.on_canvas_configure)
        self.canvas.bind_all("<MouseWheel>", self.functions.on_mousewheel)

        self.title_label.bind('<Button-1>', self.navigation.start_move)
        self.title_label.bind('<B1-Motion>', self.navigation.on_move)
        
        
# functions.py

import tkinter as tk
import uuid
import win32clipboard # type: ignore
import win32gui # type: ignore
import time
import sys
from utils import measure_time

class Functions:
    def __init__(self, manager):
        self.manager = manager
    @measure_time
    def create_card(self, item_id, item_data, index):
        card_width = self.manager.window_width + 1

        card_container = tk.Frame(self.manager.cards_frame, width=card_width)
        card_container.pack(fill=tk.BOTH, padx=2, pady=2)

        text_frame = tk.Frame(card_container)
        text_frame.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)

        # Procesamos el texto para mostrarlo de forma limpia
        processed_text = self.process_text(item_data['text'])

        text_label = tk.Label(text_frame, text=processed_text,
                            justify=tk.LEFT, anchor='w', padx=10, pady=5,
                            bg=card_container['bg'],
                            fg=self.manager.theme_manager.colors['dark' if self.manager.is_dark_mode else 'light']['fg'], width=int(24))
        text_label.pack(fill=tk.X, expand=True, side=tk.LEFT)

        icons_frame = tk.Frame(card_container, bg=card_container['bg'])
        icons_frame.pack(side=tk.RIGHT, padx=3)

        arrow_button = tk.Button(icons_frame, text="‚û°Ô∏è",
                                command=lambda: self.on_arrow_click(item_id),
                                font=('Segoe UI', 10), bd=0,
                                padx=2,
                                bg=card_container['bg'],
                                fg=self.manager.theme_manager.colors['dark' if self.manager.is_dark_mode else 'light']['fg'])
        arrow_button.pack(side=tk.LEFT)
        
        pin_text = "üìå" if item_data['pinned'] else "üìç"
        pin_button = tk.Button(icons_frame, text=pin_text,
                            command=lambda: self.toggle_pin(item_id),
                            font=('Segoe UI', 10), bd=0,
                            padx=2,
                            bg=card_container['bg'],
                            fg=self.manager.theme_manager.colors['dark' if self.manager.is_dark_mode else 'light']['fg'])
        pin_button.pack(side=tk.LEFT)

        delete_button = tk.Button(icons_frame, text="‚úñÔ∏è",
                                command=lambda: self.delete_item(item_id),
                                font=('Segoe UI', 10), bd=0,
                                padx=2,
                                bg=card_container['bg'],
                                fg=self.manager.theme_manager.colors['dark' if self.manager.is_dark_mode else 'light']['fg'])
        delete_button.pack(side=tk.LEFT)
        
        return card_container
    
    def process_text(self, text):
        """
        Procesa el texto para mostrarlo de forma limpia y ordenada
        """
        # Eliminamos espacios extras y tabulaciones al inicio y final
        text = text.strip()
        
        # Dividimos el texto en l√≠neas
        lines = text.splitlines()
        
        # Eliminamos l√≠neas vac√≠as consecutivas y espacios extras
        clean_lines = []
        prev_empty = False
        for line in lines:
            line = line.strip()
            
            # Si la l√≠nea est√° vac√≠a
            if not line:
                if not prev_empty:  # Solo mantenemos una l√≠nea vac√≠a
                    clean_lines.append('')
                    prev_empty = True
            else:
                clean_lines.append(line)
                prev_empty = False
        
        # Tomamos solo las primeras 3 l√≠neas para la vista previa
        preview_lines = clean_lines[:3]
        
        # Si hay m√°s l√≠neas, indicamos cu√°ntas m√°s hay
        if len(clean_lines) > 3:
            remaining_lines = len(clean_lines) - 3
            preview_lines.append(f"+ {remaining_lines} l√≠neas m√°s")
            
        # Unimos las l√≠neas con saltos de l√≠nea
        return '\n'.join(preview_lines)

    @measure_time
    def refresh_cards(self):
        for widget in self.manager.cards_frame.winfo_children():
            widget.destroy()

        theme = self.manager.theme_manager.colors['dark' if self.manager.is_dark_mode else 'light']
        
        for index, (item_id, item_data) in enumerate(self.manager.clipboard_items.items()):
            card = self.create_card(item_id, item_data, index)
            self.apply_theme_to_card(card, theme)

        self.manager.canvas.update_idletasks()
        self.manager.canvas.configure(scrollregion=self.manager.canvas.bbox("all"))

    def apply_theme_to_card(self, card, theme):
        card.configure(bg=theme['card_bg'])
        
        for child in card.winfo_children():
            if isinstance(child, tk.Frame):
                child.configure(bg=theme['card_bg'])
                for subchild in child.winfo_children():
                    if isinstance(subchild, (tk.Label, tk.Button)):
                        subchild.configure(bg=theme['card_bg'], fg=theme['fg'])
            elif isinstance(child, (tk.Label, tk.Button)):
                child.configure(bg=theme['card_bg'], fg=theme['fg'])

    def toggle_pin(self, item_id):
        if item_id in self.manager.clipboard_items:
            self.manager.clipboard_items[item_id]['pinned'] = not self.manager.clipboard_items[item_id]['pinned']
            self.refresh_cards()

    def delete_item(self, item_id):
        if item_id in self.manager.clipboard_items and not self.manager.clipboard_items[item_id]['pinned']:
            del self.manager.clipboard_items[item_id]
            self.refresh_cards()

    def on_arrow_click(self, index):
        pass

    def clear_history(self):
        self.manager.clipboard_items = {k: v for k, v in self.manager.clipboard_items.items() if v['pinned']}
        self.refresh_cards()

    def on_canvas_configure(self, event):
        self.manager.canvas.configure(scrollregion=self.manager.canvas.bbox("all"))

    def on_mousewheel(self, event):
        self.manager.canvas.yview_scroll(int(-1 * (event.delta / 120)), "units")
    @measure_time
    def monitor_clipboard(self):
        while True:
            clipboard_content = self.get_clipboard_text()
            if clipboard_content and clipboard_content != self.manager.current_clipboard:
                self.manager.current_clipboard = clipboard_content
                if clipboard_content not in [item['text'] for item in self.manager.clipboard_items.values()]:
                    new_id = str(uuid.uuid4())
                    self.manager.clipboard_items[new_id] = {
                        'text': clipboard_content,
                        'pinned': False,
                        'with_format': self.manager.paste_with_format
                    }
                    if len(self.manager.clipboard_items) > 20:
                        unpinned_items = [k for k, v in self.manager.clipboard_items.items() if not v['pinned']]
                        if unpinned_items:
                            del self.manager.clipboard_items[unpinned_items[-1]]
                    self.manager.root.after(0, self.refresh_cards)
            time.sleep(1)
    
    # @measure_time
    def get_clipboard_text(self):
        try:
            win32clipboard.OpenClipboard()
            data = win32clipboard.GetClipboardData(win32clipboard.CF_UNICODETEXT)
            win32clipboard.CloseClipboard()
            return data
        except Exception as e:
            print(f"Error al obtener texto del portapapeles: {e}")
            return None

    def exit_app(self):
        self.manager.root.quit()
        sys.exit()
    
    @measure_time    
    def toggle_paste_format(self):
        self.manager.paste_with_format = not self.manager.paste_with_format
        new_text = "Con formato" if self.manager.paste_with_format else "Sin formato"
        self.manager.button3.config(text=new_text)
        
    


# navigation.py
import win32com.client
import tkinter as tk
import win32gui
import keyboard
import time
import pyperclip
from utils import measure_time  

class Navigation:
    def __init__(self, manager):
        self.manager = manager

    @measure_time
    def navigate_vertical(self, event):
        if not self.manager.is_visible:
            return
        
        current_type = self.manager.current_selection['type']
        current_index = self.manager.current_selection['index']
        
        try:
            if current_type == 'button':
                if event.keysym == 'Down':
                    if len(self.manager.clipboard_items) > 0:
                        self.manager.current_selection = {'type': 'card', 'index': 0}
            elif current_type == 'card':
                items = list(self.manager.clipboard_items.keys())
                if event.keysym == 'Up':
                    if current_index > 0:
                        self.manager.current_selection['index'] = current_index - 1
                    else:
                        self.manager.current_selection = {'type': 'button', 'index': 0}
                elif event.keysym == 'Down':
                    if current_index < len(items) - 1:
                        self.manager.current_selection['index'] = current_index + 1
            elif current_type == 'icon':
                items = list(self.manager.clipboard_items.keys())
                if event.keysym == 'Up':
                    if current_index >= self.manager.icons_per_card:
                        self.manager.current_selection = {'type': 'card', 'index': (current_index // self.manager.icons_per_card) - 1}
                    else:
                        self.manager.current_selection = {'type': 'button', 'index': 0}
                elif event.keysym == 'Down':
                    next_card_index = (current_index // self.manager.icons_per_card) + 1
                    if next_card_index < len(items):
                        self.manager.current_selection = {'type': 'card', 'index': next_card_index}
                
            if len(self.manager.cards_frame.winfo_children()) > 0:
                target_widget = None
                if current_type == 'card' and self.manager.current_selection['index'] < len(self.manager.clipboard_items):
                    target_widget = self.manager.cards_frame.winfo_children()[self.manager.current_selection['index']]
                
                if target_widget:
                    self.ensure_visible(target_widget)
            
            self.update_highlights()
            
        except Exception as e:
            print(f"Error en navegaci√≥n vertical: {e}")

    @measure_time
    def navigate_horizontal(self, event):
        if not self.manager.is_visible:
            return
        
        current_type = self.manager.current_selection['type']
        current_index = self.manager.current_selection['index']
        
        try:
            if current_type == 'button':
                if event.keysym == 'Left':
                    if current_index > 0:
                        self.manager.current_selection['index'] = current_index - 1
                elif event.keysym == 'Right':
                    if current_index < self.manager.total_buttons - 1:
                        self.manager.current_selection['index'] = current_index + 1
            
            elif current_type == 'card':
                if event.keysym == 'Right':
                    self.manager.current_selection = {
                        'type': 'icon', 
                        'index': current_index * self.manager.icons_per_card
                    }
            
            elif current_type == 'icon':
                card_index = current_index // self.manager.icons_per_card
                icon_position = current_index % self.manager.icons_per_card
                
                if event.keysym == 'Left':
                    if icon_position > 0:
                        self.manager.current_selection['index'] = current_index - 1
                    else:
                        self.manager.current_selection = {'type': 'card', 'index': card_index}
                elif event.keysym == 'Right':
                    if icon_position < self.manager.icons_per_card - 1:
                        self.manager.current_selection['index'] = current_index + 1
            
            self.update_highlights()
            
        except Exception as e:
            print(f"Error en navegaci√≥n horizontal: {e}")

    @measure_time
    def activate_selected(self, event=None):
        start_time = time.time()
        current_type = self.manager.current_selection['type']
        current_index = self.manager.current_selection['index']
        
        if current_type == 'button':
            if current_index == 2:  # Bot√≥n 3
                self.manager.functions.toggle_paste_format()
        elif current_type == 'card':
            items = list(self.manager.clipboard_items.items())
            if current_index < len(items):
                item_id, item_data = items[current_index]
                clipboard_data = item_data['text']
                self.paste_content(clipboard_data)
        elif current_type == 'icon':
            items = list(self.manager.clipboard_items.keys())
            card_index = current_index // self.manager.icons_per_card
            icon_position = current_index % self.manager.icons_per_card
            
            if card_index < len(items):
                item_id = items[card_index]
                if icon_position == 0:  # Arrow
                    pass
                elif icon_position == 1:  # Pin
                    self.manager.functions.toggle_pin(item_id)
                elif icon_position == 2:  # Delete
                    self.manager.functions.delete_item(item_id)

        end_time = time.time()
        print(f"Tiempo total de operaci√≥n: {(end_time - start_time) * 1000:.2f} ms")

    @measure_time
    def paste_content(self, clipboard_data):
        try:
            self.hide_window()
            
            # Copiar el contenido al portapapeles
            pyperclip.copy(clipboard_data)
            
            # Esperar un poco para asegurar que el portapapeles se ha actualizado
            time.sleep(0.05)
            
            if self.manager.previous_window:
                # Cambiar al foco a la ventana anterior
                win32gui.SetForegroundWindow(self.manager.previous_window)
                
                # Esperar un poco para asegurar que la ventana tiene el foco
                time.sleep(0.05)
                
                # Crear un objeto shell para enviar las teclas
                shell = win32com.client.Dispatch("WScript.Shell")
                
                # Enviar Ctrl+V para pegar
                shell.SendKeys("^v")
                
        except Exception as e:
            print(f"Error en el proceso de pegado: {e}")
    
    def hide_window(self, event=None):
        try:
            self.manager.root.attributes('-topmost', False)
            self.manager.root.withdraw()
            self.manager.is_visible = False
            self.restore_focus()
        except Exception as e:
            print(f"Error al ocultar la ventana: {e}")

    def restore_focus(self):
        if self.manager.previous_window:
            try:
                win32gui.SetForegroundWindow(self.manager.previous_window)
            except Exception as e:
                print(f"Error al restaurar el foco: {e}")
                try:
                    self.manager.root.after(100, lambda: win32gui.SetForegroundWindow(self.manager.previous_window))
                except:
                    pass

    def check_window_state(self):
        try:
            actual_visible = self.manager.root.winfo_viewable()
            if actual_visible != self.manager.is_visible:
                print(f"Corrigiendo estado de visibilidad: {self.manager.is_visible} -> {actual_visible}")
                self.manager.is_visible = actual_visible
        except Exception as e:
            print(f"Error al verificar estado de la ventana: {e}")

    def update_active_window(self):
        self.manager.last_active_window = win32gui.GetForegroundWindow()

    @measure_time
    def show_window(self):
        try:
            self.manager.previous_window = win32gui.GetForegroundWindow()
            
            self.manager.root.deiconify()
            self.manager.root.geometry("+0+0") 
            self.manager.root.lift()  
            self.manager.root.attributes('-topmost', True)
            
            self.manager.is_visible = True
            
            self.initialize_focus()
        
            if not hasattr(self.manager, 'current_selection') or not self.manager.current_selection:
                self.manager.current_selection = {'type': 'card', 'index': 0}
            
            self.manager.root.focus_force()
            self.update_highlights()
            
        except Exception as e:
            print(f"Error al mostrar la ventana: {e}")

    def initialize_focus(self):
        try:
            if not hasattr(self.manager, 'current_selection') or not self.manager.current_selection:
                self.manager.current_selection = {'type': 'card', 'index': 0}
                
            self.manager.root.focus_force()
            
            self.manager.root.update_idletasks()
            
            self.update_highlights()
            
        except Exception as e:
            print(f"Error al inicializar foco: {e}")

    def handle_focus(self, event=None):
        if self.manager.is_visible:
            self.manager.root.focus_force()

    @measure_time
    def toggle_window(self):
        try:
            if self.manager.is_visible:
                self.hide_window()
            else:
                self.manager.previous_window = win32gui.GetForegroundWindow()
                self.show_window()
        except Exception as e:
            print(f"Error al alternar la ventana: {e}")

    def handle_global_key(self, key):
        if self.manager.is_visible:
            if key in ['Up', 'Down']:
                self.navigate_vertical(type('Event', (), {'keysym': key})())
            elif key in ['Left', 'Right']:
                self.navigate_horizontal(type('Event', (), {'keysym': key})())
            elif key == 'Return':
                self.activate_selected()
            # Actualizar la interfaz
            self.manager.root.update_idletasks()
            # Prevenir que la tecla se propague
            return False
        return True
    
    def start_move(self, event):
        self.manager.x = event.x
        self.manager.y = event.y

    def on_move(self, event):
        dx = event.x - self.manager.x
        dy = event.y - self.manager.y
        x = self.manager.root.winfo_x() + dx
        y = self.manager.root.winfo_y() + dy
        self.manager.root.geometry("+{}+{}".format(x, y))
        self.manager.x = event.x
        self.manager.y = event.y

    def ensure_visible(self, widget):
        if widget is None:
            return
            
        try:
            bbox = self.manager.canvas.bbox("all")
            if bbox:
                widget_y = widget.winfo_y()
                canvas_height = self.manager.canvas.winfo_height()
                if widget_y > 0:
                    self.manager.canvas.yview_moveto(widget_y / bbox[3])
        except Exception as e:
            print(f"Error al asegurar visibilidad: {e}")

    @measure_time
    def update_highlights(self):
        self.clear_all_highlights()
        
        current_type = self.manager.current_selection['type']
        current_index = self.manager.current_selection['index']
        
        highlight_color = '#444444' if self.manager.is_dark_mode else '#cccccc'
        icon_highlight_color = '#666666' if self.manager.is_dark_mode else '#aaaaaa'
        
        try:
            if current_type == 'button':
                buttons = [self.manager.button1, self.manager.button2, self.manager.button3]
                if 0 <= current_index < len(buttons):
                    buttons[current_index].configure(bg=highlight_color)
            
            elif current_type == 'card':
                cards = self.manager.cards_frame.winfo_children()
                if current_index < len(cards):
                    card = cards[current_index]
                    self.highlight_entire_card(card, highlight_color)
                    self.ensure_visible(card)
            
            elif current_type == 'icon':
                card_index = current_index // self.manager.icons_per_card
                icon_position = current_index % self.manager.icons_per_card
                cards = self.manager.cards_frame.winfo_children()
                
                if card_index < len(cards):
                    card = cards[card_index]
                    icons_frame = None
                    
                    for child in card.winfo_children():
                        if isinstance(child, tk.Frame) and child.winfo_children() and isinstance(child.winfo_children()[0], tk.Button):
                            icons_frame = child
                            break
                    
                    if icons_frame and icon_position < len(icons_frame.winfo_children()):
                        icons = icons_frame.winfo_children()
                        if 0 <= icon_position < len(icons):
                            icons[icon_position].configure(bg=icon_highlight_color)
                    self.ensure_visible(card)
                    
        except Exception as e:
            print(f"Error al actualizar highlights: {e}")

    def clear_all_highlights(self):
        theme = self.manager.theme_manager.colors['dark' if self.manager.is_dark_mode else 'light']
        base_color = theme['card_bg']
        
        buttons = [self.manager.button1, self.manager.button2, self.manager.button3]
        for button in buttons:
            button.configure(bg=theme['button_bg'])
        
        for card in self.manager.cards_frame.winfo_children():
            card.configure(bg=base_color)
            
            for child in card.winfo_children():
                child.configure(bg=base_color)
                if isinstance(child, tk.Frame):
                    for subchild in child.winfo_children():
                        if isinstance(subchild, (tk.Label, tk.Button)):
                            subchild.configure(bg=base_color)

    def highlight_entire_card(self, card, color):
        card.configure(bg=color)
    
        text_frame = card.winfo_children()[0]  
        text_frame.configure(bg=color)
        for subwidget in text_frame.winfo_children():
            if isinstance(subwidget, tk.Label):
                subwidget.configure(bg=color)
        
        theme = self.manager.theme_manager.colors['dark' if self.manager.is_dark_mode else 'light']
        icons_frame = card.winfo_children()[-1]
        icons_frame.configure(bg=theme['card_bg'])
        for icon in icons_frame.winfo_children():
            icon.configure(bg=theme['card_bg'])
            
            
