// Archivo: functions.py
# functions.py

import base64
import re
import tkinter as tk
import uuid
import win32con # type: ignore
import win32clipboard # type: ignore
import win32gui # type: ignore
import time
import sys
from bs4 import BeautifulSoup
from utils import measure_time, process_text

# Definir CF_HTML ya que no está en win32con
CF_HTML = win32clipboard.RegisterClipboardFormat("HTML Format")

class Functions:
    def __init__(self, manager):
        self.manager = manager
        self.min_card_height = 40  # Altura mínima en píxeles (2 líneas + 2*2 padding)
        self.max_card_height = 76  # Altura máxima en píxeles (4 líneas + 2*2 padding)
        self.line_height = 18  # Altura estimada de una línea de texto


    @measure_time
    def create_card(self, item_id, item_data, index):
        card_width = self.manager.window_width - 4  # Ajuste para el padding
        card_height = max(self.min_card_height, self.calculate_card_height(item_data['text']))
        
        # Procesamos el texto para mostrarlo de forma limpia
        if isinstance(item_data['text'], dict):
            processed_text = process_text(item_data['text'].get('text', ''), 3)
        else:
            processed_text = process_text(str(item_data['text']), 3)
        
        # Obtén el color de fondo actual
        current_theme = 'dark' if self.manager.is_dark_mode else 'light'
        bg_color = self.manager.theme_manager.colors[current_theme]['card_bg']

        card_container = tk.Frame(self.manager.cards_frame, width=card_width, height=card_height, bg=bg_color)
        card_container.pack(fill=tk.BOTH, padx=2, pady=2)
        card_container.pack_propagate(False)  # Evita que el contenido afecte el tamaño del contenedor

        text_frame = tk.Frame(card_container, bg=bg_color)
        text_frame.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)

        # Procesamos el texto para mostrarlo de forma limpia
        processed_text = process_text(item_data['text'], 3)

        text_label = tk.Label(text_frame, text=processed_text,
                            justify=tk.LEFT, anchor='w', padx=10, pady=5,
                            bg=card_container['bg'],
                            fg=self.manager.theme_manager.colors['dark' if self.manager.is_dark_mode else 'light']['fg'], width=int(24))
        text_label.pack(fill=tk.X, expand=True, side=tk.LEFT)

        icons_frame = tk.Frame(card_container, bg=card_container['bg'])
        icons_frame.pack(side=tk.RIGHT, padx=3)

        arrow_button = tk.Button(icons_frame, text="➡️",
                                command=lambda: self.on_arrow_click(item_id),
                                font=('Segoe UI', 10), bd=0,
                                padx=2,
                                bg=card_container['bg'],
                                fg=self.manager.theme_manager.colors['dark' if self.manager.is_dark_mode else 'light']['fg'])
        arrow_button.pack(side=tk.LEFT)
        
        pin_text = "📌" if item_data['pinned'] else "📍"
        pin_button = tk.Button(icons_frame, text=pin_text,
                            command=lambda: self.toggle_pin(item_id),
                            font=('Segoe UI', 10), bd=0,
                            padx=2,
                            bg=card_container['bg'],
                            fg=self.manager.theme_manager.colors['dark' if self.manager.is_dark_mode else 'light']['fg'])
        pin_button.pack(side=tk.LEFT)

        delete_button = tk.Button(icons_frame, text="✖️",
                                command=lambda: self.delete_item(item_id),
                                font=('Segoe UI', 10), bd=0,
                                padx=2,
                                bg=card_container['bg'],
                                fg=self.manager.theme_manager.colors['dark' if self.manager.is_dark_mode else 'light']['fg'])
        delete_button.pack(side=tk.LEFT)
        
        return card_container
    
    def calculate_card_height(self, text_data):
        if isinstance(text_data, dict):
            text = text_data.get('text', '')
        else:
            text = str(text_data)
        lines = len(text.split('\n'))
        content_height = min(lines * self.line_height, 4 * self.line_height)  # Máximo 4 líneas
        return min(max(content_height + 4, self.min_card_height), self.max_card_height)
    
    @measure_time
    def refresh_cards(self):
        if not hasattr(self.manager, 'cards_frame') or not self.manager.cards_frame.winfo_exists():
            print("cards_frame no existe o ha sido destruido")
            return
        # Eliminar tarjetas obsoletas
        existing_cards = {child.item_id: child for child in self.manager.cards_frame.winfo_children() if hasattr(child, 'item_id')}
        
        for item_id in list(existing_cards.keys()):
            if item_id not in self.manager.clipboard_items:
                existing_cards[item_id].destroy()
                del existing_cards[item_id]

        # Actualizar o crear nuevas tarjetas
        for index, (item_id, item_data) in enumerate(self.manager.clipboard_items.items()):
            if item_id in existing_cards:
                card = existing_cards[item_id]
                self.update_card(card, item_data)
            else:
                card = self.create_card(item_id, item_data, index)
                card.item_id = item_id

            card.pack(fill=tk.X, padx=2, pady=2)

        # Actualizar la región de desplazamiento
        self.manager.canvas.update_idletasks()
        self.manager.canvas.configure(scrollregion=self.manager.canvas.bbox("all"))
        self.recalculate_card_heights()
        # Asegurarse de que el scroll esté en la parte superior después de actualizar
        self.manager.canvas.yview_moveto(0)
        

    def update_card(self, card, item_data):
        processed_text = process_text(item_data['text'], 3)
        text_label = card.winfo_children()[0].winfo_children()[0]
        text_label.config(text=processed_text)

        new_height = self.calculate_card_height(processed_text)
        card.config(height=new_height)

        # Actualizar el estado del botón de pin
        pin_button = card.winfo_children()[1].winfo_children()[1]
        pin_text = "📌" if item_data['pinned'] else "📍"
        pin_button.config(text=pin_text)
        
    def apply_theme_to_card(self, card, theme):
        card.configure(bg=theme['card_bg'])
        
        for child in card.winfo_children():
            if isinstance(child, tk.Frame):
                child.configure(bg=theme['card_bg'])
                for subchild in child.winfo_children():
                    if isinstance(subchild, (tk.Label, tk.Button)):
                        subchild.configure(bg=theme['card_bg'], fg=theme['fg'])
            elif isinstance(child, (tk.Label, tk.Button)):
                child.configure(bg=theme['card_bg'], fg=theme['fg'])

    def toggle_pin(self, item_id):
        if item_id in self.manager.clipboard_items:
            self.manager.clipboard_items[item_id]['pinned'] = not self.manager.clipboard_items[item_id]['pinned']
            self.refresh_cards()
            self.manager.group_manager.save_groups()  # Guardar después de cambiar el estado de anclaje

    def delete_item(self, item_id):
        if item_id in self.manager.clipboard_items and not self.manager.clipboard_items[item_id]['pinned']:
            del self.manager.clipboard_items[item_id]
            self.refresh_cards()
            self.manager.group_manager.save_groups()  # Guardar después de eliminar un item

    
    def clear_history(self):
        self.manager.clipboard_items = {k: v for k, v in self.manager.clipboard_items.items() if v['pinned']}
        self.refresh_cards()
        self.manager.group_manager.save_groups()  # Guardar después de limpiar el historial
        if self.manager.current_selection['type'] == 'card':
            self.manager.current_selection = {'type': 'button', 'index': 0}
        self.manager.navigation.update_highlights()

    def on_canvas_configure(self, event):
        self.manager.canvas.configure(scrollregion=self.manager.canvas.bbox("all"))

    def on_mousewheel(self, event):
        self.manager.canvas.yview_scroll(int(-1 * (event.delta / 120)), "units")

    @measure_time
    def monitor_clipboard(self):
        while True:
            try:
                clipboard_content = self.get_clipboard_text()
                if clipboard_content and clipboard_content != self.manager.current_clipboard:
                    self.manager.current_clipboard = clipboard_content
                    if clipboard_content['text'] not in [item['text'].get('text', '') if isinstance(item['text'], dict) else item['text'] for item in self.manager.clipboard_items.values()]:
                        new_id = str(uuid.uuid4())
                        new_item = {
                            'text': clipboard_content,
                            'pinned': False,
                            'with_format': self.manager.paste_with_format
                        }
                        # Usar after para actualizar la GUI en el hilo principal
                        self.manager.root.after(0, self.add_clipboard_item, new_id, new_item)
            except Exception as e:
                print(f"Error en monitor_clipboard: {e}")
            time.sleep(0.5)
            
    def add_clipboard_item(self, new_id, new_item):
        # Asegúrate de que new_item['text'] siempre sea un diccionario
        if isinstance(new_item['text'], str):
            new_item['text'] = {'text': new_item['text'], 'formatted': {}}
        elif not isinstance(new_item['text'], dict):
            new_item['text'] = {'text': str(new_item['text']), 'formatted': {}}

        self.manager.clipboard_items[new_id] = new_item
        if len(self.manager.clipboard_items) > 20:
            unpinned_items = [k for k, v in self.manager.clipboard_items.items() if not v['pinned']]
            if unpinned_items:
                del self.manager.clipboard_items[unpinned_items[-1]]
        self.refresh_cards()
        self.manager.group_manager.save_groups()

    # @measure_time
    def get_clipboard_text(self):
        try:
            win32clipboard.OpenClipboard()
            formats = []
            format_id = win32clipboard.EnumClipboardFormats(0)
            while format_id:
                formats.append(format_id)
                format_id = win32clipboard.EnumClipboardFormats(format_id)
            
            text = None
            format_info = {}
            
            if win32con.CF_UNICODETEXT in formats:
                text = win32clipboard.GetClipboardData(win32con.CF_UNICODETEXT)
            
            if win32con.CF_RTF in formats:
                rtf_data = win32clipboard.GetClipboardData(win32con.CF_RTF)
                format_info = self.extract_format_info_from_rtf(rtf_data)
            elif CF_HTML in formats:
                html_data = win32clipboard.GetClipboardData(CF_HTML)
                format_info = self.extract_format_info_from_html(html_data)
            
            win32clipboard.CloseClipboard()
            
            if text:
                if format_info:
                    return {'text': text, 'formatted': format_info}
                else:
                    return text  # Retorna solo el texto si no hay información de formato
            return None
        except Exception as e:
            print(f"Error al obtener texto del portapapeles: {e}")
            return None
        
    def extract_format_info_from_rtf(self, rtf_data):
        format_info = {'rtf': True}
        
        # Extraer información de fuente
        font_match = re.search(r'\\fonttbl.*?{\\f0\\fnil (.*?);}', rtf_data)
        if font_match:
            format_info['font'] = font_match.group(1)

        # Extraer información de tamaño
        size_match = re.search(r'\\fs(\d+)', rtf_data)
        if size_match:
            format_info['size'] = int(size_match.group(1)) / 2  # RTF usa el doble del tamaño real

        # Extraer información de color
        color_match = re.search(r'\\red(\d+)\\green(\d+)\\blue(\d+)', rtf_data)
        if color_match:
            format_info['color'] = (int(color_match.group(1)), int(color_match.group(2)), int(color_match.group(3)))

        # Extraer información de negrita e itálica
        format_info['bold'] = r'\b' in rtf_data
        format_info['italic'] = r'\i' in rtf_data

        return format_info

    def extract_format_info_from_html(self, html_data):
        format_info = {'html': True}
        soup = BeautifulSoup(html_data, 'html.parser')
        
        # Buscar el primer elemento con estilo
        styled_element = soup.find(style=True)
        if styled_element:
            style = styled_element['style']
            
            # Extraer información de fuente
            font_match = re.search(r'font-family:\s*(.*?);', style)
            if font_match:
                format_info['font'] = font_match.group(1)

            # Extraer información de tamaño
            size_match = re.search(r'font-size:\s*(\d+)pt', style)
            if size_match:
                format_info['size'] = int(size_match.group(1))

            # Extraer información de color
            color_match = re.search(r'color:\s*rgb\((\d+),\s*(\d+),\s*(\d+)\)', style)
            if color_match:
                format_info['color'] = (int(color_match.group(1)), int(color_match.group(2)), int(color_match.group(3)))

        # Extraer información de negrita e itálica
        format_info['bold'] = bool(soup.find(['strong', 'b']))
        format_info['italic'] = bool(soup.find(['em', 'i']))

        return format_info
    def exit_app(self):
        self.manager.root.quit()
        sys.exit()
    
    @measure_time    
    def toggle_paste_format(self):
        self.manager.paste_with_format = not self.manager.paste_with_format
        new_text = "Con formato" if self.manager.paste_with_format else "Sin formato"
        self.manager.button2.config(text=new_text)
        self.manager.navigation.update_highlights()
        
    @measure_time
    def recalculate_card_heights(self):
        for card in self.manager.cards_frame.winfo_children():
            if hasattr(card, 'item_id'):
                item_data = self.manager.clipboard_items[card.item_id]
                new_height = self.calculate_card_height(item_data['text'])
                card.config(height=new_height)
        
        self.manager.canvas.update_idletasks()
        self.manager.canvas.configure(scrollregion=self.manager.canvas.bbox("all"))
        
    def on_arrow_click(self, item_id):
        if not self.manager.group_manager.groups:
            tk.messagebox.showinfo("Sin Grupos", "No hay grupos disponibles. Cree un grupo primero.")
            return

        dialog = tk.Toplevel(self.manager.root)
        dialog.title("Seleccionar Grupo")
        
        window_width = self.manager.settings['width']
        window_height = self.manager.settings['height']
        
        x = self.manager.window_x + 20
        y = self.manager.window_y + 20
        
        dialog.geometry(f"{window_width}x{window_height}+{x}+{y}")
                
        # dialog.geometry("295x400")
        dialog.configure(bg=self.manager.theme_manager.colors['dark']['bg'])
        dialog.overrideredirect(True)
        dialog.attributes('-topmost', True)

        # Barra de título personalizada
        title_frame = tk.Frame(dialog, bg=dialog.cget('bg'))
        title_frame.pack(fill=tk.X, padx=5, pady=(5, 0))

        title_label = tk.Label(title_frame, text="Seleccionar Grupo", font=('Segoe UI', 10, 'bold'),
                            bg=dialog.cget('bg'), fg=self.manager.theme_manager.colors['dark']['fg'])
        title_label.pack(side=tk.LEFT, padx=5)

        close_button = tk.Button(title_frame, text="❌", command=dialog.destroy,
                                font=('Segoe UI', 10, 'bold'), bd=0, padx=10,
                                bg=self.manager.theme_manager.colors['dark']['button_bg'],
                                fg=self.manager.theme_manager.colors['dark']['button_fg'])
        close_button.pack(side=tk.RIGHT)

        # Contenido
        content_frame = tk.Frame(dialog, bg=dialog.cget('bg'))
        content_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)

        for group_id, group_info in self.manager.group_manager.groups.items():
            group_button = tk.Button(content_frame, text=group_info['name'],
                                    command=lambda gid=group_id: self.add_to_group(item_id, gid, dialog),
                                    bg=self.manager.theme_manager.colors['dark']['button_bg'],
                                    fg=self.manager.theme_manager.colors['dark']['button_fg'],
                                    activebackground=self.manager.theme_manager.colors['dark']['active_bg'],
                                    activeforeground=self.manager.theme_manager.colors['dark']['active_fg'],
                                    bd=0, padx=10, pady=5, width=30, anchor='w')
            group_button.pack(fill=tk.X, pady=2)

        # Hacer la ventana arrastrable
        def start_move(event):
            dialog.x = event.x
            dialog.y = event.y

        def on_move(event):
            deltax = event.x - dialog.x
            deltay = event.y - dialog.y
            x = dialog.winfo_x() + deltax
            y = dialog.winfo_y() + deltay
            dialog.geometry(f"+{x}+{y}")

        title_frame.bind('<Button-1>', start_move)
        title_frame.bind('<B1-Motion>', on_move)

    def add_to_group(self, item_id, group_id, dialog):
        self.manager.group_manager.add_item_to_group(item_id, group_id)
        dialog.destroy()
        # tk.messagebox.showinfo("Éxito", "Item agregado al grupo exitosamente.")

// Archivo: groups_screen_navigation.py
# groups_screen_navigation.py

import tkinter as tk
import logging

logger = logging.getLogger(__name__)

class GroupsScreenNavigation:
    def __init__(self, manager):
        self.manager = manager
        self.navigation_order = ['top_buttons', 'group_cards']
        logger.debug("GroupsScreenNavigation inicializado")

    def navigate_vertical(self, event):
        logger.debug(f"Navegación vertical: {event.keysym}")
        current_type = self.manager.current_selection['type']
        current_index = self.manager.current_selection['index']
        
        if event.keysym == 'Up':
            self.move_up(current_type, current_index)
        elif event.keysym == 'Down':
            self.move_down(current_type, current_index)

        self.update_highlights()
        self.ensure_visible()
        logger.debug(f"Nueva selección: {self.manager.current_selection}")

    def move_up(self, current_type, current_index):
        logger.debug(f"Moviendo arriba desde {current_type}, {current_index}")
        if current_type == 'group_cards':
            if current_index > 0:
                self.manager.current_selection['index'] = current_index - 1
            else:
                self.manager.current_selection = {'type': 'top_buttons', 'index': 0}
        elif current_type == 'group_card_icons':
            self.manager.current_selection = {'type': 'group_cards', 'index': current_index // 3}
        elif current_type == 'top_buttons':
            # Si ya estamos en los botones superiores, no hacemos nada
            pass

    def move_down(self, current_type, current_index):
        logger.debug(f"Moviendo abajo desde {current_type}, {current_index}")
        if current_type == 'top_buttons':
            if self.get_group_cards_count() > 0:
                self.manager.current_selection = {'type': 'group_cards', 'index': 0}
        elif current_type == 'group_cards':
            if current_index < self.get_group_cards_count() - 1:
                self.manager.current_selection['index'] = current_index + 1
        elif current_type == 'group_card_icons':
            next_card_index = (current_index // 3) + 1
            if next_card_index < self.get_group_cards_count():
                self.manager.current_selection = {'type': 'group_cards', 'index': next_card_index}

    def navigate_horizontal(self, event):
        logger.debug(f"Navegación horizontal: {event.keysym}")
        current_type = self.manager.current_selection['type']
        current_index = self.manager.current_selection['index']

        if event.keysym == 'Left':
            self.move_left(current_type, current_index)
        elif event.keysym == 'Right':
            self.move_right(current_type, current_index)

        self.update_highlights()

    def move_left(self, current_type, current_index):
        if current_type == 'top_buttons':
            self.manager.current_selection['index'] = (current_index - 1) % self.get_top_button_count()
        elif current_type == 'group_card_icons':
            if current_index % 3 > 0:
                self.manager.current_selection['index'] = current_index - 1
            else:
                self.manager.current_selection = {'type': 'group_cards', 'index': current_index // 3}
        self.update_highlights()

    def move_right(self, current_type, current_index):
        if current_type == 'top_buttons':
            self.manager.current_selection['index'] = (current_index + 1) % self.get_top_button_count()
        elif current_type == 'group_cards':
            icons = self.get_card_icons(self.get_group_cards()[current_index])
            if icons:
                self.manager.current_selection = {'type': 'group_card_icons', 'index': current_index * 3}
        elif current_type == 'group_card_icons':
            card_index = current_index // 3
            icon_position = current_index % 3
            icons = self.get_card_icons(self.get_group_cards()[card_index])
            if icon_position < len(icons) - 1:
                self.manager.current_selection['index'] = current_index + 1
        self.update_highlights()

    def activate_selected(self, event=None):
        current_type = self.manager.current_selection['type']
        current_index = self.manager.current_selection['index']

        if current_type == 'top_buttons':
            self.activate_top_button(current_index)
        elif current_type == 'group_cards':
            self.activate_group_card(current_index)
        elif current_type == 'group_card_icons':
            self.activate_group_card_icon(current_index)

    def activate_top_button(self, index):
        if index == 0:  # Botón Añadir Grupo
            self.manager.group_manager.add_group()
        elif index == 1:  # Botón Cerrar
            self.manager.group_manager.close_groups_window()

    def activate_group_card(self, index):
        groups = list(self.manager.group_manager.groups.items())
        if index < len(groups):
            group_id, _ = groups[index]
            self.manager.group_manager.show_group_content(group_id)

    def activate_group_card_icon(self, index):
        groups = list(self.manager.group_manager.groups.items())
        card_index = index // 3
        icon_position = index % 2
        
        if card_index < len(groups):
            group_id, _ = groups[card_index]
            if icon_position == 0:  # Edit
                self.manager.group_manager.edit_group(group_id)
            elif icon_position == 1:  # Delete
                self.manager.group_manager.delete_group(group_id)

    def update_highlights(self):
        logger.debug("Actualizando highlights")
        self.clear_all_highlights()
        
        current_type = self.manager.current_selection['type']
        current_index = self.manager.current_selection['index']
        
        highlight_color = '#444444' if self.manager.is_dark_mode else '#cccccc'
        icon_highlight_color = '#666666' if self.manager.is_dark_mode else '#aaaaaa'
        
        if current_type == 'top_buttons':
            top_buttons = self.get_top_buttons()
            if 0 <= current_index < len(top_buttons):
                top_buttons[current_index].configure(bg=highlight_color)
        
        elif current_type == 'group_cards':
            group_cards = self.get_group_cards()
            if current_index < len(group_cards):
                self.highlight_group_card(group_cards[current_index], highlight_color)
        
        elif current_type == 'group_card_icons':
            card_index = current_index // 3
            icon_position = current_index % 3
            group_cards = self.get_group_cards()
            
            if card_index < len(group_cards):
                card = group_cards[card_index]
                icons = self.get_card_icons(card)
                
                if icons and 0 <= icon_position < len(icons):
                    self.highlight_group_card(card, highlight_color)
                    icons[icon_position].configure(bg=icon_highlight_color)

    def clear_all_highlights(self):
        theme = self.manager.theme_manager.colors['dark' if self.manager.is_dark_mode else 'light']
        base_color = theme['card_bg']
        button_color = theme['button_bg']
        
        for button in self.get_top_buttons():
            button.configure(bg=button_color)
        
        for card in self.get_group_cards():
            self.reset_card_colors(card, base_color, button_color)

    def reset_card_colors(self, card, base_color, button_color):
        card.configure(bg=base_color)
        for child in card.winfo_children():
            if isinstance(child, tk.Label):
                child.configure(bg=base_color)
            elif isinstance(child, tk.Frame):  # Para el frame de iconos
                child.configure(bg=base_color)
                for icon in child.winfo_children():
                    if isinstance(icon, tk.Button):
                        icon.configure(bg=button_color, bd=0, highlightthickness=0)

    def highlight_group_card(self, card, color):
        card.configure(bg=color)
        for child in card.winfo_children():
            if isinstance(child, tk.Label):
                child.configure(bg=color)
            elif isinstance(child, tk.Frame):  # Para el frame de iconos
                child.configure(bg=color)

    def ensure_visible(self):
        current_type = self.manager.current_selection['type']
        current_index = self.manager.current_selection['index']
        
        if current_type in ['group_cards', 'group_card_icons']:
            group_cards = self.get_group_cards()
            if current_index < len(group_cards):
                widget = group_cards[current_index]
                bbox = self.manager.group_manager.canvas.bbox("all")
                if bbox:
                    widget_y = widget.winfo_y()
                    canvas_height = self.manager.group_manager.canvas.winfo_height()
                    if widget_y > 0:
                        self.manager.group_manager.canvas.yview_moveto(widget_y / bbox[3])

    def initialize_focus(self):
        logger.debug("Inicializando foco")
        if self.get_group_cards_count() > 0:
            self.manager.current_selection = {'type': 'group_cards', 'index': 0}
        else:
            self.manager.current_selection = {'type': 'top_buttons', 'index': 0}
        
        self.update_highlights()
        logger.debug(f"Foco inicial: {self.manager.current_selection}")

    def get_group_cards_count(self):
        return len(self.manager.group_manager.groups)

    def get_top_buttons(self):
        return [self.manager.group_manager.add_button, self.manager.group_manager.close_button]

    def get_group_cards(self):
        return self.manager.group_manager.groups_frame.winfo_children()

    def get_top_button_count(self):
        return len(self.get_top_buttons())

    def get_card_icons(self, card):
        icons_frame = [child for child in card.winfo_children() if isinstance(child, tk.Frame)]
        if icons_frame:
            return icons_frame[0].winfo_children()
        return []

// Archivo: group_content_manager.py
# group_content_manager.py

import tkinter as tk
from tkinter import ttk

from utils import process_text

class GroupContentManager:
    def __init__(self, master, clipboard_manager, theme_manager, settings_manager):
        self.master = master
        self.clipboard_manager = clipboard_manager
        self.theme_manager = theme_manager
        self.settings_manager = settings_manager
        self.content_window = None
        self.canvas = None
        self.scrollbar = None
        self.items_frame = None

        self.min_card_height = 50  # Altura mínima en píxeles (2 líneas + 2*2 padding)
        self.max_card_height = 120  # Altura máxima en píxeles (4 líneas + 2*2 padding)
        self.line_height = 10      # Altura estimada de una línea de texto

    def calculate_card_height(self, text_data):
        if isinstance(text_data, dict):
            text = text_data.get('text', '')
        else:
            text = str(text_data)
        
        lines = len(text.split('\n'))
        if lines > 2:
            content_height = min(lines * (self.line_height*2), 7 * self.line_height)  # Máximo 4 líneas
        else:
            content_height = min(lines * self.line_height, 5 * self.line_height)  # Máximo 4 líneas
        return min(max(content_height + 5, self.min_card_height), self.max_card_height)

    def show_group_content(self, group_id):
        if self.content_window is None or not self.content_window.winfo_exists():
            self.content_window = tk.Toplevel(self.master)
            self.content_window.title(f"Contenido del Grupo: {self.clipboard_manager.group_manager.groups[group_id]['name']}")
            
            window_width = self.settings_manager.settings['width']
            window_height = self.settings_manager.settings['height']
            
            x = self.clipboard_manager.window_x 
            y = self.clipboard_manager.window_y 
            
            self.content_window.geometry(f"{window_width}x{window_height}+{x}+{y}")
                    
            self.content_window.overrideredirect(True)
            self.content_window.configure(bg=self.theme_manager.colors['dark']['bg'])
            self.content_window.attributes('-topmost', True)

            # Barra de título personalizada
            title_frame = tk.Frame(self.content_window, bg=self.theme_manager.colors['dark']['bg'])
            title_frame.pack(fill=tk.X, padx=6, pady=(0,0))

            title_label = tk.Label(title_frame, text=f"Grupo: {self.clipboard_manager.group_manager.groups[group_id]['name']}", 
                                font=('Segoe UI', 10, 'bold'),
                                bg=self.theme_manager.colors['dark']['bg'],
                                fg=self.theme_manager.colors['dark']['fg'])
            title_label.pack(side=tk.LEFT, padx=5, pady=5)

            close_button = tk.Button(title_frame, text="❌", command=lambda: self.close_content_window(group_id),
                                    font=('Segoe UI', 10, 'bold'),bd=0, padx=10, width=5, height=2,
                                    bg=self.theme_manager.colors['dark']['button_bg'],
                                    fg=self.theme_manager.colors['dark']['button_fg'])
            close_button.pack(side=tk.RIGHT)

            # Canvas y scroll para los items
            self.canvas = tk.Canvas(self.content_window, bg=self.theme_manager.colors['dark']['bg'], highlightthickness=0)
            self.canvas.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)

            self.scrollbar = ttk.Scrollbar(self.content_window, orient="vertical", command=self.canvas.yview)
            self.scrollbar.pack(side=tk.RIGHT, fill=tk.Y)

            self.canvas.configure(yscrollcommand=self.scrollbar.set)

            self.items_frame = tk.Frame(self.canvas, bg=self.theme_manager.colors['dark']['bg'])
            self.canvas.create_window((0, 0), window=self.items_frame, anchor='nw', width=window_width)
            self.canvas_window = self.canvas.create_window((0, 0), window=self.items_frame, anchor='nw', width=window_width)

            # Configurar el desplazamiento con la rueda del ratón
            def _on_mousewheel(event):
                self.canvas.yview_scroll(int(-1*(event.delta/120)), "units")

            self.canvas.bind_all("<MouseWheel>", _on_mousewheel)

            # Asegurar que el ancho del frame interior se ajuste al canvas
            def _configure_inner_frame(event):
                if self.canvas.winfo_exists():
                    self.canvas.itemconfig(self.canvas_window, width=event.width)
            
            self.canvas.bind('<Configure>', _configure_inner_frame)

            # Hacer la ventana arrastrable
            title_frame.bind('<Button-1>', self.start_move)
            title_frame.bind('<B1-Motion>', self.on_move)

        else:
            self.content_window.deiconify()  # Muestra la ventana si estaba oculta
            self.content_window.lift()
            self.content_window.attributes('-topmost', True)
            self.content_window.after_idle(self.content_window.attributes, '-topmost', False)

        # Mostrar items del grupo
        self.refresh_group_content(group_id)

        # Restaurar la posición del scroll
        if hasattr(self, 'scroll_position'):
            self.canvas.yview_moveto(self.scroll_position)

    def close_content_window(self, group_id):
        if self.canvas:
            # Guardar la posición actual del scroll
            self.scroll_position = self.canvas.yview()[0]
        self.content_window.withdraw()
        self.clipboard_manager.group_manager.show_groups_window()

    def start_move(self, event):
        self.x = event.x
        self.y = event.y

    def on_move(self, event):
        deltax = event.x - self.x
        deltay = event.y - self.y
        x = self.content_window.winfo_x() + deltax
        y = self.content_window.winfo_y() + deltay
        self.content_window.geometry(f"+{x}+{y}")
        
    def refresh_group_content(self, group_id):
        # Limpiar el frame de items existente
        for widget in self.items_frame.winfo_children():
            widget.destroy()
        
        window_width = self.settings_manager.settings['width']
        window_height = self.settings_manager.settings['height'] - 40  # Ajuste para la barra de título

        current_theme = 'dark'  # Puedes cambiar esto si soportas modo claro/oscuro
        theme = self.theme_manager.colors[current_theme]

        for item in self.clipboard_manager.group_manager.groups[group_id]['items']:
            card_width = window_width - 4  # Ajuste mínimo para el padding
            card_height = max(self.min_card_height, self.calculate_card_height(item['text']))
    
            bg_color = theme['card_bg']
    
            card_container = tk.Frame(self.items_frame, width=card_width, height=card_height, bg=bg_color)
            card_container.pack(fill=tk.X, padx=6, pady=(4,0))
            card_container.pack_propagate(False)  # Evita que el contenido afecte el tamaño del contenedor

            text_frame = tk.Frame(card_container, bg=bg_color, pady=0)
            text_frame.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)

            # Procesamos el texto para mostrarlo de forma limpia
            processed_text = process_text(item['text'], 2)
            item_name = item.get('name', '')

            # Etiqueta para item_name en negrita y tamaño de fuente mayor
            if item_name:
                item_name_label = tk.Label(
                    text_frame,
                    text=f"{item_name}:",
                    font=("Segoe UI", 10, "bold"),
                    bg=bg_color,
                    fg=theme['fg'],
                    justify=tk.LEFT,
                    anchor='w',
                    width=int(24)
                )
                item_name_label.pack(padx=2, pady=0, fill=tk.X, side=tk.TOP, anchor='w')

            # Etiqueta para processed_text con fuente regular
            text_label = tk.Label(
                text_frame,
                text=processed_text,
                font=("Segoe UI", 10),
                justify=tk.LEFT,
                anchor='w',
                bg=bg_color,
                fg=theme['fg'],
                width=int(24)
            )
            text_label.pack(padx=6, pady=(0,4), fill=tk.X, expand=True, side=tk.TOP)
            
            icons_frame = tk.Frame(card_container, bg=bg_color)
            icons_frame.pack(side=tk.RIGHT, padx=3)

            edit_button = tk.Button(icons_frame, text="✏️", 
                                    command=lambda i=item['id']: self.edit_group_item(group_id, i),
                                    font=('Segoe UI', 10), bd=0,
                                    padx=2,
                                    bg=bg_color,
                                    fg=theme['fg'])
            edit_button.pack(side=tk.LEFT)

            delete_button = tk.Button(icons_frame, text="🗑️", 
                                    command=lambda i=item['id']: self.remove_item_from_group(group_id, i, self.items_frame),
                                    font=('Segoe UI', 10), bd=0,
                                    padx=2,
                                    bg=bg_color,
                                    fg=theme['fg'])
            delete_button.pack(side=tk.LEFT)

        # Actualizar el scrollregion después de añadir todos los widgets
        self.items_frame.update_idletasks()
        self.canvas.config(scrollregion=self.canvas.bbox("all"))
        
    def remove_item_from_group(self, group_id, item_id, items_frame):
        self.clipboard_manager.group_manager.groups[group_id]['items'] = [item for item in self.clipboard_manager.group_manager.groups[group_id]['items'] if item['id'] != item_id]
        self.clipboard_manager.group_manager.save_groups()
        self.refresh_group_content(group_id)

    def edit_group_item(self, group_id, item_id):
        item = next((item for item in self.clipboard_manager.group_manager.groups[group_id]['items'] if item['id'] == item_id), None)
        if not item:
            return

        dialog = tk.Toplevel(self.master)
        dialog.title("Editar Item")
        
        x = self.clipboard_manager.window_x + 40
        y = self.clipboard_manager.window_y + 40
        
        if isinstance(item['text'], dict):
            text = item['text'].get('text', '')
            original_format = item['text'].get('formatted', {})
        else:
            text = str(item['text'])
            original_format = {}
        
        text_lines = text.count('\n') + 1
        initial_height = min(150 + (text_lines * 20), 600)
        
        dialog.geometry(f"300x{initial_height}+{x}+{y}")
        
        dialog.configure(bg=self.theme_manager.colors['dark']['bg'])
        dialog.overrideredirect(True)
        dialog.attributes('-topmost', True)

        title_frame = tk.Frame(dialog, bg=self.theme_manager.colors['dark']['bg'])
        title_frame.pack(fill=tk.X, padx=4, pady=(4, 0))

        title_label = tk.Label(title_frame, text="Editar Item", font=('Segoe UI', 10, 'bold'),
                            bg=self.theme_manager.colors['dark']['bg'],
                            fg=self.theme_manager.colors['dark']['fg'])
        title_label.pack(side=tk.LEFT, padx=0)

        close_button = tk.Button(title_frame, text="❌", command=dialog.destroy,
                                font=('Segoe UI', 10, 'bold'), bd=0, padx=0,
                                bg=self.theme_manager.colors['dark']['button_bg'],
                                fg=self.theme_manager.colors['dark']['button_fg'])
        close_button.pack(side=tk.RIGHT)
        
        content_frame = tk.Frame(dialog, bg=self.theme_manager.colors['dark']['bg'])
        content_frame.pack(fill=tk.BOTH, expand=True, padx=4, pady=0)

        name_label = tk.Label(content_frame, text="Nombre del item:",
                            bg=self.theme_manager.colors['dark']['bg'],
                            fg=self.theme_manager.colors['dark']['fg'])
        name_label.pack(anchor='w', pady=(0, 5))

        name_entry = tk.Entry(content_frame, bg=self.theme_manager.colors['dark']['button_bg'],
                            fg=self.theme_manager.colors['dark']['fg'],
                            insertbackground=self.theme_manager.colors['dark']['fg'],
                            font=('Segoe UI', 10))
        name_entry.insert(0, item.get('name', ''))
        name_entry.pack(fill=tk.X, pady=(0, 5))

        text_label = tk.Label(content_frame, text="Texto del item:",
                            bg=self.theme_manager.colors['dark']['bg'],
                            fg=self.theme_manager.colors['dark']['fg'])
        text_label.pack(anchor='w', pady=(0, 5))

        text_entry = tk.Text(content_frame, height=3, bg=self.theme_manager.colors['dark']['button_bg'],
                            fg=self.theme_manager.colors['dark']['fg'],
                            insertbackground=self.theme_manager.colors['dark']['fg'],
                            font=('Segoe UI', 10))
        text_entry.insert(tk.END, text)
        text_entry.pack(fill=tk.BOTH, expand=True, pady=(0, 5))

        def save_item():
            new_name = name_entry.get().strip()
            new_text = text_entry.get("1.0", tk.END).strip()
            if new_text:
                item['name'] = new_name
                if new_text != text:
                    # Si el texto ha cambiado, eliminamos el formato
                    item['text'] = {'text': new_text, 'formatted': {}}
                else:
                    # Si el texto no ha cambiado, mantenemos el formato original
                    item['text'] = {'text': new_text, 'formatted': original_format}
                self.clipboard_manager.group_manager.save_groups()
                dialog.destroy()
                self.refresh_group_content(group_id)

        save_button = tk.Button(content_frame, text="Guardar", command=save_item,
                                bg=self.theme_manager.colors['dark']['button_bg'],
                                fg=self.theme_manager.colors['dark']['button_fg'])
        save_button.pack(fill=tk.X, pady=(0, 5))

        # Código para hacer la ventana arrastrable
        def start_move(event):
            dialog.x = event.x
            dialog.y = event.y

        def on_move(event):
            deltax = event.x - dialog.x
            deltay = event.y - dialog.y
            x = dialog.winfo_x() + deltax
            y = dialog.winfo_y() + deltay
            dialog.geometry(f"+{x}+{y}")

        title_frame.bind('<Button-1>', start_move)
        title_frame.bind('<B1-Motion>', on_move)

        # Función para ajustar dinámicamente la altura de la ventana
        def adjust_dialog_height(event=None):
            content = text_entry.get("1.0", tk.END)
            lines = content.count('\n') + 1
            new_height = min(150 + (lines * 20), 600)
            dialog.geometry(f"300x{new_height}")

        text_entry.bind("<KeyRelease>", adjust_dialog_height)

        dialog.focus_set()
        name_entry.focus()

        adjust_dialog_height()

// Archivo: group_manager.py
# group_manager.py

import tkinter as tk
from tkinter import ttk, simpledialog, messagebox
import uuid
from settings_manager import SettingsManager
from group_content_manager import GroupContentManager
import logging

logging.getLogger('chardet').setLevel(logging.WARNING)
logging.basicConfig(level=logging.DEBUG, format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

class GroupManager:
    def __init__(self, master, clipboard_manager):
        self.master = master
        self.clipboard_manager = clipboard_manager
        self.data_manager = clipboard_manager.data_manager
        self.theme_manager = clipboard_manager.theme_manager
        self.settings = clipboard_manager.settings
        self.settings_manager = clipboard_manager.settings_manager
        self.groups, _, _ = self.data_manager.load_data()
        self.groups_window = None
        self.groups_frame = None
        self.group_content_manager = GroupContentManager(master, clipboard_manager, clipboard_manager.theme_manager, clipboard_manager.settings_manager)
        self.canvas = None
        self.scrollbar = None
        self.add_button = None
        self.close_button = None

    def show_group_content(self, group_id):
        if self.groups_window:
            self.groups_window.withdraw()  # Oculta la ventana de grupos
        self.group_content_manager.show_group_content(group_id)


    def show_groups_window(self):
        logger.debug("Intentando mostrar la ventana de grupos")
        if self.groups_window is None or not self.groups_window.winfo_exists():
            logger.debug("Creando nueva ventana de grupos")
            self.groups_window = tk.Toplevel(self.master)
            self.groups_window.title("Grupos")
            
            window_width = self.settings['width']
            window_height = self.settings['height']
            
            x = self.clipboard_manager.window_x 
            y = self.clipboard_manager.window_y 
            
            self.groups_window.geometry(f"{window_width}x{window_height}+{x}+{y}")
            
            self.groups_window.overrideredirect(True)
            self.groups_window.configure(bg=self.theme_manager.colors['dark']['bg'])
            self.groups_window.attributes('-topmost', True)
            self.master.bind("<Destroy>", self.on_main_window_close)

            # Barra de título personalizada
            title_frame = tk.Frame(self.groups_window, bg=self.theme_manager.colors['dark']['bg'])
            title_frame.pack(fill=tk.X, padx=2, pady=(0, 0))

            title_label = tk.Label(title_frame, text="Grupos", font=('Segoe UI', 10, 'bold'), 
                                   bg=self.theme_manager.colors['dark']['bg'], 
                                   fg=self.theme_manager.colors['dark']['fg'])
            title_label.pack(side=tk.LEFT, padx=5)

            # Botones en la barra de título
            buttons_frame = tk.Frame(title_frame, bg=self.theme_manager.colors['dark']['bg'])
            buttons_frame.pack(side=tk.RIGHT, padx=4)

            self.add_button = tk.Button(buttons_frame, text="➕", command=self.add_group, 
                                   font=('Segoe UI', 10), bd=0, padx=10, width=5, height=2,
                                   bg=self.theme_manager.colors['dark']['button_bg'],
                                   fg=self.theme_manager.colors['dark']['button_fg'])
            self.add_button.pack(side=tk.LEFT)

            self.close_button = tk.Button(buttons_frame, text="❌", command=self.close_groups_window, 
                                     font=('Segoe UI', 10, 'bold'), bd=0, padx=10, width=5, height=2,
                                     bg=self.theme_manager.colors['dark']['button_bg'],
                                     fg=self.theme_manager.colors['dark']['button_fg'])
            self.close_button.pack(side=tk.LEFT)
            
            # Canvas para scroll y contenedor de grupos
            self.canvas = tk.Canvas(self.groups_window, bg=self.theme_manager.colors['dark']['bg'], bd=0, highlightthickness=0)
            self.canvas.pack(fill=tk.BOTH, expand=True, padx=2, pady=2)

            # Scrollbar
            self.scrollbar = ttk.Scrollbar(self.groups_window, orient=tk.VERTICAL, command=self.canvas.yview)
            self.canvas.configure(yscrollcommand=self.scrollbar.set)

            # Frame contenedor dentro del canvas para el scroll
            self.groups_frame = tk.Frame(self.canvas, bg=self.theme_manager.colors['dark']['bg'])
            canvas_window = self.canvas.create_window((0, 0), window=self.groups_frame, anchor='nw', width=295)

            # Ajustar el ancho del frame contenedor al canvas
            def on_canvas_resize(event):
                self.canvas.itemconfig(canvas_window, width=event.width)

            self.canvas.bind("<Configure>", on_canvas_resize)

            # Configuración de scroll
            def on_frame_configure(event):
                self.canvas.configure(scrollregion=self.canvas.bbox("all"))

            self.groups_frame.bind("<Configure>", on_frame_configure)

            # Función para desplazamiento con la rueda del mouse
            def _on_mousewheel(event):
                self.canvas.yview_scroll(int(-1*(event.delta/120)), "units")

            self.canvas.bind_all("<MouseWheel>", _on_mousewheel)

            # Hacer la ventana arrastrable
            title_label.bind('<Button-1>', self.start_move)
            title_label.bind('<B1-Motion>', self.on_move)

            self.refresh_groups()

            # Configurar eventos de teclado
            self.groups_window.bind('<Up>', lambda e: self.clipboard_manager.navigation.navigate_vertical(e))
            self.groups_window.bind('<Down>', lambda e: self.clipboard_manager.navigation.navigate_vertical(e))
            self.groups_window.bind('<Left>', lambda e: self.clipboard_manager.navigation.navigate_horizontal(e))
            self.groups_window.bind('<Right>', lambda e: self.clipboard_manager.navigation.navigate_horizontal(e))
            self.groups_window.bind('<Return>', lambda e: self.clipboard_manager.navigation.activate_selected(e))

            # Mostrar la ventana después de configurarla completamente
            self.groups_window.deiconify()
            self.groups_window.focus_force()
            
            # Inicializar el foco después de que la ventana esté visible
            self.groups_window.after(100, self.clipboard_manager.navigation.initialize_focus)
        else:
            logger.debug("Mostrando ventana de grupos existente")
            self.groups_window.deiconify()
            self.groups_window.focus_force()

        self.clipboard_manager.navigation.set_strategy('groups')
        logger.debug("Ventana de grupos mostrada y estrategia de navegación configurada")

        # Restaurar la posición del scroll
        # if hasattr(self, 'scroll_position'):
        #     self.canvas.yview_moveto(self.scroll_position)
         
    def close_groups_window(self):
        if self.canvas:
            # Guardar la posición actual del scroll
            self.scroll_position = self.canvas.yview()[0]
        self.groups_window.withdraw()
        self.clipboard_manager.show_main_screen()
        
    def start_move(self, event):
        self.x = event.x
        self.y = event.y

    def on_move(self, event):
        deltax = event.x - self.x
        deltay = event.y - self.y
        x = self.groups_window.winfo_x() + deltax
        y = self.groups_window.winfo_y() + deltay
        self.groups_window.geometry(f"+{x}+{y}")

    def refresh_groups(self):
        logger.debug("Refrescando grupos")
        if self.groups_frame is None or not self.groups_frame.winfo_exists():
            return

        for widget in self.groups_frame.winfo_children():
            widget.destroy()

        for group_id, group_info in self.groups.items():
            group_card = tk.Frame(self.groups_frame, bg=self.theme_manager.colors['dark']['card_bg'], cursor="hand2")
            group_card.pack(fill=tk.X, padx=8, pady=2)
            
            group_card.bind("<Button-1>", lambda e, gid=group_id: self.show_group_content(gid))

            name_label = tk.Label(group_card, text=group_info['name'], font=("Segoe UI", 10, "bold"),
                                bg=self.theme_manager.colors['dark']['card_bg'],
                                fg=self.theme_manager.colors['dark']['fg'])
            name_label.pack(side=tk.LEFT, padx=5, pady=5)

            count_label = tk.Label(group_card, text=f"Items: {len(group_info['items'])}",
                                bg=self.theme_manager.colors['dark']['card_bg'],
                                fg=self.theme_manager.colors['dark']['fg'])
            count_label.pack(side=tk.LEFT, padx=5, pady=5)
            
            # Frame para los iconos
            icons_frame = tk.Frame(group_card, bg=self.theme_manager.colors['dark']['card_bg'])
            icons_frame.pack(side=tk.RIGHT)

            # edit_button = tk.Button(icons_frame, text="✏️", command=lambda gid=group_id: self.edit_group(gid),
            #                         font=('Segoe UI', 10), bd=0, bg=self.theme_manager.colors['dark']['button_bg'],
            #                         fg=self.theme_manager.colors['dark']['button_fg'])
            edit_button = tk.Button(icons_frame, text="✏️", command=lambda gid=group_id: self.edit_group(gid),
                        font=('Segoe UI', 10), bd=0, highlightthickness=0,
                        bg=self.clipboard_manager.theme_manager.colors['dark']['button_bg'],
                        fg=self.clipboard_manager.theme_manager.colors['dark']['button_fg'])
            edit_button.pack(side=tk.LEFT, padx=4)

            # delete_button = tk.Button(icons_frame, text="🗑️", command=lambda gid=group_id: self.delete_group(gid),
            #                         font=('Segoe UI', 10), bd=0, bg=self.theme_manager.colors['dark']['button_bg'],
            #                         fg=self.theme_manager.colors['dark']['button_fg'])
            delete_button = tk.Button(icons_frame, text="❌", command=lambda gid=group_id: self.delete_group(gid),
                          font=('Segoe UI', 10), bd=0, highlightthickness=0,
                          bg=self.clipboard_manager.theme_manager.colors['dark']['button_bg'],
                          fg=self.clipboard_manager.theme_manager.colors['dark']['button_fg'])
            delete_button.pack(side=tk.LEFT, padx=4)

        # logger.debug(f"Grupos refrescados: {len(self.groups)} grupos")

            
            
    def save_groups(self):
        pinned_items = {k: v for k, v in self.clipboard_manager.clipboard_items.items() if v['pinned']}
        # Asegúrate de que cada item pinned tenga la estructura correcta
        for item_id, item_data in pinned_items.items():
            if isinstance(item_data['text'], str):
                pinned_items[item_id]['text'] = {'text': item_data['text'], 'formatted': {}}
            elif not isinstance(item_data['text'], dict):
                pinned_items[item_id]['text'] = {'text': str(item_data['text']), 'formatted': {}}
        
        self.data_manager.save_data(self.groups, pinned_items, self.clipboard_manager.settings)
        print("Groups and pinned items saved")
        
    def edit_group(self, group_id):
        self.show_edit_group_dialog(group_id)

    def delete_group(self, group_id):
        # if tk.messagebox.askyesno("Eliminar Grupo", "¿Está seguro de que desea eliminar este grupo?"):
        del self.groups[group_id]
        self.refresh_groups()
        self.save_groups()

    def add_item_to_group(self, item_id, group_id):
        if group_id in self.groups:
            item_data = self.clipboard_manager.clipboard_items.get(item_id)
            if item_data and item_id not in [item['id'] for item in self.groups[group_id]['items']]:
                self.groups[group_id]['items'].append({
                    'id': item_id,
                    'text': item_data['text']
                })
                self.save_groups()
                if self.groups_window and self.groups_window.winfo_exists():
                    self.refresh_groups()
                print(f"Item {item_id} added to group {group_id}")
                
                # Actualizar la vista principal si es necesario
                if hasattr(self.clipboard_manager, 'refresh_cards'):
                    self.clipboard_manager.refresh_cards()
            else:
                print(f"Item {item_id} already in group {group_id} or not found")
        else:
            print(f"Group {group_id} not found")
            
    def on_main_window_close(self, event):
        if self.groups_window and self.groups_window.winfo_exists():
            self.groups_window.destroy()
            
    def close_groups_window(self):
        self.groups_window.destroy()
        self.clipboard_manager.show_main_screen()
            
    # ----------------------------------------------------------------------
   
    
    
    def add_group(self):
        dialog = tk.Toplevel(self.master)
        dialog.title("Nuevo Grupo")
        dialog.geometry("200x115")
        
        # Calcula la posición relativa a la ventana principal
        x = self.clipboard_manager.window_x + 40
        y = self.clipboard_manager.window_y + 40
        
        dialog.geometry(f"+{x}+{y}")
        
        dialog.configure(bg=self.theme_manager.colors['dark']['bg'])
        dialog.overrideredirect(True)
        dialog.attributes('-topmost', True)

        # Barra de título personalizada
        title_frame = tk.Frame(dialog, bg=self.theme_manager.colors['dark']['bg'])
        title_frame.pack(fill=tk.X, padx=4, pady=(4, 0))

        title_label = tk.Label(title_frame, text="Nuevo Grupo", font=('Segoe UI', 10, 'bold'),
                            bg=self.theme_manager.colors['dark']['bg'],
                            fg=self.theme_manager.colors['dark']['fg'])
        title_label.pack(side=tk.LEFT, padx=0)

        close_button = tk.Button(title_frame, text="❌", command=dialog.destroy,
                                font=('Segoe UI', 10, 'bold'), bd=0, padx=0,
                                bg=self.theme_manager.colors['dark']['button_bg'],
                                fg=self.theme_manager.colors['dark']['button_fg'])
        close_button.pack(side=tk.RIGHT)

        # Contenido
        content_frame = tk.Frame(dialog, bg=self.theme_manager.colors['dark']['bg'])
        content_frame.pack(fill=tk.BOTH, expand=True, padx=4, pady=0)

        name_label = tk.Label(content_frame, text="Nombre del grupo:",
                            bg=self.theme_manager.colors['dark']['bg'],
                            fg=self.theme_manager.colors['dark']['fg'])
        name_label.pack(anchor='w', pady=(0, 5))

        name_entry = tk.Entry(content_frame, bg=self.theme_manager.colors['dark']['button_bg'],
                            fg=self.theme_manager.colors['dark']['fg'],
                            insertbackground=self.theme_manager.colors['dark']['fg'],
                            relief=tk.FLAT,  # Quita el efecto 3D
                            bd=0,  # Quita el borde
                            highlightthickness=1,  # Añade un borde fino
                            highlightcolor=self.theme_manager.colors['dark'].get('highlight', '#555555'),  # Color del borde cuando tiene foco
                            highlightbackground=self.theme_manager.colors['dark'].get('border', '#333333'))  # Color del borde cuando no tiene foco
        name_entry.pack(fill=tk.X, pady=(0, 0))

        def save_group():
            name = name_entry.get().strip()
            if name:
                group_id = str(uuid.uuid4())
                self.groups[group_id] = {'name': name, 'items': []}
                self.refresh_groups()
                self.save_groups()
                dialog.destroy()

        save_button = tk.Button(content_frame, text="Guardar", command=save_group,
                                bg=self.theme_manager.colors['dark']['button_bg'],
                                fg=self.theme_manager.colors['dark']['button_fg'],
                                activebackground=self.theme_manager.colors['dark'].get('active_bg', '#4E4E4E'),
                                activeforeground=self.theme_manager.colors['dark'].get('active_fg', '#FFFFFF'),
                                relief=tk.FLAT,  # Elimina el estilo 3D
                                bd=0,  # Elimina el borde
                                padx=4, pady=5)
        save_button.pack(fill=tk.X, expand=True, pady=(0, 0))

        # Hacer la ventana arrastrable
        def start_move(event):
            dialog.x = event.x
            dialog.y = event.y

        def on_move(event):
            deltax = event.x - dialog.x
            deltay = event.y - dialog.y
            x = dialog.winfo_x() + deltax
            y = dialog.winfo_y() + deltay
            dialog.geometry(f"+{x}+{y}")

        title_frame.bind('<Button-1>', start_move)
        title_frame.bind('<B1-Motion>', on_move)

        # Centrar el diálogo en la pantalla
        dialog.update_idletasks()
        width = dialog.winfo_width()
        height = dialog.winfo_height()
        x = (dialog.winfo_screenwidth() // 2) - (width // 2)
        y = (dialog.winfo_screenheight() // 2) - (height // 2)
        dialog.geometry('{}x{}+{}+{}'.format(width, height, x, y))

        dialog.focus_set()
        name_entry.focus()
        
    # ----------------------------------------------------------------------------------
    
    def show_edit_group_dialog(self, group_id):
        dialog = tk.Toplevel(self.master)
        dialog.title("Editar Grupo")
        # dialog.geometry("200x115")
        
        # Calcula la posición relativa a la ventana principal
        x = self.clipboard_manager.window_x + 40
        y = self.clipboard_manager.window_y + 40
        
        dialog.geometry(f"200x115+{x}+{y}")
        
        dialog.configure(bg=self.theme_manager.colors['dark']['bg'])
        dialog.overrideredirect(True)
        dialog.attributes('-topmost', True)

        # Barra de título personalizada
        title_frame = tk.Frame(dialog, bg=self.theme_manager.colors['dark']['bg'])
        title_frame.pack(fill=tk.X, padx=4, pady=(4, 0))

        title_label = tk.Label(title_frame, text="Editar Grupo", font=('Segoe UI', 10, 'bold'),
                            bg=self.theme_manager.colors['dark']['bg'],
                            fg=self.theme_manager.colors['dark']['fg'])
        title_label.pack(side=tk.LEFT, padx=0)

        close_button = tk.Button(title_frame, text="❌", command=dialog.destroy,
                                font=('Segoe UI', 10, 'bold'), bd=0, padx=0,
                                bg=self.theme_manager.colors['dark']['button_bg'],
                                fg=self.theme_manager.colors['dark']['button_fg'])
        close_button.pack(side=tk.RIGHT)

        # Contenido
        content_frame = tk.Frame(dialog, bg=self.theme_manager.colors['dark']['bg'])
        content_frame.pack(fill=tk.BOTH, expand=True, padx=4, pady=0)

        name_label = tk.Label(content_frame, text="Nuevo nombre del grupo:",
                            bg=self.theme_manager.colors['dark']['bg'],
                            fg=self.theme_manager.colors['dark']['fg'])
        name_label.pack(anchor='w', pady=(0, 5))

        name_entry = tk.Entry(content_frame, bg=self.theme_manager.colors['dark']['button_bg'],
                            fg=self.theme_manager.colors['dark']['fg'],
                            insertbackground=self.theme_manager.colors['dark']['fg'],
                            relief=tk.FLAT,  # Quita el efecto 3D
                            bd=0,  # Quita el borde
                            highlightthickness=1,  # Añade un borde fino
                            highlightcolor=self.theme_manager.colors['dark'].get('highlight', '#555555'),  # Color del borde cuando tiene foco
                            highlightbackground=self.theme_manager.colors['dark'].get('border', '#333333'))  # Color del borde cuando no tiene foco
        name_entry.insert(0, self.groups[group_id]['name'])
        name_entry.pack(fill=tk.X, pady=(0, 0))

        def save_group():
            new_name = name_entry.get().strip()
            if new_name:
                self.groups[group_id]['name'] = new_name
                self.refresh_groups()
                self.save_groups()
                dialog.destroy()

        save_button = tk.Button(content_frame, text="Guardar", command=save_group,
                                bg=self.theme_manager.colors['dark']['button_bg'],
                                fg=self.theme_manager.colors['dark']['button_fg'],
                                activebackground=self.theme_manager.colors['dark'].get('active_bg', '#4E4E4E'),
                                activeforeground=self.theme_manager.colors['dark'].get('active_fg', '#FFFFFF'),
                                relief=tk.FLAT,  # Elimina el estilo 3D
                                bd=0,  # Elimina el borde
                                padx=4, pady=5)
        save_button.pack(fill=tk.X, expand=True, pady=(0, 0))  # Hace que el botón ocupe todo el ancho disponible

        # Hacer la ventana arrastrable
        def start_move(event):
            dialog.x = event.x
            dialog.y = event.y

        def on_move(event):
            deltax = event.x - dialog.x
            deltay = event.y - dialog.y
            x = dialog.winfo_x() + deltax
            y = dialog.winfo_y() + deltay
            dialog.geometry(f"+{x}+{y}")

        title_frame.bind('<Button-1>', start_move)
        title_frame.bind('<B1-Motion>', on_move)

        # Centrar el diálogo en la pantalla
        dialog.update_idletasks()
        width = dialog.winfo_width()
        height = dialog.winfo_height()
        x = (dialog.winfo_screenwidth() // 2) - (width // 2)
        y = (dialog.winfo_screenheight() // 2) - (height // 2)
        dialog.geometry('{}x{}+{}+{}'.format(width, height, x, y))

        dialog.focus_set()
        name_entry.focus()

// Archivo: key_manager.py
# key_manager.py
import win32com
import win32clipboard
import keyboard
import win32gui
import win32com.client
import pyperclip
import time
import pyautogui
import win32api
import win32con
import ctypes
import re
from bs4 import BeautifulSoup

# Definir CF_HTML ya que no está en win32con
CF_HTML = win32clipboard.RegisterClipboardFormat("HTML Format")

class KeyManager:
    def __init__(self, manager):
        self.manager = manager
        self.hotkey = self.manager.hotkey
        self.current_hotkey = None
        self.update_hotkey(None, self.hotkey)
        self.original_cursor_pos = None

    def update_hotkey(self, old_hotkey, new_hotkey):
        if old_hotkey:
            try:
                keyboard.remove_hotkey(old_hotkey)
            except KeyError:
                print(f"No se pudo eliminar el atajo anterior: {old_hotkey}")

        if not new_hotkey.lower().startswith('alt+'):
            new_hotkey = 'alt+' + new_hotkey
        
        keyboard.add_hotkey(new_hotkey, self.toggle_window)
        self.current_hotkey = new_hotkey
        print(f"Nuevo atajo configurado: {new_hotkey}")

    def toggle_window(self):
        print("Toggling window")
        if not self.manager.is_visible:
            print("Showing window")
            self.original_cursor_pos = win32gui.GetCursorPos()
            self.show_window()
        else:
            print("Hiding window")
            self.hide_window()

    def hide_window(self):
        self.manager.root.withdraw()
        self.manager.is_visible = False
        self.restore_focus()
        if self.original_cursor_pos:
            win32api.SetCursorPos(self.original_cursor_pos)
        self.setup_global_keys()

    def show_window(self):
        print("In show_window function")
        try:
            self.manager.previous_window = win32gui.GetForegroundWindow()
            # Obtener la posición actual del cursor
            mouse_x, mouse_y = pyautogui.position()
            
            # Calcular la posición de la ventana
            window_x = mouse_x - self.manager.window_width // 2
            window_y = mouse_y - self.manager.window_height // 2
            
            # Asegurar que la ventana no se salga de la pantalla
            screen_width, screen_height = pyautogui.size()
            window_x = max(0, min(window_x, screen_width - self.manager.window_width))
            window_y = max(0, min(window_y, screen_height - self.manager.window_height))
            
            self.manager.root.geometry(f"{self.manager.window_width}x{self.manager.window_height}+{window_x}+{window_y}")
            self.manager.window_x = window_x  # Guarda la posición x de la ventana
            self.manager.window_y = window_y  # Guarda la posición y de la ventana
            
            self.manager.root.deiconify()
            self.manager.root.lift()
            self.manager.root.attributes('-topmost', True)
            self.manager.is_visible = True
            self.manager.navigation.initialize_focus()
            self.setup_global_keys()
            
            # Actualizar la región de desplazamiento del canvas
            self.manager.canvas.update_idletasks()
            self.manager.canvas.configure(scrollregion=self.manager.canvas.bbox("all"))
            
            self.manager.root.update_idletasks()
            self.manager.root.after(100, lambda: self.manager.root.attributes('-topmost', False))
            self.manager.root.focus_force()
            
        except Exception as e:
            print(f"Error al mostrar la ventana: {e}")

    def restore_focus(self):
        if self.manager.previous_window:
            try:
                win32gui.SetForegroundWindow(self.manager.previous_window)
            except Exception as e:
                print(f"Error al restaurar el foco: {e}")
                try:
                    self.manager.root.after(100, lambda: win32gui.SetForegroundWindow(self.manager.previous_window))
                except:
                    pass

    def setup_global_keys(self):
        keyboard.unhook_all()
        keyboard.add_hotkey(self.current_hotkey, self.toggle_window)
        
        # Solo configura las teclas globales si la ventana principal está visible
        if self.manager.is_visible:
            keyboard.add_hotkey('up', lambda: self.handle_global_key('Up'))
            keyboard.add_hotkey('down', lambda: self.handle_global_key('Down'))
            keyboard.add_hotkey('left', lambda: self.handle_global_key('Left'))
            keyboard.add_hotkey('right', lambda: self.handle_global_key('Right'))
            keyboard.add_hotkey('enter', lambda: self.handle_global_key('Return'))

    def handle_global_key(self, key):
        if self.manager.is_visible:
            print(f"Handling global key: {key}")
            if key in ['Up', 'Down']:
                self.manager.navigation.navigate_vertical(type('Event', (), {'keysym': key})())
            elif key in ['Left', 'Right']:
                self.manager.navigation.navigate_horizontal(type('Event', (), {'keysym': key})())
            elif key == 'Return':
                self.manager.navigation.activate_selected()
            
            self.manager.root.update_idletasks()
            self.manager.root.after(10, self.manager.root.update)
            self.manager.root.after(20, self.restore_cursor_position)

    def restore_cursor_position(self):
        if self.original_cursor_pos:
            win32api.SetCursorPos(self.original_cursor_pos)

    def paste_content(self, clipboard_data):
        try:
            self.hide_window()
            current_cursor_pos = win32gui.GetCursorPos()
            
            if isinstance(clipboard_data, dict):
                text = clipboard_data.get('text', '')
                format_info = clipboard_data.get('formatted', {})
            else:
                text = str(clipboard_data)
                format_info = {}

            if self.manager.paste_with_format and format_info:
                formatted_content = self.apply_format_to_text(text, format_info)
                win32clipboard.OpenClipboard()
                win32clipboard.EmptyClipboard()
                win32clipboard.SetClipboardData(win32con.CF_UNICODETEXT, formatted_content)
                win32clipboard.CloseClipboard()
            else:
                pyperclip.copy(text)
            
            time.sleep(0.05)
            
            if self.manager.previous_window:
                win32gui.SetForegroundWindow(self.manager.previous_window)
                time.sleep(0.05)
                
                win32api.SetCursorPos(current_cursor_pos)
                
                shell = win32com.client.Dispatch("WScript.Shell")
                shell.SendKeys("^v")
            
            self.original_cursor_pos = None
            
        except Exception as e:
            print(f"Error en el proceso de pegado: {e}")
        finally:
            if self.original_cursor_pos:
                win32api.SetCursorPos(self.original_cursor_pos)
            self.original_cursor_pos = None

    def apply_format_to_text(self, text, format_info):
        if 'rtf' in format_info:
            return self.apply_rtf_format(text, format_info)
        elif 'html' in format_info:
            return self.apply_html_format(text, format_info)
        else:
            return text

    def apply_rtf_format(self, text, format_info):
        rtf = r"{\rtf1\ansi\deff0"
        if format_info.get('font'):
            rtf += r"{\fonttbl{\f0\fnil " + format_info['font'] + r";}}"
        if format_info.get('color'):
            rtf += r"{\colortbl;\red" + str(format_info['color'][0]) + r"\green" + str(format_info['color'][1]) + r"\blue" + str(format_info['color'][2]) + r";}"
        rtf += r"\f0"
        if format_info.get('size'):
            rtf += r"\fs" + str(int(format_info['size'] * 2))
        if format_info.get('bold'):
            rtf += r"\b"
        if format_info.get('italic'):
            rtf += r"\i"
        rtf += " " + text.replace("\n", r"\par ") + r"}"
        return rtf

    def apply_html_format(self, text, format_info):
        html = "<div style='"
        if format_info.get('font'):
            html += f"font-family: {format_info['font']}; "
        if format_info.get('size'):
            html += f"font-size: {format_info['size']}pt; "
        if format_info.get('color'):
            html += f"color: rgb{format_info['color']}; "
        html += "'>"
        if format_info.get('bold'):
            html += "<strong>"
        if format_info.get('italic'):
            html += "<em>"
        html += text
        if format_info.get('italic'):
            html += "</em>"
        if format_info.get('bold'):
            html += "</strong>"
        html += "</div>"
        return html

// Archivo: main_screen_navigation.py
# main_screen_navigation.py

import tkinter as tk

class MainScreenNavigation:
    def __init__(self, manager):
        self.manager = manager
        self.navigation_order = ['top_buttons', 'main_buttons', 'cards']   

    def navigate_vertical(self, event):
        print(f"MainScreenNavigation: Navigating vertically {event.keysym}")
        current_type = self.manager.current_selection['type']
        current_index = self.manager.current_selection['index']
        print(f"Before navigation: type={current_type}, index={current_index}")
        
        if event.keysym == 'Up':
            self.move_up(current_type, current_index)
        elif event.keysym == 'Down':
            self.move_down(current_type, current_index)

        self.update_highlights()
        self.ensure_visible()
        print(f"After navigation: type={self.manager.current_selection['type']}, index={self.manager.current_selection['index']}")
        self.update_highlights()

    def move_up(self, current_type, current_index):
        if current_type in ['cards', 'icons']:
            if current_index > 0:
                self.manager.current_selection['index'] = current_index - 1
            else:
                self.manager.current_selection = {'type': 'main_buttons', 'index': 0}
        elif current_type == 'main_buttons':
            self.manager.current_selection = {'type': 'top_buttons', 'index': 0}
        elif current_type == 'top_buttons':
            # Si ya estamos en los botones superiores, no hacemos nada
            pass
        print(f"After move_up: {self.manager.current_selection}")
        
    def move_down(self, current_type, current_index):
        if current_type == 'top_buttons':
            self.manager.current_selection = {'type': 'main_buttons', 'index': 0}
        elif current_type == 'main_buttons':
            if self.get_cards_count() > 0:
                self.manager.current_selection = {'type': 'cards', 'index': 0}
        elif current_type == 'cards':
            if current_index < self.get_cards_count() - 1:
                self.manager.current_selection['index'] = current_index + 1
        print(f"After move_down: {self.manager.current_selection}")
        
    def navigate_horizontal(self, event):
        print(f"MainScreenNavigation: Navigating horizontally {event.keysym}")  
        current_type = self.manager.current_selection['type']
        current_index = self.manager.current_selection['index']

        if event.keysym == 'Left':
            self.move_left(current_type, current_index)
        elif event.keysym == 'Right':
            self.move_right(current_type, current_index)

        self.update_highlights()

    def move_left(self, current_type, current_index):
        if current_type in ['top_buttons', 'main_buttons']:
            self.manager.current_selection['index'] = (current_index - 1) % self.get_button_count(current_type)
        elif current_type == 'icons':
            if current_index % 3 > 0:
                self.manager.current_selection['index'] = current_index - 1
            else:
                self.manager.current_selection = {'type': 'cards', 'index': current_index // 3}

    def move_right(self, current_type, current_index):
        if current_type in ['top_buttons', 'main_buttons']:
            self.manager.current_selection['index'] = (current_index + 1) % self.get_button_count(current_type)
        elif current_type == 'cards':
            self.manager.current_selection = {'type': 'icons', 'index': current_index * 3}
        elif current_type == 'icons':
            if current_index % 3 < 2:
                self.manager.current_selection['index'] = current_index + 1

    def activate_selected(self, event=None):
        current_type = self.manager.current_selection['type']
        current_index = self.manager.current_selection['index']

        if current_type == 'main_buttons':
            self.activate_main_button(current_index)
        elif current_type == 'top_buttons':
            self.activate_top_button(current_index)
        elif current_type == 'cards':
            self.activate_card(current_index)
        elif current_type == 'icons':
            self.activate_icon(current_index)

    def activate_main_button(self, index):
        if index == 0:  # Botón Grupos
            self.manager.show_groups()
        elif index == 1:  # Botón Pegar (con/sin formato)
            self.manager.functions.toggle_paste_format()
        elif index == 2:  # Botón Borrar Todo
            self.manager.functions.clear_history()

    def activate_top_button(self, index):
        if index == 0:  # Botón Cambiar tema
            self.manager.theme_manager.toggle_theme()
        elif index == 1:  # Botón Configuración
            self.manager.show_settings()
        elif index == 2:  # Botón Cerrar app
            self.manager.functions.exit_app()

    def activate_card(self, index):
        items = list(self.manager.clipboard_items.items())
        if index < len(items):
            item_id, item_data = items[index]
            clipboard_data = item_data['text']
            self.manager.key_manager.paste_content(clipboard_data)

    def activate_icon(self, index):
        items = list(self.manager.clipboard_items.keys())
        card_index = index // 3
        icon_position = index % 3
        
        if card_index < len(items):
            item_id = items[card_index]
            if icon_position == 0:  # Arrow
                self.manager.functions.on_arrow_click(item_id)
            elif icon_position == 1:  # Pin
                self.manager.functions.toggle_pin(item_id)
            elif icon_position == 2:  # Delete
                self.manager.functions.delete_item(item_id)

    def initialize_focus(self):
        if self.get_cards_count() > 0:
            self.manager.current_selection = {'type': 'cards', 'index': 0}
        else:
            self.manager.current_selection = {'type': 'main_buttons', 'index': 0}
        
        self.manager.root.focus_force()
        self.manager.root.update_idletasks()
        self.update_highlights()
    
    def update_highlights(self):
        print("Updating highlights")
        self.clear_all_highlights()
        
        current_type = self.manager.current_selection['type']
        current_index = self.manager.current_selection['index']
        
        highlight_color = '#444444' if self.manager.is_dark_mode else '#cccccc'
        icon_highlight_color = '#666666' if self.manager.is_dark_mode else '#aaaaaa'
        
        if current_type == 'main_buttons':
            buttons = [self.manager.button1, self.manager.button2, self.manager.button3]
            if 0 <= current_index < len(buttons):
                buttons[current_index].configure(bg=highlight_color)
        
        elif current_type == 'top_buttons':
            top_buttons = [self.manager.theme_button, self.manager.clear_button, self.manager.close_button]
            if 0 <= current_index < len(top_buttons):
                top_buttons[current_index].configure(bg=highlight_color)
        
        elif current_type == 'cards':
            cards = self.manager.cards_frame.winfo_children()
            if current_index < len(cards):
                self.highlight_entire_card(cards[current_index], highlight_color)
        
        elif current_type == 'icons':
            card_index = current_index // 3
            icon_position = current_index % 3
            cards = self.manager.cards_frame.winfo_children()
            
            if card_index < len(cards):
                card = cards[card_index]
                icons_frame = self.find_icons_frame(card)
                
                if icons_frame and icon_position < len(icons_frame.winfo_children()):
                    icons = icons_frame.winfo_children()
                    if 0 <= icon_position < len(icons):
                        self.highlight_entire_card(card, highlight_color)
                        icons[icon_position].configure(bg=icon_highlight_color)
                        
        print(f"Highlighted: {current_type}, index: {current_index}")
        self.manager.root.update_idletasks()
        self.manager.root.after(10, self.manager.root.update)

    def highlight_entire_card(self, card, color):
        card.configure(bg=color)
        for child in card.winfo_children():
            if isinstance(child, tk.Frame):
                child.configure(bg=color)
                for subchild in child.winfo_children():
                    if isinstance(subchild, (tk.Label, tk.Button)):
                        subchild.configure(bg=color)
            elif isinstance(child, (tk.Label, tk.Button)):
                child.configure(bg=color)

    def clear_all_highlights(self):
        theme = self.manager.theme_manager.colors['dark' if self.manager.is_dark_mode else 'light']
        base_color = theme['card_bg']
        button_color = theme['button_bg']
        
        buttons = [self.manager.button1, self.manager.button2, self.manager.button3,
                self.manager.theme_button, self.manager.clear_button, self.manager.close_button]
        for button in buttons:
            button.configure(bg=button_color)
        
        for card in self.manager.cards_frame.winfo_children():
            self.reset_card_colors(card, base_color, button_color)

    def reset_card_colors(self, card, base_color, button_color):
        card.configure(bg=base_color)
        for child in card.winfo_children():
            if isinstance(child, tk.Frame):
                child.configure(bg=base_color)
                for subchild in child.winfo_children():
                    if isinstance(subchild, tk.Label):
                        subchild.configure(bg=base_color)
                    elif isinstance(subchild, tk.Button):
                        subchild.configure(bg=button_color)
            elif isinstance(child, tk.Label):
                child.configure(bg=base_color)
            elif isinstance(child, tk.Button):
                child.configure(bg=button_color)

    def ensure_visible(self):
        current_type = self.manager.current_selection['type']
        current_index = self.manager.current_selection['index']
        
        if current_type == 'cards':
            cards = self.manager.cards_frame.winfo_children()
            if current_index < len(cards):
                widget = cards[current_index]
                bbox = self.manager.canvas.bbox("all")
                if bbox:
                    widget_y = widget.winfo_y()
                    canvas_height = self.manager.canvas.winfo_height()
                    if widget_y > 0:
                        self.manager.canvas.yview_moveto(widget_y / bbox[3])

    def get_cards_count(self):
        return len(self.manager.cards_frame.winfo_children())

    def get_button_count(self, button_type):
        if button_type == 'top_buttons':
            return 3  # Asumiendo que siempre hay 3 botones superiores
        elif button_type == 'main_buttons':
            return 3  # Asumiendo que siempre hay 3 botones principales

    def find_icons_frame(self, card):
        for child in card.winfo_children():
            if isinstance(child, tk.Frame) and child.winfo_children() and isinstance(child.winfo_children()[0], tk.Button):
                return child
        return None



// Archivo: navigation.py
# # navigation.py

# from main_screen_navigation import MainScreenNavigation
# from groups_screen_navigation import GroupsScreenNavigation
# # from settings_screen_navigation import SettingsScreenNavigation

# import logging

# logger = logging.getLogger(__name__)

# class Navigation:
#     def __init__(self, manager):
#         self.manager = manager
#         self.strategies = {
#             'main': MainScreenNavigation(manager),
#             'groups': GroupsScreenNavigation(manager),
#             # 'settings': SettingsScreenNavigation(manager)
#         }
#         self.current_strategy = self.strategies['main']
#         logger.debug("Navigation inicializado")

#     def set_strategy(self, screen_type):
#         if screen_type in self.strategies:
#             self.current_strategy = self.strategies[screen_type]
#             logger.debug(f"Estrategia de navegación cambiada a: {screen_type}")
#         else:
#             logger.error(f"Estrategia de navegación no reconocida: {screen_type}")
            
#     def navigate_vertical(self, event):
#         logger.debug(f"Navegación vertical: {event.keysym}")
#         self.current_strategy.navigate_vertical(event)

#     def navigate_horizontal(self, event):
#         logger.debug(f"Navegación horizontal: {event.keysym}")
#         self.current_strategy.navigate_horizontal(event)

#     def activate_selected(self, event=None):
#         logger.debug("Activando selección")
#         self.current_strategy.activate_selected(event)

#     def update_highlights(self):
#         logger.debug("Actualizando highlights")
#         self.current_strategy.update_highlights()


#     def get_cards_count(self):
#         return len(self.manager.cards_frame.winfo_children()) if hasattr(self.manager, 'cards_frame') else 0

#     def initialize_focus(self):
#         if self.get_cards_count() > 0:
#             self.manager.current_selection = {'type': 'cards', 'index': 0}
#         else:
#             self.manager.current_selection = {'type': 'main_buttons', 'index': 0}
        
#         self.update_highlights()
#         self.manager.root.update_idletasks()

#     def handle_focus(self, event=None):
#         if self.manager.is_visible:
#             self.manager.root.focus_force()

#     def check_window_state(self):
#         try:
#             actual_visible = self.manager.root.winfo_viewable()
#             if actual_visible != self.manager.is_visible:
#                 print('**********'f"Corrigiendo estado de visibilidad: {self.manager.is_visible} -> {actual_visible}")
#                 self.manager.is_visible = actual_visible
#         except Exception as e:
#             print(f"Error al verificar estado de la ventana: {e}")

#     def update_active_window(self):
#         import win32gui
#         self.manager.last_active_window = win32gui.GetForegroundWindow()

#     def get_current_selection(self):
#         return self.manager.current_selection

#     def set_current_selection(self, selection_type, index):
#         self.manager.current_selection = {'type': selection_type, 'index': index}
#         self.update_highlights()

#     def get_clipboard_items(self):
#         return self.manager.clipboard_items

#     def get_cards_frame(self):
#         return self.manager.cards_frame

#     def get_canvas(self):
#         return self.manager.canvas

#     def is_dark_mode(self):
#         return self.manager.is_dark_mode

#     def get_theme_colors(self):
#         return self.manager.theme_manager.colors


import logging
from main_screen_navigation import MainScreenNavigation
from groups_screen_navigation import GroupsScreenNavigation

logger = logging.getLogger(__name__)

class Navigation:
    def __init__(self, manager):
        self.manager = manager
        self.strategies = {
            'main': MainScreenNavigation(manager),
            'groups': GroupsScreenNavigation(manager),
        }
        self.current_strategy = self.strategies['main']
        logger.debug("Navigation inicializado")

    def set_strategy(self, screen_type):
        if screen_type in self.strategies:
            self.current_strategy = self.strategies[screen_type]
            logger.debug(f"Estrategia de navegación cambiada a: {screen_type}")
        else:
            logger.error(f"Estrategia de navegación no reconocida: {screen_type}")

    def navigate_vertical(self, event):
        logger.debug(f"Navegación vertical: {event.keysym}")
        self.current_strategy.navigate_vertical(event)

    def navigate_horizontal(self, event):
        logger.debug(f"Navegación horizontal: {event.keysym}")
        self.current_strategy.navigate_horizontal(event)

    def activate_selected(self, event=None):
        logger.debug("Activando selección")
        self.current_strategy.activate_selected(event)

    def update_highlights(self):
        logger.debug("Actualizando highlights")
        self.current_strategy.update_highlights()

    def initialize_focus(self):
        logger.debug("Inicializando foco")
        self.current_strategy.initialize_focus()

    def get_cards_count(self):
        return self.current_strategy.get_cards_count()

    def handle_focus(self, event=None):
        if self.manager.is_visible:
            self.manager.root.focus_force()
        logger.debug("Manejando foco de la ventana")

    def check_window_state(self):
        try:
            actual_visible = self.manager.root.winfo_viewable()
            if actual_visible != self.manager.is_visible:
                logger.info(f"Corrigiendo estado de visibilidad: {self.manager.is_visible} -> {actual_visible}")
                self.manager.is_visible = actual_visible
        except Exception as e:
            logger.error(f"Error al verificar estado de la ventana: {e}")

    def update_active_window(self):
        import win32gui
        self.manager.last_active_window = win32gui.GetForegroundWindow()
        logger.debug(f"Ventana activa actualizada: {self.manager.last_active_window}")

    def get_current_selection(self):
        return self.manager.current_selection

    def set_current_selection(self, selection_type, index):
        self.manager.current_selection = {'type': selection_type, 'index': index}
        self.update_highlights()
        logger.debug(f"Selección actual establecida: {self.manager.current_selection}")

    def get_clipboard_items(self):
        return self.manager.clipboard_items

    def get_cards_frame(self):
        return self.manager.cards_frame

    def get_canvas(self):
        return self.manager.canvas

    def is_dark_mode(self):
        return self.manager.is_dark_mode

    def get_theme_colors(self):
        return self.manager.theme_manager.colors

    def ensure_visible(self):
        self.current_strategy.ensure_visible()
        logger.debug("Asegurando visibilidad del elemento seleccionado")

    def handle_global_key(self, key):
        logger.debug(f"Manejando tecla global: {key}")
        if self.manager.is_visible:
            if key in ['Up', 'Down']:
                self.navigate_vertical(type('Event', (), {'keysym': key})())
            elif key in ['Left', 'Right']:
                self.navigate_horizontal(type('Event', (), {'keysym': key})())
            elif key == 'Return':
                self.activate_selected()
            
            self.manager.root.update_idletasks()
            self.manager.root.after(10, self.manager.root.update)
            self.manager.root.after(20, self.manager.key_manager.restore_cursor_position)

    def refresh_navigation(self):
        logger.debug("Refrescando navegación")
        self.initialize_focus()
        self.update_highlights()
        if hasattr(self.current_strategy, 'refresh_view'):
            self.current_strategy.refresh_view()

    def on_window_focus(self, event):
        logger.debug("Ventana obtuvo el foco")
        self.refresh_navigation()

    def on_window_unfocus(self, event):
        logger.debug("Ventana perdió el foco")
        # Aquí puedes agregar lógica adicional si es necesario cuando la ventana pierde el foco

// Archivo: navigation_strategies.py
# navigation_strategies.py

from abc import ABC, abstractmethod

class NavigationStrategy(ABC):
    @abstractmethod
    def navigate_vertical(self, event):
        pass

    @abstractmethod
    def navigate_horizontal(self, event):
        pass

    @abstractmethod
    def activate_selected(self, event=None):
        pass

    @abstractmethod
    def update_highlights(self):
        pass

    @abstractmethod
    def initialize_focus(self):
        pass

# Nota: Las implementaciones concretas de MainScreenNavigation, GroupsScreenNavigation,
# y SettingsScreenNavigation ahora están en archivos separados.

// Archivo: structure.py
# structure.py

import tkinter as tk
from tkinter import ttk
import threading
import win32gui
import pyautogui

from functions import Functions
from key_manager import KeyManager
from navigation import Navigation
from theme_manager import ThemeManager
from group_manager import GroupManager
from data_manager import DataManager
from settings_manager import SettingsManager

import logging

logger = logging.getLogger(__name__)

class ClipboardManager:
    def __init__(self, root, show_settings=False):
        self.root = root
        self.root.title("Portapapeles")

        self.data_manager = DataManager()
        groups, pinned_items, settings = self.data_manager.load_data()
        
        self.settings = settings
        self.settings_manager = SettingsManager(self.root, self)
        self.settings_manager.initialize_settings()

        self.window_width = settings['width']
        self.window_height = settings['height']
        self.window_x = 0
        self.window_y = 0

        self.root.overrideredirect(True)
        self.root.attributes('-topmost', True)
        self.root.protocol("WM_DELETE_WINDOW", self.on_close)  # Manejar el cierre de la ventana

        
        self.root.withdraw()
        self.is_visible = False

        self.previous_window = None

        self.clipboard_items = {}
        for item_id, item_data in pinned_items.items():
            if isinstance(item_data['text'], dict):
                self.clipboard_items[item_id] = item_data
            else:
                # Si el texto no es un diccionario, lo convertimos a la estructura esperada
                self.clipboard_items[item_id] = {
                    'text': {'text': item_data['text'], 'formatted': {}},
                    'pinned': item_data['pinned']
                }
                
        self.current_clipboard = ""
        self.selected_index = None
        self.current_selection = {'type': 'button', 'index': 0}
        self.is_dark_mode = True
        
        self.paste_with_format = False
        
        self.previous_window = None
        self.last_active_window = None
        self.selected_button = None
        self.selected_card = None
        self.selected_icon = None
        self.total_buttons = 6
        self.top_buttons = 3
        self.icons_per_card = 3
        
        self.hotkey = f"alt+{settings['hotkey']}"

        self.theme_manager = ThemeManager(self)
        self.functions = Functions(self)
        self.key_manager = KeyManager(self)
        self.group_manager = GroupManager(self.root, self)
        
        self.group_manager.groups = groups
        
        self.create_gui()
        self.load_saved_data()
        
        self.navigation = Navigation(self)
        
        self.theme_manager.apply_theme()

        self.monitor_thread = threading.Thread(target=self.functions.monitor_clipboard, daemon=True)
        self.monitor_thread.start()

        self.key_manager.update_hotkey(None, self.settings_manager.settings['hotkey'])
                
        if show_settings:
            self.root.after(100, self.settings_manager.show_settings_window)
        
        self.root.after(1000, self.navigation.check_window_state)
        self.key_manager.setup_global_keys()
        
        # scroll
        self.canvas.configure(yscrollcommand=self.scrollbar.set)
        self.canvas.bind('<Configure>', self.on_canvas_configure)
        self.cards_frame.bind('<Configure>', lambda e: self.canvas.configure(scrollregion=self.canvas.bbox("all")))
        
    def force_update(self):
        self.root.update_idletasks()
        self.root.update()
            
    def on_close(self):
        self.root.withdraw()
        self.is_visible = False

    def create_gui(self):
        self.main_frame = ttk.Frame(self.root, style='Main.TFrame')
        self.main_frame.pack(fill=tk.BOTH, expand=True)

        self.title_frame = tk.Frame(self.main_frame, bg=self.theme_manager.colors['dark']['bg'])
        self.title_frame.pack(fill=tk.X, padx=3, pady=(0,6))

        self.title_label = tk.Label(self.title_frame, text="Portapapeles", font=('Segoe UI', 10, 'bold'), bg=self.theme_manager.colors['dark']['bg'], fg=self.theme_manager.colors['dark']['fg'])
        self.title_label.pack(side=tk.LEFT, padx=5)

        buttons_frame = tk.Frame(self.title_frame, bg=self.theme_manager.colors['dark']['bg'])
        buttons_frame.pack(side=tk.RIGHT, padx=4)

        self.theme_button = tk.Button(buttons_frame, text="🌙", command=self.theme_manager.toggle_theme, font=('Segoe UI', 10), bd=0, padx=10, width=5, height=2)
        self.theme_button.pack(side=tk.LEFT)

        self.clear_button = tk.Button(buttons_frame, text="    🖥️", command=self.show_settings, font=('Segoe UI', 10), bd=0, padx=10, width=5, height=2)
        self.clear_button.pack(side=tk.LEFT)

        self.close_button = tk.Button(buttons_frame, text="❌", command=self.functions.exit_app, font=('Segoe UI', 10, 'bold'), bd=0, padx=10, width=5, height=2)
        self.close_button.pack(side=tk.LEFT)

        main_buttons_frame = tk.Frame(self.main_frame, bg=self.theme_manager.colors['dark']['bg'])
        main_buttons_frame.pack(fill=tk.X, padx=6, pady=0)

        self.button1 = tk.Button(main_buttons_frame, text="Grupos", 
                                 command=self.show_groups, font=('Segoe UI', 10), 
                                 bg=self.theme_manager.colors['dark']['button_bg'], 
                                 fg=self.theme_manager.colors['dark']['button_fg'],
                                 relief=tk.FLAT,
                                 bd=0,
                                 highlightthickness=1,
                                 pady=8)
        self.button1.pack(side=tk.LEFT, fill=tk.X, expand=True, padx=1, pady=0)

        self.button2 = tk.Button(main_buttons_frame, text="Sin formato", 
                                 command=self.functions.toggle_paste_format, font=('Segoe UI', 10), 
                                 bg=self.theme_manager.colors['dark']['button_bg'], 
                                 fg=self.theme_manager.colors['dark']['button_fg'],
                                 relief=tk.FLAT,
                                 bd=0,
                                 highlightthickness=1,
                                 pady=8) 
        self.button2.pack(side=tk.LEFT, fill=tk.X, expand=True, padx=1, pady=0)

        self.button3 = tk.Button(main_buttons_frame, text="Borrar Todo", 
                                 command=self.functions.clear_history, font=('Segoe UI', 10), 
                                 bg=self.theme_manager.colors['dark']['button_bg'], 
                                 fg=self.theme_manager.colors['dark']['button_fg'],
                                 relief=tk.FLAT,
                                 bd=0,
                                 highlightthickness=1,
                                 pady=8)                               
        self.button3.pack(side=tk.LEFT, fill=tk.X, expand=True, padx=1, pady=0)

        self.canvas = tk.Canvas(self.main_frame, bd=0, highlightthickness=0)
        self.canvas.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)
        
        self.cards_frame = tk.Frame(self.canvas, bg=self.theme_manager.colors['dark']['bg'])
        self.canvas_window = self.canvas.create_window((0, 0), window=self.cards_frame, anchor='nw')

        self.scrollbar = ttk.Scrollbar(self.main_frame, orient=tk.VERTICAL, command=self.canvas.yview)
        self.canvas.configure(yscrollcommand=self.scrollbar.set)

        # Variables para el movimiento de la ventana
        self._drag_data = {"x": 0, "y": 0, "item": None}

        # Vincular eventos para mover la ventana
        self.title_label.bind('<Button-1>', self.start_move)
        self.title_label.bind('<ButtonRelease-1>', self.stop_move)
        self.title_label.bind('<B1-Motion>', self.on_move)
        
        # Vincula eventos de scroll
        self.canvas.bind('<Configure>', self.on_canvas_configure)
        self.cards_frame.bind('<Configure>', self.on_frame_configure)
        self.canvas.bind_all("<MouseWheel>", self.on_mousewheel)

    def scrollbar_set(self, start, end):
        # Este método se llama cuando el canvas actualiza su región de scroll
        self.canvas.yview_moveto(float(start))

    def show_groups(self):
        logger.debug("Mostrando ventana de grupos")
        self.group_manager.show_groups_window()
        self.navigation.set_strategy('groups')
        self.root.withdraw()
        
        # Desvincula los eventos de teclado de la ventana principal
        self.root.unbind('<Up>')
        self.root.unbind('<Down>')
        self.root.unbind('<Left>')
        self.root.unbind('<Right>')
        self.root.unbind('<Return>')

    def show_settings(self):
        self.settings_manager.show_settings_window()
        self.navigation.set_strategy('settings')
        self.root.withdraw()
        
    def refresh_main_screen(self):
        # Actualizar la región de desplazamiento
        self.canvas.update_idletasks()
        self.canvas.configure(scrollregion=self.canvas.bbox("all"))
        
        # Volver a vincular eventos de scroll
        self.canvas.bind('<Configure>', self.on_canvas_configure)
        self.cards_frame.bind('<Configure>', self.on_frame_configure)
        self.canvas.bind_all("<MouseWheel>", self.on_mousewheel)
        
        # Asegurarse de que el canvas tenga el foco
        self.canvas.focus_set()
        
        # Refrescar las tarjetas
        self.functions.refresh_cards()

    def show_main_screen(self):
        # Lógica para mostrar la pantalla principal
        self.navigation.set_strategy('main')
        self.root.deiconify()
        self.root.lift()
        self.root.focus_force()
        self.refresh_main_screen()

    def load_saved_data(self):
        groups, pinned_items, _ = self.data_manager.load_data()
        self.group_manager.groups = groups
        self.clipboard_items.update(pinned_items)
        self.functions.refresh_cards()

    def on_main_window_map(self, event):
        if self.group_manager.groups_window and self.group_manager.groups_window.winfo_exists():
            self.group_manager.groups_window.deiconify()

    def on_main_window_unmap(self, event):
        if self.group_manager.groups_window and self.group_manager.groups_window.winfo_exists():
            self.group_manager.groups_window.withdraw()

    def start_move(self, event):
        self._drag_data["x"] = event.x
        self._drag_data["y"] = event.y

    def stop_move(self, event):
        self._drag_data["x"] = 0
        self._drag_data["y"] = 0
        self._drag_data["item"] = None

    def on_move(self, event):
        delta_x = event.x - self._drag_data["x"]
        delta_y = event.y - self._drag_data["y"]
        x = self.root.winfo_x() + delta_x
        y = self.root.winfo_y() + delta_y
        self.root.geometry(f"+{x}+{y}")
        self.window_x = x
        self.window_y = y

    def on_canvas_configure(self, event):
        self.canvas.configure(scrollregion=self.canvas.bbox("all"))
        width = event.width
        self.canvas.itemconfig(self.canvas_window, width=width)

    def on_frame_configure(self, event):
        self.canvas.configure(scrollregion=self.canvas.bbox("all"))

    def on_mousewheel(self, event):
        # Asegurarse de que el canvas tenga el foco
        self.canvas.focus_set()
        # Scroll
        self.canvas.yview_scroll(int(-1 * (event.delta / 120)), "units")
        
    def on_scroll(self, *args):
        # Este método se llama cuando se realiza un scroll
        if len(args) == 3 and isinstance(args[2], str):
            self.canvas.yview_moveto(args[0])
        elif len(args) == 2 and isinstance(args[0], str):
            self.canvas.yview_scroll(int(args[1]), args[0])

// Archivo: theme_manager.py
#theme_manager.py

import tkinter as tk
from tkinter import ttk

class ThemeManager:
    def __init__(self, manager):
        self.manager = manager
        self.colors = {
            'dark': {
                'bg': '#1e1e1e',
                'fg': '#ffffff',
                'button_bg': '#333333',
                'button_fg': '#ffffff',
                'listbox_bg': '#2d2d2d',
                'listbox_fg': '#ffffff',
                'active_bg': '#4E4E4E',  # Añadido
                'active_fg': '#FFFFFF',  # Añadido
                'card_bg': '#333333'
            },
            'light': {
                'bg': '#f0f0f0',
                'fg': '#000000',
                'button_bg': '#e0e0e0',
                'button_fg': '#000000',
                'listbox_bg': '#ffffff',
                'listbox_fg': '#000000',
                'active_bg': '#D0D0D0',  # Añadido
                'active_fg': '#000000',  # Añadido
                'card_bg': '#ffffff'
            }
        }

    def toggle_theme(self):
        self.manager.is_dark_mode = not self.manager.is_dark_mode
        self.manager.theme_button.config(text="🌙" if self.manager.is_dark_mode else "☀️")
        self.apply_theme()

    def apply_theme(self):
        theme = self.colors['dark'] if self.manager.is_dark_mode else self.colors['light']
        
        self.manager.root.configure(bg=theme['bg'])
        self.manager.main_frame.configure(style='Main.TFrame')
        self.manager.title_frame.configure(bg=theme['bg'])
        self.manager.title_label.configure(bg=theme['bg'], fg=theme['fg'])
        
        self.manager.clear_button.configure(
            bg=theme['button_bg'],
            fg=theme['button_fg'],
            activebackground=theme['button_bg'],
            activeforeground=theme['button_fg']
        )
        self.manager.theme_button.configure(
            bg=theme['button_bg'],
            fg=theme['button_fg'],
            activebackground=theme['button_bg'],
            activeforeground=theme['button_fg']
        )
        
        self.manager.close_button.configure(
            bg=theme['button_bg'],
            fg=theme['button_fg'],
            activebackground=theme['button_bg'],
            activeforeground=theme['button_fg']
        )

        self.manager.button1.configure(
            bg=theme['button_bg'],
            fg=theme['button_fg'],
            activebackground=theme['button_bg'],
            activeforeground=theme['button_fg']
        )

        self.manager.button2.configure(
            bg=theme['button_bg'],
            fg=theme['button_fg'],
            activebackground=theme['button_bg'],
            activeforeground=theme['button_fg']
        )

        self.manager.button3.configure(
            bg=theme['button_bg'],
            fg=theme['button_fg'],
            activebackground=theme['button_bg'],
            activeforeground=theme['button_fg']
        )

        self.manager.canvas.configure(bg=theme['bg'])
        self.manager.cards_frame.configure(bg=theme['bg'])
        
        self.manager.functions.refresh_cards()

        style = ttk.Style()  
        style.theme_use('clam')  
        style.configure('Main.TFrame', background=theme['bg'])

// Archivo: utils.py
# utils.py

import time

def measure_time(func):
    def wrapper(*args, **kwargs):
        start_time = time.time()
        result = func(*args, **kwargs)
        end_time = time.time()
        print(f"{func.__name__} tomó {(end_time - start_time) * 1000:.2f} ms")
        return result
    return wrapper

def process_text(text_data, cant_lineas):
    """
    Procesa el texto para mostrarlo de forma limpia y ordenada
    """
    # Comprueba si text_data es un diccionario y extrae el texto
    if isinstance(text_data, dict):
        text = text_data.get('text', '')
    else:
        text = str(text_data)

    # Eliminamos espacios extras y tabulaciones al inicio y final
    text = text.strip()
    
    # Dividimos el texto en líneas
    lines = text.splitlines()
    
    # Eliminamos líneas vacías consecutivas y espacios extras
    clean_lines = []
    prev_empty = False
    for line in lines:
        line = line.strip()
        
        # Si la línea está vacía
        if not line:
            if not prev_empty:  # Solo mantenemos una línea vacía
                clean_lines.append('')
                prev_empty = True
        else:
            clean_lines.append(line)
            prev_empty = False
    
    # Tomamos solo las primeras 'cant_lineas' para la vista previa
    preview_lines = clean_lines[:cant_lineas]
    
    # Si hay más líneas, indicamos cuántas más hay
    if len(clean_lines) > cant_lineas:
        remaining_lines = len(clean_lines) - cant_lineas
        preview_lines.append(f"+ {remaining_lines} líneas más")
        
    # Unimos las líneas con saltos de línea
    return '\n'.join(preview_lines)
