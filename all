# data_manager.py

import json
import os

class DataManager:
    def __init__(self, file_path='clipboard_data.json'):
        self.file_path = file_path

    def save_data(self, groups, pinned_items, settings):
        data = {
            'groups': groups,
            'pinned_items': pinned_items,
            'settings': settings
        }
        with open(self.file_path, 'w') as f:
            json.dump(data, f, indent=4)
        print(f"All data saved to {self.file_path}")

    def load_data(self):
        if not os.path.exists(self.file_path):
            return {}, {}, {
                'height': 400,
                'width': 295,
                'hotkey': 'v'
            }
        
        with open(self.file_path, 'r') as f:
            data = json.load(f)
        
        groups = data.get('groups', {})
        for group in groups.values():
            if 'items' in group:
                group['items'] = [item if isinstance(item, dict) else {'id': item, 'text': 'Unknown'} for item in group['items']]
        
        settings = data.get('settings', {
            'height': 400,
            'width': 295,
            'hotkey': 'v'
        })
        
        return groups, data.get('pinned_items', {}), settings



# functions.py

import tkinter as tk
import uuid
import win32con # type: ignore
import win32clipboard # type: ignore
import win32gui # type: ignore
import time
import sys
from utils import measure_time, process_text

# Definir CF_HTML ya que no est√° en win32con
CF_HTML = win32clipboard.RegisterClipboardFormat("HTML Format")

class Functions:
    def __init__(self, manager):
        self.manager = manager
        self.min_card_height = 40  # Altura m√≠nima en p√≠xeles (2 l√≠neas + 2*2 padding)
        self.max_card_height = 76  # Altura m√°xima en p√≠xeles (4 l√≠neas + 2*2 padding)
        self.line_height = 18  # Altura estimada de una l√≠nea de texto


    @measure_time
    def create_card(self, item_id, item_data, index):
        card_width = self.manager.window_width - 4  # Ajuste para el padding
        card_height = max(self.min_card_height, self.calculate_card_height(item_data['text']))
        
        # Procesamos el texto para mostrarlo de forma limpia
        if isinstance(item_data['text'], dict):
            processed_text = process_text(item_data['text'].get('text', ''), 3)
        else:
            processed_text = process_text(str(item_data['text']), 3)
        
        # Obt√©n el color de fondo actual
        current_theme = 'dark' if self.manager.is_dark_mode else 'light'
        bg_color = self.manager.theme_manager.colors[current_theme]['card_bg']

        card_container = tk.Frame(self.manager.cards_frame, width=card_width, height=card_height, bg=bg_color)
        card_container.pack(fill=tk.BOTH, padx=2, pady=2)
        card_container.pack_propagate(False)  # Evita que el contenido afecte el tama√±o del contenedor

        text_frame = tk.Frame(card_container, bg=bg_color)
        text_frame.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)

        # Procesamos el texto para mostrarlo de forma limpia
        processed_text = process_text(item_data['text'], 3)

        text_label = tk.Label(text_frame, text=processed_text,
                            justify=tk.LEFT, anchor='w', padx=10, pady=5,
                            bg=card_container['bg'],
                            fg=self.manager.theme_manager.colors['dark' if self.manager.is_dark_mode else 'light']['fg'], width=int(24))
        text_label.pack(fill=tk.X, expand=True, side=tk.LEFT)

        icons_frame = tk.Frame(card_container, bg=card_container['bg'])
        icons_frame.pack(side=tk.RIGHT, padx=3)

        arrow_button = tk.Button(icons_frame, text="‚û°Ô∏è",
                                command=lambda: self.on_arrow_click(item_id),
                                font=('Segoe UI', 10), bd=0,
                                padx=2,
                                bg=card_container['bg'],
                                fg=self.manager.theme_manager.colors['dark' if self.manager.is_dark_mode else 'light']['fg'])
        arrow_button.pack(side=tk.LEFT)
        
        pin_text = "üìå" if item_data['pinned'] else "üìç"
        pin_button = tk.Button(icons_frame, text=pin_text,
                            command=lambda: self.toggle_pin(item_id),
                            font=('Segoe UI', 10), bd=0,
                            padx=2,
                            bg=card_container['bg'],
                            fg=self.manager.theme_manager.colors['dark' if self.manager.is_dark_mode else 'light']['fg'])
        pin_button.pack(side=tk.LEFT)

        delete_button = tk.Button(icons_frame, text="‚úñÔ∏è",
                                command=lambda: self.delete_item(item_id),
                                font=('Segoe UI', 10), bd=0,
                                padx=2,
                                bg=card_container['bg'],
                                fg=self.manager.theme_manager.colors['dark' if self.manager.is_dark_mode else 'light']['fg'])
        delete_button.pack(side=tk.LEFT)
        
        return card_container
    
    def calculate_card_height(self, text_data):
        if isinstance(text_data, dict):
            text = text_data.get('text', '')
        else:
            text = str(text_data)
        lines = len(text.split('\n'))
        content_height = min(lines * self.line_height, 4 * self.line_height)  # M√°ximo 4 l√≠neas
        return min(max(content_height + 4, self.min_card_height), self.max_card_height)
    
    @measure_time
    def refresh_cards(self):
        if not hasattr(self.manager, 'cards_frame') or not self.manager.cards_frame.winfo_exists():
            print("cards_frame no existe o ha sido destruido")
            return
        # Eliminar tarjetas obsoletas
        existing_cards = {child.item_id: child for child in self.manager.cards_frame.winfo_children() if hasattr(child, 'item_id')}
        
        for item_id in list(existing_cards.keys()):
            if item_id not in self.manager.clipboard_items:
                existing_cards[item_id].destroy()
                del existing_cards[item_id]

        # Actualizar o crear nuevas tarjetas
        for index, (item_id, item_data) in enumerate(self.manager.clipboard_items.items()):
            if item_id in existing_cards:
                card = existing_cards[item_id]
                self.update_card(card, item_data)
            else:
                card = self.create_card(item_id, item_data, index)
                card.item_id = item_id

            card.pack(fill=tk.X, padx=2, pady=2)

        # Actualizar la regi√≥n de desplazamiento
        self.manager.canvas.update_idletasks()
        self.manager.canvas.configure(scrollregion=self.manager.canvas.bbox("all"))
        self.recalculate_card_heights()
        # Asegurarse de que el scroll est√© en la parte superior despu√©s de actualizar
        self.manager.canvas.yview_moveto(0)
        

    def update_card(self, card, item_data):
        processed_text = process_text(item_data['text'], 3)
        text_label = card.winfo_children()[0].winfo_children()[0]
        text_label.config(text=processed_text)

        new_height = self.calculate_card_height(processed_text)
        card.config(height=new_height)

        # Actualizar el estado del bot√≥n de pin
        pin_button = card.winfo_children()[1].winfo_children()[1]
        pin_text = "üìå" if item_data['pinned'] else "üìç"
        pin_button.config(text=pin_text)
        
    def apply_theme_to_card(self, card, theme):
        card.configure(bg=theme['card_bg'])
        
        for child in card.winfo_children():
            if isinstance(child, tk.Frame):
                child.configure(bg=theme['card_bg'])
                for subchild in child.winfo_children():
                    if isinstance(subchild, (tk.Label, tk.Button)):
                        subchild.configure(bg=theme['card_bg'], fg=theme['fg'])
            elif isinstance(child, (tk.Label, tk.Button)):
                child.configure(bg=theme['card_bg'], fg=theme['fg'])

    def toggle_pin(self, item_id):
        if item_id in self.manager.clipboard_items:
            self.manager.clipboard_items[item_id]['pinned'] = not self.manager.clipboard_items[item_id]['pinned']
            self.refresh_cards()
            self.manager.group_manager.save_groups()  # Guardar despu√©s de cambiar el estado de anclaje

    def delete_item(self, item_id):
        if item_id in self.manager.clipboard_items and not self.manager.clipboard_items[item_id]['pinned']:
            del self.manager.clipboard_items[item_id]
            self.refresh_cards()
            self.manager.group_manager.save_groups()  # Guardar despu√©s de eliminar un item

    
    def clear_history(self):
        self.manager.clipboard_items = {k: v for k, v in self.manager.clipboard_items.items() if v['pinned']}
        self.refresh_cards()
        self.manager.group_manager.save_groups()  # Guardar despu√©s de limpiar el historial
        if self.manager.current_selection['type'] == 'card':
            self.manager.current_selection = {'type': 'button', 'index': 0}
        self.manager.navigation.update_highlights()

    def on_canvas_configure(self, event):
        self.manager.canvas.configure(scrollregion=self.manager.canvas.bbox("all"))

    def on_mousewheel(self, event):
        self.manager.canvas.yview_scroll(int(-1 * (event.delta / 120)), "units")

    @measure_time
    def monitor_clipboard(self):
        while True:
            try:
                clipboard_content = self.get_clipboard_text()
                if clipboard_content and clipboard_content != self.manager.current_clipboard:
                    self.manager.current_clipboard = clipboard_content
                    if clipboard_content['text'] not in [item['text'].get('text', '') if isinstance(item['text'], dict) else item['text'] for item in self.manager.clipboard_items.values()]:
                        new_id = str(uuid.uuid4())
                        new_item = {
                            'text': clipboard_content,
                            'pinned': False,
                            'with_format': self.manager.paste_with_format
                        }
                        # Usar after para actualizar la GUI en el hilo principal
                        self.manager.root.after(0, self.add_clipboard_item, new_id, new_item)
            except Exception as e:
                print(f"Error en monitor_clipboard: {e}")
            time.sleep(0.5)
            
    def add_clipboard_item(self, new_id, new_item):
        self.manager.clipboard_items[new_id] = new_item
        if len(self.manager.clipboard_items) > 20:
            unpinned_items = [k for k, v in self.manager.clipboard_items.items() if not v['pinned']]
            if unpinned_items:
                del self.manager.clipboard_items[unpinned_items[-1]]
        self.refresh_cards()
        self.manager.group_manager.save_groups()

    # @measure_time
    def get_clipboard_text(self):
        try:
            win32clipboard.OpenClipboard()
            formats = []
            format_id = win32clipboard.EnumClipboardFormats(0)
            while format_id:
                formats.append(format_id)
                format_id = win32clipboard.EnumClipboardFormats(format_id)
            
            text = None
            formatted = None
            
            if win32con.CF_UNICODETEXT in formats:
                text = win32clipboard.GetClipboardData(win32con.CF_UNICODETEXT)
            
            if win32con.CF_RTF in formats:
                formatted = win32clipboard.GetClipboardData(win32con.CF_RTF)
            elif CF_HTML in formats:
                formatted = win32clipboard.GetClipboardData(CF_HTML)
            
            win32clipboard.CloseClipboard()
            
            return {'text': text, 'formatted': formatted} if text else None
        except Exception as e:
            print(f"Error al obtener texto del portapapeles: {e}")
            return None
    def exit_app(self):
        self.manager.root.quit()
        sys.exit()
    
    @measure_time    
    def toggle_paste_format(self):
        self.manager.paste_with_format = not self.manager.paste_with_format
        new_text = "Con formato" if self.manager.paste_with_format else "Sin formato"
        self.manager.button2.config(text=new_text)
        self.manager.navigation.update_highlights()
        
    @measure_time
    def recalculate_card_heights(self):
        for card in self.manager.cards_frame.winfo_children():
            if hasattr(card, 'item_id'):
                item_data = self.manager.clipboard_items[card.item_id]
                new_height = self.calculate_card_height(item_data['text'])
                card.config(height=new_height)
        
        self.manager.canvas.update_idletasks()
        self.manager.canvas.configure(scrollregion=self.manager.canvas.bbox("all"))
        
    def on_arrow_click(self, item_id):
        if not self.manager.group_manager.groups:
            tk.messagebox.showinfo("Sin Grupos", "No hay grupos disponibles. Cree un grupo primero.")
            return

        dialog = tk.Toplevel(self.manager.root)
        dialog.title("Seleccionar Grupo")
        
        window_width = self.manager.settings['width']
        window_height = self.manager.settings['height']
        
        x = self.manager.window_x + 20
        y = self.manager.window_y + 20
        
        dialog.geometry(f"{window_width}x{window_height}+{x}+{y}")
                
        # dialog.geometry("295x400")
        dialog.configure(bg=self.manager.theme_manager.colors['dark']['bg'])
        dialog.overrideredirect(True)
        dialog.attributes('-topmost', True)

        # Barra de t√≠tulo personalizada
        title_frame = tk.Frame(dialog, bg=dialog.cget('bg'))
        title_frame.pack(fill=tk.X, padx=5, pady=(5, 0))

        title_label = tk.Label(title_frame, text="Seleccionar Grupo", font=('Segoe UI', 10, 'bold'),
                            bg=dialog.cget('bg'), fg=self.manager.theme_manager.colors['dark']['fg'])
        title_label.pack(side=tk.LEFT, padx=5)

        close_button = tk.Button(title_frame, text="‚ùå", command=dialog.destroy,
                                font=('Segoe UI', 10, 'bold'), bd=0, padx=10,
                                bg=self.manager.theme_manager.colors['dark']['button_bg'],
                                fg=self.manager.theme_manager.colors['dark']['button_fg'])
        close_button.pack(side=tk.RIGHT)

        # Contenido
        content_frame = tk.Frame(dialog, bg=dialog.cget('bg'))
        content_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)

        for group_id, group_info in self.manager.group_manager.groups.items():
            group_button = tk.Button(content_frame, text=group_info['name'],
                                    command=lambda gid=group_id: self.add_to_group(item_id, gid, dialog),
                                    bg=self.manager.theme_manager.colors['dark']['button_bg'],
                                    fg=self.manager.theme_manager.colors['dark']['button_fg'],
                                    activebackground=self.manager.theme_manager.colors['dark']['active_bg'],
                                    activeforeground=self.manager.theme_manager.colors['dark']['active_fg'],
                                    bd=0, padx=10, pady=5, width=30, anchor='w')
            group_button.pack(fill=tk.X, pady=2)

        # Hacer la ventana arrastrable
        def start_move(event):
            dialog.x = event.x
            dialog.y = event.y

        def on_move(event):
            deltax = event.x - dialog.x
            deltay = event.y - dialog.y
            x = dialog.winfo_x() + deltax
            y = dialog.winfo_y() + deltay
            dialog.geometry(f"+{x}+{y}")

        title_frame.bind('<Button-1>', start_move)
        title_frame.bind('<B1-Motion>', on_move)

    def add_to_group(self, item_id, group_id, dialog):
        self.manager.group_manager.add_item_to_group(item_id, group_id)
        dialog.destroy()
        # tk.messagebox.showinfo("√âxito", "Item agregado al grupo exitosamente.")
        
        
        
# group_content_manager.py

import tkinter as tk
from tkinter import ttk

from utils import process_text

class GroupContentManager:
    def __init__(self, master, clipboard_manager, theme_manager, settings_manager):
        self.master = master
        self.clipboard_manager = clipboard_manager
        self.theme_manager = theme_manager
        self.settings_manager = settings_manager

        self.min_card_height = 50  # Altura m√≠nima en p√≠xeles (2 l√≠neas + 2*2 padding)
        self.max_card_height = 120  # Altura m√°xima en p√≠xeles (4 l√≠neas + 2*2 padding)
        self.line_height = 10      # Altura estimada de una l√≠nea de texto

    def calculate_card_height(self, text):
        lines = len(text.split('\n'))
        if lines > 2:
            content_height = min(lines * (self.line_height*2), 7 * self.line_height)  # M√°ximo 4 l√≠neas
        else:
            content_height = min(lines * self.line_height, 5 * self.line_height)  # M√°ximo 4 l√≠neas
        return min(max(content_height + 5, self.min_card_height), self.max_card_height)

    def show_group_content(self, group_id):
        group_window = tk.Toplevel(self.master)
        group_window.title(f"Contenido del Grupo: {self.clipboard_manager.group_manager.groups[group_id]['name']}")
        
        window_width = self.settings_manager.settings['width']
        window_height = self.settings_manager.settings['height']
        
        x = self.clipboard_manager.window_x + 20
        y = self.clipboard_manager.window_y + 20
        
        group_window.geometry(f"{window_width}x{window_height}+{x}+{y}")
                
        group_window.overrideredirect(True)
        group_window.configure(bg=self.theme_manager.colors['dark']['bg'])
        group_window.attributes('-topmost', True)

        # Barra de t√≠tulo personalizada
        title_frame = tk.Frame(group_window, bg=self.theme_manager.colors['dark']['bg'])
        title_frame.pack(fill=tk.X, padx=6, pady=(0,0))

        title_label = tk.Label(title_frame, text=f"Grupo: {self.clipboard_manager.group_manager.groups[group_id]['name']}", 
                            font=('Segoe UI', 10, 'bold'),
                            bg=self.theme_manager.colors['dark']['bg'],
                            fg=self.theme_manager.colors['dark']['fg'])
        title_label.pack(side=tk.LEFT, padx=5, pady=5)

        close_button = tk.Button(title_frame, text="‚ùå", command=group_window.destroy,
                                font=('Segoe UI', 10, 'bold'),bd=0, padx=10, width=5, height=2,
                                bg=self.theme_manager.colors['dark']['button_bg'],
                                fg=self.theme_manager.colors['dark']['button_fg'])
        close_button.pack(side=tk.RIGHT)

        # Canvas y scroll para los items
        self.canvas = tk.Canvas(group_window, bg=self.theme_manager.colors['dark']['bg'], highlightthickness=0)
        self.canvas.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)

        scrollbar = ttk.Scrollbar(group_window, orient="vertical", command=self.canvas.yview)
        scrollbar.pack(side=tk.RIGHT, fill=tk.Y)

        self.canvas.configure(yscrollcommand=scrollbar.set)

        self.items_frame = tk.Frame(self.canvas, bg=self.theme_manager.colors['dark']['bg'])
        self.canvas.create_window((0, 0), window=self.items_frame, anchor='nw', width=window_width)
        self.canvas_window = self.canvas.create_window((0, 0), window=self.items_frame, anchor='nw', width=window_width)
        # Configurar el desplazamiento con la rueda del rat√≥n
        def _on_mousewheel(event):
            self.canvas.yview_scroll(int(-1*(event.delta/120)), "units")

        self.canvas.bind_all("<MouseWheel>", _on_mousewheel)

        # Asegurar que el ancho del frame interior se ajuste al canvas
        def _configure_inner_frame(event):
            if self.canvas.winfo_exists():
                self.canvas.itemconfig(self.canvas_window, width=event.width)
        
        self.canvas.bind('<Configure>', _configure_inner_frame)

        # Mostrar items del grupo
        self.refresh_group_content(group_id)

        # Hacer la ventana arrastrable
        def start_move(event):
            group_window.x = event.x
            group_window.y = event.y

        def on_move(event):
            deltax = event.x - group_window.x
            deltay = event.y - group_window.y
            x = group_window.winfo_x() + deltax
            y = group_window.winfo_y() + deltay
            group_window.geometry(f"+{x}+{y}")

        title_frame.bind('<Button-1>', start_move)
        title_frame.bind('<B1-Motion>', on_move)

    def refresh_group_content(self, group_id):
        # Limpiar el frame de items existente
        for widget in self.items_frame.winfo_children():
            widget.destroy()
        
        window_width = self.settings_manager.settings['width']
        window_height = self.settings_manager.settings['height'] - 40  # Ajuste para la barra de t√≠tulo

        current_theme = 'dark'  # Puedes cambiar esto si soportas modo claro/oscuro
        theme = self.theme_manager.colors[current_theme]

        for item in self.clipboard_manager.group_manager.groups[group_id]['items']:
            card_width = window_width - 4  # Ajuste m√≠nimo para el padding
            card_height = max(self.min_card_height, self.calculate_card_height(item['text']))
    
            bg_color = theme['card_bg']
    
            card_container = tk.Frame(self.items_frame, width=card_width, height=card_height, bg=bg_color)
            card_container.pack(fill=tk.X, padx=6, pady=(4,0))
            card_container.pack_propagate(False)  # Evita que el contenido afecte el tama√±o del contenedor

            text_frame = tk.Frame(card_container, bg=bg_color, pady=0)
            text_frame.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)

            # Procesamos el texto para mostrarlo de forma limpia
            processed_text = process_text(item['text'], 2)
            item_name = item.get('name', '')

            # Etiqueta para item_name en negrita y tama√±o de fuente mayor
            if item_name:
                item_name_label = tk.Label(
                    text_frame,
                    text=f"{item_name}:",
                    font=("Segoe UI", 10, "bold"),
                    bg=bg_color,
                    fg=theme['fg'],
                    justify=tk.LEFT,
                    anchor='w',
                    width=int(24)
                )
                item_name_label.pack(padx=2, pady=0, fill=tk.X, side=tk.TOP, anchor='w')

            # Etiqueta para processed_text con fuente regular
            text_label = tk.Label(
                text_frame,
                text=processed_text,
                font=("Segoe UI", 10),
                justify=tk.LEFT,
                anchor='w',
                bg=bg_color,
                fg=theme['fg'],
                width=int(24)
            )
            text_label.pack(padx=6, pady=(0,4), fill=tk.X, expand=True, side=tk.TOP)
            
            icons_frame = tk.Frame(card_container, bg=bg_color)
            icons_frame.pack(side=tk.RIGHT, padx=3)

            edit_button = tk.Button(icons_frame, text="‚úèÔ∏è", 
                                    command=lambda i=item['id']: self.edit_group_item(group_id, i),
                                    font=('Segoe UI', 10), bd=0,
                                    padx=2,
                                    bg=bg_color,
                                    fg=theme['fg'])
            edit_button.pack(side=tk.LEFT)

            delete_button = tk.Button(icons_frame, text="üóëÔ∏è", 
                                    command=lambda i=item['id']: self.remove_item_from_group(group_id, i, self.items_frame),
                                    font=('Segoe UI', 10), bd=0,
                                    padx=2,
                                    bg=bg_color,
                                    fg=theme['fg'])
            delete_button.pack(side=tk.LEFT)

        # Actualizar el scrollregion despu√©s de a√±adir todos los widgets
        self.items_frame.update_idletasks()
        self.canvas.config(scrollregion=self.canvas.bbox("all"))
        
    def remove_item_from_group(self, group_id, item_id, items_frame):
        self.clipboard_manager.group_manager.groups[group_id]['items'] = [item for item in self.clipboard_manager.group_manager.groups[group_id]['items'] if item['id'] != item_id]
        self.clipboard_manager.group_manager.save_groups()
        self.refresh_group_content(group_id)

    def edit_group_item(self, group_id, item_id):
        item = next((item for item in self.clipboard_manager.group_manager.groups[group_id]['items'] if item['id'] == item_id), None)
        if not item:
            return

        dialog = tk.Toplevel(self.master)
        dialog.title("Editar Item")
        
        # Calcula la posici√≥n relativa a la ventana principal
        x = self.clipboard_manager.window_x + 40
        y = self.clipboard_manager.window_y + 40
        
        # Calcular la altura inicial basada en el contenido
        text_lines = item['text'].count('\n') + 1
        initial_height = min(150 + (text_lines * 20), 600)  # 20 p√≠xeles por l√≠nea, m√°ximo 600
        
        dialog.geometry(f"300x{initial_height}+{x}+{y}")
        
        dialog.configure(bg=self.theme_manager.colors['dark']['bg'])
        dialog.overrideredirect(True)
        dialog.attributes('-topmost', True)

        # Barra de t√≠tulo personalizada
        title_frame = tk.Frame(dialog, bg=self.theme_manager.colors['dark']['bg'])
        title_frame.pack(fill=tk.X, padx=4, pady=(4, 0))

        title_label = tk.Label(title_frame, text="Editar Item", font=('Segoe UI', 10, 'bold'),
                            bg=self.theme_manager.colors['dark']['bg'],
                            fg=self.theme_manager.colors['dark']['fg'])
        title_label.pack(side=tk.LEFT, padx=0)

        close_button = tk.Button(title_frame, text="‚ùå", command=dialog.destroy,
                                font=('Segoe UI', 10, 'bold'), bd=0, padx=0,
                                bg=self.theme_manager.colors['dark']['button_bg'],
                                fg=self.theme_manager.colors['dark']['button_fg'])
        close_button.pack(side=tk.RIGHT)
        
        # Contenido
        content_frame = tk.Frame(dialog, bg=self.theme_manager.colors['dark']['bg'])
        content_frame.pack(fill=tk.BOTH, expand=True, padx=4, pady=0)

        name_label = tk.Label(content_frame, text="Nombre del item:",
                            bg=self.theme_manager.colors['dark']['bg'],
                            fg=self.theme_manager.colors['dark']['fg'])
        name_label.pack(anchor='w', pady=(0, 5))

        name_entry = tk.Entry(content_frame, bg=self.theme_manager.colors['dark']['button_bg'],
                            fg=self.theme_manager.colors['dark']['fg'],
                            insertbackground=self.theme_manager.colors['dark']['fg'],
                            font=('Segoe UI', 10))
        name_entry.insert(0, item.get('name', ''))
        name_entry.pack(fill=tk.X, pady=(0, 5))

        text_label = tk.Label(content_frame, text="Texto del item:",
                            bg=self.theme_manager.colors['dark']['bg'],
                            fg=self.theme_manager.colors['dark']['fg'])
        text_label.pack(anchor='w', pady=(0, 5))

        text_entry = tk.Text(content_frame, height=3, bg=self.theme_manager.colors['dark']['button_bg'],
                            fg=self.theme_manager.colors['dark']['fg'],
                            insertbackground=self.theme_manager.colors['dark']['fg'],
                            font=('Segoe UI', 10))
        text_entry.insert(tk.END, item['text'])
        text_entry.pack(fill=tk.BOTH, expand=True, pady=(0, 5))

        def save_item():
            new_name = name_entry.get().strip()
            new_text = text_entry.get("1.0", tk.END).strip()
            if new_text:
                item['name'] = new_name
                item['text'] = new_text
                self.clipboard_manager.group_manager.save_groups()
                dialog.destroy()
                self.refresh_group_content(group_id)

        save_button = tk.Button(content_frame, text="Guardar", command=save_item,
                                bg=self.theme_manager.colors['dark']['button_bg'],
                                fg=self.theme_manager.colors['dark']['button_fg'])
        save_button.pack(fill=tk.X, pady=(0, 5))

        # Hacer la ventana arrastrable
        def start_move(event):
            dialog.x = event.x
            dialog.y = event.y

        def on_move(event):
            deltax = event.x - dialog.x
            deltay = event.y - dialog.y
            x = dialog.winfo_x() + deltax
            y = dialog.winfo_y() + deltay
            dialog.geometry(f"+{x}+{y}")

        title_frame.bind('<Button-1>', start_move)
        title_frame.bind('<B1-Motion>', on_move)

        # Funci√≥n para ajustar din√°micamente la altura de la ventana
        def adjust_dialog_height(event=None):
            content = text_entry.get("1.0", tk.END)
            lines = content.count('\n') + 1
            new_height = min(150 + (lines * 20), 600)  # 100 p√≠xeles base + 20 por l√≠nea, m√°ximo 600
            dialog.geometry(f"300x{new_height}")

        # Vincular la funci√≥n de ajuste al evento de cambio en el texto
        text_entry.bind("<KeyRelease>", adjust_dialog_height)

        dialog.focus_set()
        name_entry.focus()

        # Ajustar la altura inicial
        adjust_dialog_height()
        
        
        
# group_manager.py

import tkinter as tk
from tkinter import ttk, simpledialog, messagebox
import uuid
from settings_manager import SettingsManager
from group_content_manager import GroupContentManager


class GroupManager:
    def __init__(self, master, clipboard_manager):
        self.master = master
        self.clipboard_manager = clipboard_manager
        self.data_manager = clipboard_manager.data_manager
        self.theme_manager = clipboard_manager.theme_manager
        self.settings = clipboard_manager.settings
        self.settings_manager = clipboard_manager.settings_manager
        self.groups, _, _ = self.data_manager.load_data()
        self.groups_window = None
        self.groups_frame = None
        self.group_content_manager = GroupContentManager(master, clipboard_manager, clipboard_manager.theme_manager, clipboard_manager.settings_manager)

    def show_group_content(self, group_id):
        self.group_content_manager.show_group_content(group_id)

    def show_groups_window(self):
        if self.groups_window is None or not self.groups_window.winfo_exists():
            self.groups_window = tk.Toplevel(self.master)
            self.groups_window.title("Grupos")
            
            window_width = self.settings['width']
            window_height = self.settings['height']
            # self.groups_window.geometry(f"{window_width}x{window_height}+0+0")
            
             # Calcula la posici√≥n relativa a la ventana principal
            x = self.clipboard_manager.window_x + 10
            y = self.clipboard_manager.window_y + 10
            
            self.groups_window.geometry(f"{window_width}x{window_height}+{x}+{y}")
            
            self.groups_window.overrideredirect(True) # Oculta la barra de t√≠tulo
            
            self.groups_window.configure(bg=self.theme_manager.colors['dark']['bg'])
            self.groups_window.attributes('-topmost', True) # Hacer que la ventana est√© siempre en primer plano
            self.master.bind("<Destroy>", self.on_main_window_close) # Vincular el cierre de la ventana principal al cierre de la ventana de grupos

            # Barra de t√≠tulo personalizada
            title_frame = tk.Frame(self.groups_window, bg=self.theme_manager.colors['dark']['bg'])
            title_frame.pack(fill=tk.X, padx=2, pady=(0, 0))

            title_label = tk.Label(title_frame, text="Grupos", font=('Segoe UI', 10, 'bold'), 
                                   bg=self.theme_manager.colors['dark']['bg'], 
                                   fg=self.theme_manager.colors['dark']['fg'])
            title_label.pack(side=tk.LEFT, padx=5)

            # Botones en la barra de t√≠tulo
            buttons_frame = tk.Frame(title_frame, bg=self.theme_manager.colors['dark']['bg'])
            buttons_frame.pack(side=tk.RIGHT, padx=4)

            add_button = tk.Button(buttons_frame, text="‚ûï", command=self.add_group, 
                                   font=('Segoe UI', 10), bd=0, padx=10, width=5, height=2,
                                   bg=self.theme_manager.colors['dark']['button_bg'],
                                   fg=self.theme_manager.colors['dark']['button_fg'])
            add_button.pack(side=tk.LEFT)

            close_button = tk.Button(buttons_frame, text="‚ùå", command=self.groups_window.destroy, 
                                     font=('Segoe UI', 10, 'bold'), bd=0, padx=10, width=5, height=2,
                                     bg=self.theme_manager.colors['dark']['button_bg'],
                                     fg=self.theme_manager.colors['dark']['button_fg'])
            close_button.pack(side=tk.LEFT)

            # # Marco para la lista de grupos
            # self.groups_frame = tk.Frame(self.groups_window, bg=self.theme_manager.colors['dark']['bg'])
            # self.groups_frame.pack(fill=tk.BOTH, expand=True, padx=2, pady=2)

            # # Hacer la ventana arrastrable
            # title_label.bind('<Button-1>', self.start_move)
            # title_label.bind('<B1-Motion>', self.on_move)
            
            # Canvas para scroll y contenedor de grupos
            canvas = tk.Canvas(self.groups_window, bg=self.theme_manager.colors['dark']['bg'], bd=0, highlightthickness=0)
            canvas.pack(fill=tk.BOTH, expand=True, padx=2, pady=2)

            # Scrollbar oculto
            scrollbar = ttk.Scrollbar(self.groups_window, orient=tk.VERTICAL, command=canvas.yview)
            canvas.configure(yscrollcommand=scrollbar.set)

            # Frame contenedor dentro del canvas para el scroll
            self.groups_frame = tk.Frame(canvas, bg=self.theme_manager.colors['dark']['bg'])
            canvas_window = canvas.create_window((0, 0), window=self.groups_frame, anchor='nw', width=295)

            # Ajustar el ancho del frame contenedor al canvas
            def on_canvas_resize(event):
                canvas.itemconfig(canvas_window, width=event.width)

            canvas.bind("<Configure>", on_canvas_resize)

            # Configuraci√≥n de scroll
            def on_frame_configure(event):
                canvas.configure(scrollregion=canvas.bbox("all"))

            self.groups_frame.bind("<Configure>", on_frame_configure)

            # Funci√≥n para desplazamiento con la rueda del mouse
            def _on_mousewheel(event):
                canvas.yview_scroll(int(-1*(event.delta/120)), "units")

            canvas.bind_all("<MouseWheel>", _on_mousewheel)

            # Hacer la ventana arrastrable
            title_label.bind('<Button-1>', self.start_move)
            title_label.bind('<B1-Motion>', self.on_move)

            self.refresh_groups()

        # Si la ventana de grupos ya estaba abierta, llevarla al frente
        else:
            self.groups_window.lift()
            self.groups_window.attributes('-topmost', True)
            self.groups_window.after_idle(self.groups_window.attributes, '-topmost', False)
        
    def start_move(self, event):
        self.x = event.x
        self.y = event.y

    def on_move(self, event):
        deltax = event.x - self.x
        deltay = event.y - self.y
        x = self.groups_window.winfo_x() + deltax
        y = self.groups_window.winfo_y() + deltay
        self.groups_window.geometry(f"+{x}+{y}")

    def refresh_groups(self):
        if self.groups_frame is None or not self.groups_frame.winfo_exists():
            return

        for widget in self.groups_frame.winfo_children():
            widget.destroy()

        for group_id, group_info in self.groups.items():
            group_card = tk.Frame(self.groups_frame, bg=self.theme_manager.colors['dark']['card_bg'], cursor="hand2")
            group_card.pack(fill=tk.X, padx=4, pady=2)
            
            group_card.bind("<Button-1>", lambda e, gid=group_id: self.show_group_content(gid))

            name_label = tk.Label(group_card, text=group_info['name'], font=("Segoe UI", 10, "bold"),
                                bg=self.theme_manager.colors['dark']['card_bg'],
                                fg=self.theme_manager.colors['dark']['fg'])
            name_label.pack(side=tk.LEFT, padx=5, pady=5)

            count_label = tk.Label(group_card, text=f"Items: {len(group_info['items'])}",
                                bg=self.theme_manager.colors['dark']['card_bg'],
                                fg=self.theme_manager.colors['dark']['fg'])
            count_label.pack(side=tk.LEFT, padx=5, pady=5)
            
            delete_button = tk.Button(group_card, text="    üóëÔ∏è", command=lambda gid=group_id: self.delete_group(gid),
                                    font=('Segoe UI', 10), bd=0, bg=self.theme_manager.colors['dark']['button_bg'],
                                    fg=self.theme_manager.colors['dark']['button_fg'])
            delete_button.pack(side=tk.RIGHT, padx=2, pady=5)

            edit_button = tk.Button(group_card, text="‚úèÔ∏è", command=lambda gid=group_id: self.edit_group(gid),
                                    font=('Segoe UI', 10), bd=0, bg=self.theme_manager.colors['dark']['button_bg'],
                                    fg=self.theme_manager.colors['dark']['button_fg'])
            edit_button.pack(side=tk.RIGHT, padx=2, pady=5)

            
            
    def save_groups(self):
        pinned_items = {k: v for k, v in self.clipboard_manager.clipboard_items.items() if v['pinned']}
        self.data_manager.save_data(self.groups, pinned_items, self.clipboard_manager.settings)
        print("Groups and pinned items saved")
        
    def edit_group(self, group_id):
        self.show_edit_group_dialog(group_id)

    def delete_group(self, group_id):
        # if tk.messagebox.askyesno("Eliminar Grupo", "¬øEst√° seguro de que desea eliminar este grupo?"):
        del self.groups[group_id]
        self.refresh_groups()
        self.save_groups()

    def add_item_to_group(self, item_id, group_id):
        if group_id in self.groups:
            item_data = self.clipboard_manager.clipboard_items.get(item_id)
            if item_data and item_id not in [item['id'] for item in self.groups[group_id]['items']]:
                self.groups[group_id]['items'].append({
                    'id': item_id,
                    'text': item_data['text']
                })
                self.save_groups()
                if self.groups_window and self.groups_window.winfo_exists():
                    self.refresh_groups()
                print(f"Item {item_id} added to group {group_id}")
                
                # Actualizar la vista principal si es necesario
                if hasattr(self.clipboard_manager, 'refresh_cards'):
                    self.clipboard_manager.refresh_cards()
            else:
                print(f"Item {item_id} already in group {group_id} or not found")
        else:
            print(f"Group {group_id} not found")
            
    def on_main_window_close(self, event):
        if self.groups_window and self.groups_window.winfo_exists():
            self.groups_window.destroy()
            
    # ----------------------------------------------------------------------
   
    
    
    def add_group(self):
        dialog = tk.Toplevel(self.master)
        dialog.title("Nuevo Grupo")
        dialog.geometry("200x115")
        
        # Calcula la posici√≥n relativa a la ventana principal
        x = self.clipboard_manager.window_x + 40
        y = self.clipboard_manager.window_y + 40
        
        dialog.geometry(f"+{x}+{y}")
        
        dialog.configure(bg=self.theme_manager.colors['dark']['bg'])
        dialog.overrideredirect(True)
        dialog.attributes('-topmost', True)

        # Barra de t√≠tulo personalizada
        title_frame = tk.Frame(dialog, bg=self.theme_manager.colors['dark']['bg'])
        title_frame.pack(fill=tk.X, padx=4, pady=(4, 0))

        title_label = tk.Label(title_frame, text="Nuevo Grupo", font=('Segoe UI', 10, 'bold'),
                            bg=self.theme_manager.colors['dark']['bg'],
                            fg=self.theme_manager.colors['dark']['fg'])
        title_label.pack(side=tk.LEFT, padx=0)

        close_button = tk.Button(title_frame, text="‚ùå", command=dialog.destroy,
                                font=('Segoe UI', 10, 'bold'), bd=0, padx=0,
                                bg=self.theme_manager.colors['dark']['button_bg'],
                                fg=self.theme_manager.colors['dark']['button_fg'])
        close_button.pack(side=tk.RIGHT)

        # Contenido
        content_frame = tk.Frame(dialog, bg=self.theme_manager.colors['dark']['bg'])
        content_frame.pack(fill=tk.BOTH, expand=True, padx=4, pady=0)

        name_label = tk.Label(content_frame, text="Nombre del grupo:",
                            bg=self.theme_manager.colors['dark']['bg'],
                            fg=self.theme_manager.colors['dark']['fg'])
        name_label.pack(anchor='w', pady=(0, 5))

        name_entry = tk.Entry(content_frame, bg=self.theme_manager.colors['dark']['button_bg'],
                            fg=self.theme_manager.colors['dark']['fg'],
                            insertbackground=self.theme_manager.colors['dark']['fg'],
                            relief=tk.FLAT,  # Quita el efecto 3D
                            bd=0,  # Quita el borde
                            highlightthickness=1,  # A√±ade un borde fino
                            highlightcolor=self.theme_manager.colors['dark'].get('highlight', '#555555'),  # Color del borde cuando tiene foco
                            highlightbackground=self.theme_manager.colors['dark'].get('border', '#333333'))  # Color del borde cuando no tiene foco
        name_entry.pack(fill=tk.X, pady=(0, 0))

        def save_group():
            name = name_entry.get().strip()
            if name:
                group_id = str(uuid.uuid4())
                self.groups[group_id] = {'name': name, 'items': []}
                self.refresh_groups()
                self.save_groups()
                dialog.destroy()

        save_button = tk.Button(content_frame, text="Guardar", command=save_group,
                                bg=self.theme_manager.colors['dark']['button_bg'],
                                fg=self.theme_manager.colors['dark']['button_fg'],
                                activebackground=self.theme_manager.colors['dark'].get('active_bg', '#4E4E4E'),
                                activeforeground=self.theme_manager.colors['dark'].get('active_fg', '#FFFFFF'),
                                relief=tk.FLAT,  # Elimina el estilo 3D
                                bd=0,  # Elimina el borde
                                padx=4, pady=5)
        save_button.pack(fill=tk.X, expand=True, pady=(0, 0))

        # Hacer la ventana arrastrable
        def start_move(event):
            dialog.x = event.x
            dialog.y = event.y

        def on_move(event):
            deltax = event.x - dialog.x
            deltay = event.y - dialog.y
            x = dialog.winfo_x() + deltax
            y = dialog.winfo_y() + deltay
            dialog.geometry(f"+{x}+{y}")

        title_frame.bind('<Button-1>', start_move)
        title_frame.bind('<B1-Motion>', on_move)

        # Centrar el di√°logo en la pantalla
        dialog.update_idletasks()
        width = dialog.winfo_width()
        height = dialog.winfo_height()
        x = (dialog.winfo_screenwidth() // 2) - (width // 2)
        y = (dialog.winfo_screenheight() // 2) - (height // 2)
        dialog.geometry('{}x{}+{}+{}'.format(width, height, x, y))

        dialog.focus_set()
        name_entry.focus()
        
    # ----------------------------------------------------------------------------------
    
    def show_edit_group_dialog(self, group_id):
        dialog = tk.Toplevel(self.master)
        dialog.title("Editar Grupo")
        # dialog.geometry("200x115")
        
        # Calcula la posici√≥n relativa a la ventana principal
        x = self.clipboard_manager.window_x + 40
        y = self.clipboard_manager.window_y + 40
        
        dialog.geometry(f"200x115+{x}+{y}")
        
        dialog.configure(bg=self.theme_manager.colors['dark']['bg'])
        dialog.overrideredirect(True)
        dialog.attributes('-topmost', True)

        # Barra de t√≠tulo personalizada
        title_frame = tk.Frame(dialog, bg=self.theme_manager.colors['dark']['bg'])
        title_frame.pack(fill=tk.X, padx=4, pady=(4, 0))

        title_label = tk.Label(title_frame, text="Editar Grupo", font=('Segoe UI', 10, 'bold'),
                            bg=self.theme_manager.colors['dark']['bg'],
                            fg=self.theme_manager.colors['dark']['fg'])
        title_label.pack(side=tk.LEFT, padx=0)

        close_button = tk.Button(title_frame, text="‚ùå", command=dialog.destroy,
                                font=('Segoe UI', 10, 'bold'), bd=0, padx=0,
                                bg=self.theme_manager.colors['dark']['button_bg'],
                                fg=self.theme_manager.colors['dark']['button_fg'])
        close_button.pack(side=tk.RIGHT)

        # Contenido
        content_frame = tk.Frame(dialog, bg=self.theme_manager.colors['dark']['bg'])
        content_frame.pack(fill=tk.BOTH, expand=True, padx=4, pady=0)

        name_label = tk.Label(content_frame, text="Nuevo nombre del grupo:",
                            bg=self.theme_manager.colors['dark']['bg'],
                            fg=self.theme_manager.colors['dark']['fg'])
        name_label.pack(anchor='w', pady=(0, 5))

        name_entry = tk.Entry(content_frame, bg=self.theme_manager.colors['dark']['button_bg'],
                            fg=self.theme_manager.colors['dark']['fg'],
                            insertbackground=self.theme_manager.colors['dark']['fg'],
                            relief=tk.FLAT,  # Quita el efecto 3D
                            bd=0,  # Quita el borde
                            highlightthickness=1,  # A√±ade un borde fino
                            highlightcolor=self.theme_manager.colors['dark'].get('highlight', '#555555'),  # Color del borde cuando tiene foco
                            highlightbackground=self.theme_manager.colors['dark'].get('border', '#333333'))  # Color del borde cuando no tiene foco
        name_entry.insert(0, self.groups[group_id]['name'])
        name_entry.pack(fill=tk.X, pady=(0, 0))

        def save_group():
            new_name = name_entry.get().strip()
            if new_name:
                self.groups[group_id]['name'] = new_name
                self.refresh_groups()
                self.save_groups()
                dialog.destroy()

        save_button = tk.Button(content_frame, text="Guardar", command=save_group,
                                bg=self.theme_manager.colors['dark']['button_bg'],
                                fg=self.theme_manager.colors['dark']['button_fg'],
                                activebackground=self.theme_manager.colors['dark'].get('active_bg', '#4E4E4E'),
                                activeforeground=self.theme_manager.colors['dark'].get('active_fg', '#FFFFFF'),
                                relief=tk.FLAT,  # Elimina el estilo 3D
                                bd=0,  # Elimina el borde
                                padx=4, pady=5)
        save_button.pack(fill=tk.X, expand=True, pady=(0, 0))  # Hace que el bot√≥n ocupe todo el ancho disponible

        # Hacer la ventana arrastrable
        def start_move(event):
            dialog.x = event.x
            dialog.y = event.y

        def on_move(event):
            deltax = event.x - dialog.x
            deltay = event.y - dialog.y
            x = dialog.winfo_x() + deltax
            y = dialog.winfo_y() + deltay
            dialog.geometry(f"+{x}+{y}")

        title_frame.bind('<Button-1>', start_move)
        title_frame.bind('<B1-Motion>', on_move)

        # Centrar el di√°logo en la pantalla
        dialog.update_idletasks()
        width = dialog.winfo_width()
        height = dialog.winfo_height()
        x = (dialog.winfo_screenwidth() // 2) - (width // 2)
        y = (dialog.winfo_screenheight() // 2) - (height // 2)
        dialog.geometry('{}x{}+{}+{}'.format(width, height, x, y))

        dialog.focus_set()
        name_entry.focus()
        
        
        
# main.py

import sys
import tkinter as tk
from structure import ClipboardManager

def main():
    root = tk.Tk()
    show_settings = "--show-settings" in sys.argv
    app = ClipboardManager(root, show_settings)
    # Aplicar las configuraciones iniciales
    root.geometry(f"{app.settings_manager.settings['width']}x{app.settings_manager.settings['height']}+0+0")
    
    if show_settings:
        root.after(100, app.settings_manager.show_settings_window)
    
    root.mainloop()

if __name__ == "__main__":
    main()
    
            
#theme_manager.py

import tkinter as tk
from tkinter import ttk

class ThemeManager:
    def __init__(self, manager):
        self.manager = manager
        self.colors = {
            'dark': {
                'bg': '#1e1e1e',
                'fg': '#ffffff',
                'button_bg': '#333333',
                'button_fg': '#ffffff',
                'listbox_bg': '#2d2d2d',
                'listbox_fg': '#ffffff',
                'active_bg': '#4E4E4E',  # A√±adido
                'active_fg': '#FFFFFF',  # A√±adido
                'card_bg': '#333333'
            },
            'light': {
                'bg': '#f0f0f0',
                'fg': '#000000',
                'button_bg': '#e0e0e0',
                'button_fg': '#000000',
                'listbox_bg': '#ffffff',
                'listbox_fg': '#000000',
                'active_bg': '#D0D0D0',  # A√±adido
                'active_fg': '#000000',  # A√±adido
                'card_bg': '#ffffff'
            }
        }

    def toggle_theme(self):
        self.manager.is_dark_mode = not self.manager.is_dark_mode
        self.manager.theme_button.config(text="üåô" if self.manager.is_dark_mode else "‚òÄÔ∏è")
        self.apply_theme()

    def apply_theme(self):
        theme = self.colors['dark'] if self.manager.is_dark_mode else self.colors['light']
        
        self.manager.root.configure(bg=theme['bg'])
        self.manager.main_frame.configure(style='Main.TFrame')
        self.manager.title_frame.configure(bg=theme['bg'])
        self.manager.title_label.configure(bg=theme['bg'], fg=theme['fg'])
        
        self.manager.clear_button.configure(
            bg=theme['button_bg'],
            fg=theme['button_fg'],
            activebackground=theme['button_bg'],
            activeforeground=theme['button_fg']
        )
        self.manager.theme_button.configure(
            bg=theme['button_bg'],
            fg=theme['button_fg'],
            activebackground=theme['button_bg'],
            activeforeground=theme['button_fg']
        )
        
        self.manager.close_button.configure(
            bg=theme['button_bg'],
            fg=theme['button_fg'],
            activebackground=theme['button_bg'],
            activeforeground=theme['button_fg']
        )

        self.manager.button1.configure(
            bg=theme['button_bg'],
            fg=theme['button_fg'],
            activebackground=theme['button_bg'],
            activeforeground=theme['button_fg']
        )

        self.manager.button2.configure(
            bg=theme['button_bg'],
            fg=theme['button_fg'],
            activebackground=theme['button_bg'],
            activeforeground=theme['button_fg']
        )

        self.manager.button3.configure(
            bg=theme['button_bg'],
            fg=theme['button_fg'],
            activebackground=theme['button_bg'],
            activeforeground=theme['button_fg']
        )

        self.manager.canvas.configure(bg=theme['bg'])
        self.manager.cards_frame.configure(bg=theme['bg'])
        
        self.manager.functions.refresh_cards()

        style = ttk.Style()  
        style.theme_use('clam')  
        style.configure('Main.TFrame', background=theme['bg'])
        
        
        
# utils.py

import time

def measure_time(func):
    def wrapper(*args, **kwargs):
        start_time = time.time()
        result = func(*args, **kwargs)
        end_time = time.time()
        print(f"{func.__name__} tom√≥ {(end_time - start_time) * 1000:.2f} ms")
        return result
    return wrapper

def process_text(text_data, cant_lineas):
    """
    Procesa el texto para mostrarlo de forma limpia y ordenada
    """
    # Comprueba si text_data es un diccionario y extrae el texto
    if isinstance(text_data, dict):
        text = text_data.get('text', '')
    else:
        text = str(text_data)

    # Eliminamos espacios extras y tabulaciones al inicio y final
    text = text.strip()
    
    # Dividimos el texto en l√≠neas
    lines = text.splitlines()
    
    # Eliminamos l√≠neas vac√≠as consecutivas y espacios extras
    clean_lines = []
    prev_empty = False
    for line in lines:
        line = line.strip()
        
        # Si la l√≠nea est√° vac√≠a
        if not line:
            if not prev_empty:  # Solo mantenemos una l√≠nea vac√≠a
                clean_lines.append('')
                prev_empty = True
        else:
            clean_lines.append(line)
            prev_empty = False
    
    # Tomamos solo las primeras 'cant_lineas' para la vista previa
    preview_lines = clean_lines[:cant_lineas]
    
    # Si hay m√°s l√≠neas, indicamos cu√°ntas m√°s hay
    if len(clean_lines) > cant_lineas:
        remaining_lines = len(clean_lines) - cant_lineas
        preview_lines.append(f"+ {remaining_lines} l√≠neas m√°s")
        
    # Unimos las l√≠neas con saltos de l√≠nea
    return '\n'.join(preview_lines)



# --------------------------------------------------------------------
# settings_manager.py

import json
import os
import sys
import tkinter as tk
from tkinter import ttk

class SettingsManager:
    def __init__(self, master, clipboard_manager):
        self.master = master
        self.clipboard_manager = clipboard_manager
        self.settings_window = None
        self.settings = None      
          
    def initialize_settings(self):
        # Llama a este m√©todo despu√©s de que ClipboardManager haya inicializado completamente
        self.settings = self.clipboard_manager.settings
        
    def save_settings(self):
        groups, pinned_items, _ = self.clipboard_manager.data_manager.load_data()
        self.clipboard_manager.data_manager.save_data(groups, pinned_items, self.settings)
        
    def show_settings_window(self):
        if self.settings_window is None or not self.settings_window.winfo_exists():
            self.settings_window = tk.Toplevel(self.master)
            self.settings_window.title("Configuraciones")
            
            window_width = self.settings['width']
            window_height = self.settings['height']

            # Usa las coordenadas de la ventana principal o una posici√≥n predeterminada
            x = getattr(self.clipboard_manager, 'window_x', 0) + 50
            y = getattr(self.clipboard_manager, 'window_y', 0) + 50
            
            self.settings_window.geometry(f"{window_width}x{window_height}+{x}+{y}")
            
            self.settings_window.overrideredirect(True)
            self.settings_window.configure(bg=self.clipboard_manager.theme_manager.colors['dark']['bg'])
            self.settings_window.attributes('-topmost', True)

            # Barra de t√≠tulo personalizada
            title_frame = tk.Frame(self.settings_window, bg=self.clipboard_manager.theme_manager.colors['dark']['bg'])
            title_frame.pack(fill=tk.X, padx=6, pady=(0, 0))

            title_label = tk.Label(title_frame, text="Configuraciones", font=('Segoe UI', 10, 'bold'), 
                                   bg=self.clipboard_manager.theme_manager.colors['dark']['bg'], 
                                   fg=self.clipboard_manager.theme_manager.colors['dark']['fg'])
            title_label.pack(side=tk.LEFT, padx=5)

            close_button = tk.Button(title_frame, text="‚ùå", command=self.settings_window.destroy, 
                                     font=('Segoe UI', 10, 'bold'), bd=0, padx=10, width=5, height=2,
                                     bg=self.clipboard_manager.theme_manager.colors['dark']['button_bg'],
                                     fg=self.clipboard_manager.theme_manager.colors['dark']['button_fg'])
            close_button.pack(side=tk.RIGHT)

            # Canvas para scroll y contenedor de configuraciones
            canvas = tk.Canvas(self.settings_window, bg=self.clipboard_manager.theme_manager.colors['dark']['bg'], bd=0, highlightthickness=0)
            canvas.pack(fill=tk.BOTH, expand=True, padx=2, pady=2)

            # Scrollbar oculto
            scrollbar = ttk.Scrollbar(self.settings_window, orient=tk.VERTICAL, command=canvas.yview)
            canvas.configure(yscrollcommand=scrollbar.set)

            # Frame contenedor dentro del canvas para el scroll
            self.settings_frame = tk.Frame(canvas, bg=self.clipboard_manager.theme_manager.colors['dark']['bg'])
            canvas_window = canvas.create_window((0, 0), window=self.settings_frame, anchor='nw', width=295)

            # Ajustar el ancho del frame contenedor al canvas
            def on_canvas_resize(event):
                canvas.itemconfig(canvas_window, width=event.width)

            canvas.bind("<Configure>", on_canvas_resize)

            # Configuraci√≥n de scroll
            def on_frame_configure(event):
                canvas.configure(scrollregion=canvas.bbox("all"))

            self.settings_frame.bind("<Configure>", on_frame_configure)

            # Funci√≥n para desplazamiento con la rueda del mouse
            def _on_mousewheel(event):
                canvas.yview_scroll(int(-1*(event.delta/120)), "units")

            canvas.bind_all("<MouseWheel>", _on_mousewheel)

            # Crear cards de configuraci√≥n
            subtitle = tk.Label(self.settings_frame, text="Tecla de activaci√≥n", 
                        font=('Segoe UI', 10, 'bold'),
                        bg=self.clipboard_manager.theme_manager.colors['dark']['bg'],
                        fg=self.clipboard_manager.theme_manager.colors['dark']['fg'],
                        anchor='w')
            subtitle.pack(fill=tk.X, padx=4, pady=(10, 5), anchor='w')
            self.create_setting_card("Alt+", self.settings['hotkey'])
            
            subtitle = tk.Label(self.settings_frame, text="Dimensiones de la app", 
                        font=('Segoe UI', 10, 'bold'),
                        bg=self.clipboard_manager.theme_manager.colors['dark']['bg'],
                        fg=self.clipboard_manager.theme_manager.colors['dark']['fg'],
                        anchor='w')
            subtitle.pack(fill=tk.X, padx=4, pady=(10, 5), anchor='w')
            self.create_setting_card("Alto", str(self.settings['height']))
            self.create_setting_card("Ancho", str(self.settings['width']))

            # Hacer la ventana arrastrable
            title_label.bind('<Button-1>', self.start_move)
            title_label.bind('<B1-Motion>', self.on_move)

        else:
            self.settings_window.lift()
            self.settings_window.attributes('-topmost', True)
            self.settings_window.after_idle(self.settings_window.attributes, '-topmost', False)

    def create_setting_card(self, setting_name, default_value):
        card = tk.Frame(self.settings_frame, bg=self.clipboard_manager.theme_manager.colors['dark']['card_bg'])
        card.pack(fill=tk.X, padx=4, pady=2)

        label = tk.Label(card, text=f"{setting_name}: {default_value}", 
                         bg=self.clipboard_manager.theme_manager.colors['dark']['card_bg'],
                         fg=self.clipboard_manager.theme_manager.colors['dark']['fg'],
                         anchor='w', padx=5, pady=5)
        label.pack(side=tk.LEFT, fill=tk.X, expand=True)

        edit_button = tk.Button(card, text="‚úèÔ∏è", 
                                command=lambda: self.toggle_edit_mode(card, label, edit_button, setting_name, default_value),
                                font=('Segoe UI', 10), bd=0,
                                bg=self.clipboard_manager.theme_manager.colors['dark']['button_bg'],
                                fg=self.clipboard_manager.theme_manager.colors['dark']['button_fg'])
        edit_button.pack(side=tk.RIGHT, padx=2, pady=2)

    def toggle_edit_mode(self, card, label, button, setting_name, current_value):
        if button['text'] == "‚úèÔ∏è":
            # Cambiar a modo edici√≥n
            entry = tk.Entry(card, bg=self.clipboard_manager.theme_manager.colors['dark']['button_bg'],
                             fg=self.clipboard_manager.theme_manager.colors['dark']['fg'],
                             insertbackground=self.clipboard_manager.theme_manager.colors['dark']['fg'])
            entry.insert(0, current_value)
            entry.pack(side=tk.LEFT, fill=tk.X, expand=True, padx=5, pady=5)
            label.pack_forget()
            button.configure(text="üíæ")
        else:
            # Guardar cambios
            entry = [child for child in card.winfo_children() if isinstance(child, tk.Entry)][0]
            new_value = entry.get()
            label.configure(text=f"{setting_name}: {new_value}")
            entry.destroy()
            label.pack(side=tk.LEFT, fill=tk.X, expand=True)
            button.configure(text="‚úèÔ∏è")
            
            # Actualizar configuraciones
            if setting_name == "Alto":
                self.settings['height'] = int(new_value)
            elif setting_name == "Ancho":
                self.settings['width'] = int(new_value)
            elif setting_name == "Alt+":
                old_hotkey = self.settings['hotkey']
                self.settings['hotkey'] = new_value
                self.clipboard_manager.key_manager.update_hotkey(old_hotkey, new_value)
                
            self.save_settings()
            self.restart_app()
            
    def restart_app(self):
        python = sys.executable
        os.execl(python, python, *sys.argv, "--show-settings")
            
    def start_move(self, event):
        self.x = event.x
        self.y = event.y

    def on_move(self, event):
        deltax = event.x - self.x
        deltay = event.y - self.y
        x = self.settings_window.winfo_x() + deltax
        y = self.settings_window.winfo_y() + deltay
        self.settings_window.geometry(f"+{x}+{y}")



# structure.py

import tkinter as tk
from tkinter import ttk
import time
import threading
from datetime import datetime
import keyboard # type: ignore
import sys
import win32gui # type: ignore
import pyautogui  # A√±ade esta importaci√≥n al principio del archivo

from functions import Functions
from key_manager import KeyManager
from navigation import Navigation
from theme_manager import ThemeManager
from group_manager import GroupManager
from data_manager import DataManager
from settings_manager import SettingsManager

class ClipboardManager:
    def __init__(self, root, show_settings=False):
        self.root = root
        self.root.title("Portapapeles")

        self.data_manager = DataManager()
        groups, pinned_items, settings = self.data_manager.load_data()
        
        self.settings = settings
        self.settings_manager = SettingsManager(self.root, self)
        self.settings_manager.initialize_settings()

        self.window_width = settings['width']
        self.window_height = settings['height']
        self.window_x = 0  # Inicializa window_x
        self.window_y = 0  # Inicializa window_y

        self.root.overrideredirect(True)
        
        self.root.withdraw()
        self.is_visible = False

        self.previous_window = None

        self.clipboard_items = pinned_items
        self.current_clipboard = ""
        self.selected_index = None
        self.current_selection = {'type': 'button', 'index': 0}
        self.is_dark_mode = True
        
        self.paste_with_format = True
        
        self.previous_window = None
        self.last_active_window = None
        self.selected_button = None
        self.selected_card = None
        self.selected_icon = None
        self.total_buttons = 6
        self.top_buttons = 3
        self.icons_per_card = 3
        
        self.paste_with_format = True  # Variable de estado de la app
        
        self.hotkey = f"alt+{settings['hotkey']}"

        self.theme_manager = ThemeManager(self)
        self.functions = Functions(self)
        self.navigation = Navigation(self)
        self.key_manager = KeyManager(self)
        self.group_manager = GroupManager(self.root, self)
        
        self.group_manager.groups = groups
        
        self.create_gui()
        self.load_saved_data()
        self.theme_manager.apply_theme()

        self.root.bind('<Return>', self.navigation.activate_selected)
        self.root.bind('<Up>', self.navigation.navigate_vertical)
        self.root.bind('<Down>', self.navigation.navigate_vertical)
        self.root.bind('<Left>', self.navigation.navigate_horizontal)
        self.root.bind('<Right>', self.navigation.navigate_horizontal)
        self.root.bind('<FocusIn>', self.navigation.handle_focus)

        self.monitor_thread = threading.Thread(target=self.functions.monitor_clipboard, daemon=True)
        self.monitor_thread.start()

        # self.navigation.update_hotkey(None, self.settings_manager.settings['hotkey'])
        self.key_manager.update_hotkey(None, self.settings_manager.settings['hotkey'])
        self.key_manager.setup_global_keys()
        
        self.root.after(1000, self.navigation.check_window_state)
        self.root.bind("<Map>", self.on_main_window_map)
        self.root.bind("<Unmap>", self.on_main_window_unmap)
        
        if show_settings:
            self.root.after(100, self.settings_manager.show_settings_window)

    def create_gui(self):
        self.main_frame = ttk.Frame(self.root, style='Main.TFrame')
        self.main_frame.pack(fill=tk.BOTH, expand=True)

        self.title_frame = tk.Frame(self.main_frame, bg=self.theme_manager.colors['dark']['bg'])
        self.title_frame.pack(fill=tk.X, padx=3, pady=(0,6))

        self.title_label = tk.Label(self.title_frame, text="Portapapeles", font=('Segoe UI', 10, 'bold'), bg=self.theme_manager.colors['dark']['bg'], fg=self.theme_manager.colors['dark']['fg'])
        self.title_label.pack(side=tk.LEFT, padx=5)

        buttons_frame = tk.Frame(self.title_frame, bg=self.theme_manager.colors['dark']['bg'])
        buttons_frame.pack(side=tk.RIGHT, padx=4)

        self.theme_button = tk.Button(buttons_frame, text="üåô", command=self.theme_manager.toggle_theme, font=('Segoe UI', 10), bd=0, padx=10, width=5, height=2)
        self.theme_button.pack(side=tk.LEFT)

        self.clear_button = tk.Button(buttons_frame, text="    üñ•Ô∏è", command=self.settings_manager.show_settings_window, font=('Segoe UI', 10), bd=0, padx=10, width=5, height=2)
        self.clear_button.pack(side=tk.LEFT)

        self.close_button = tk.Button(buttons_frame, text="‚ùå", command=self.functions.exit_app, font=('Segoe UI', 10, 'bold'), bd=0, padx=10, width=5, height=2)
        self.close_button.pack(side=tk.LEFT)

        main_buttons_frame = tk.Frame(self.main_frame, bg=self.theme_manager.colors['dark']['bg'])
        main_buttons_frame.pack(fill=tk.X, padx=6, pady=0)

        self.button1 = tk.Button(main_buttons_frame, text="Grupos", 
                                 command=self.show_groups, font=('Segoe UI', 10), 
                                 bg=self.theme_manager.colors['dark']['button_bg'], 
                                 fg=self.theme_manager.colors['dark']['button_fg'],
                                 relief=tk.FLAT,
                                 bd=0,
                                 highlightthickness=1,
                                 pady=8)
        self.button1.pack(side=tk.LEFT, fill=tk.X, expand=True, padx=1, pady=0)

        self.button2 = tk.Button(main_buttons_frame, text="Con formato", 
                                 command=self.functions.toggle_paste_format, font=('Segoe UI', 10), 
                                 bg=self.theme_manager.colors['dark']['button_bg'], 
                                 fg=self.theme_manager.colors['dark']['button_fg'],
                                 relief=tk.FLAT,
                                 bd=0,
                                 highlightthickness=1,
                                 pady=8) 
        self.button2.pack(side=tk.LEFT, fill=tk.X, expand=True, padx=1, pady=0)

        self.button3 = tk.Button(main_buttons_frame, text="Borrar Todo", 
                                 command=self.functions.clear_history, font=('Segoe UI', 10), 
                                 bg=self.theme_manager.colors['dark']['button_bg'], 
                                 fg=self.theme_manager.colors['dark']['button_fg'],
                                 relief=tk.FLAT,
                                 bd=0,
                                 highlightthickness=1,
                                 pady=8)                               
        self.button3.pack(side=tk.LEFT, fill=tk.X, expand=True, padx=1, pady=0)

        self.canvas = tk.Canvas(self.main_frame, bd=0, highlightthickness=0)
        self.canvas.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)
        
        self.cards_frame = tk.Frame(self.canvas, bg=self.theme_manager.colors['dark']['bg'])
        self.canvas_window = self.canvas.create_window((0, 0), window=self.cards_frame, anchor='nw')

        self.scrollbar = ttk.Scrollbar(self.main_frame, orient=tk.VERTICAL, command=self.canvas.yview)
        self.canvas.configure(yscrollcommand=self.scrollbar.set)
        # self.scrollbar.pack(side=tk.RIGHT, fill=tk.Y)

        # Variables para el movimiento de la ventana
        self._drag_data = {"x": 0, "y": 0, "item": None}

        # Vincular eventos para mover la ventana
        self.title_label.bind('<Button-1>', self.start_move)
        self.title_label.bind('<ButtonRelease-1>', self.stop_move)
        self.title_label.bind('<B1-Motion>', self.on_move)
        
        # Vincula eventos de scroll
        self.canvas.bind('<Configure>', self.on_canvas_configure)
        self.cards_frame.bind('<Configure>', self.on_frame_configure)
        self.canvas.bind_all("<MouseWheel>", self.on_mousewheel)

    def scrollbar_set(self, start, end):
        # Este m√©todo se llama cuando el canvas actualiza su regi√≥n de scroll
        self.canvas.yview_moveto(float(start))
        
    def start_move(self, event):
        self._drag_data["x"] = event.x
        self._drag_data["y"] = event.y

    def stop_move(self, event):
        self._drag_data["x"] = 0
        self._drag_data["y"] = 0
        self._drag_data["item"] = None

    def on_move(self, event):
        delta_x = event.x - self._drag_data["x"]
        delta_y = event.y - self._drag_data["y"]
        x = self.root.winfo_x() + delta_x
        y = self.root.winfo_y() + delta_y
        self.root.geometry(f"+{x}+{y}")
        self.window_x = x  # Actualiza la posici√≥n x de la ventana
        self.window_y = y  # Actualiza la posici√≥n y de la ventana

    def on_scroll(self, *args):
        # Este m√©todo se llama cuando se realiza un scroll
        if len(args) == 3 and isinstance(args[2], str):
            self.canvas.yview_moveto(args[0])
        elif len(args) == 2 and isinstance(args[0], str):
            self.canvas.yview_scroll(int(args[1]), args[0])

    def on_canvas_configure(self, event):
        # Ajusta el tama√±o del √°rea scrollable cuando el canvas cambia de tama√±o
        self.canvas.configure(scrollregion=self.canvas.bbox("all"))
        width = event.width
        self.canvas.itemconfig(self.canvas_window, width=width)

    def on_frame_configure(self, event):
        # Ajusta el √°rea scrollable cuando el contenido del frame cambia
        self.canvas.configure(scrollregion=self.canvas.bbox("all"))

    def on_mousewheel(self, event):
        # Maneja el evento de la rueda del rat√≥n para hacer scroll
        self.canvas.yview_scroll(int(-1 * (event.delta / 120)), "units")
        
    def show_groups(self):
        self.group_manager.show_groups_window()
        
    def load_saved_data(self):
        groups, pinned_items, _ = self.data_manager.load_data()
        self.group_manager.groups = groups
        self.clipboard_items.update(pinned_items)
        self.functions.refresh_cards()
        
    def on_main_window_map(self, event):
        if self.group_manager.groups_window and self.group_manager.groups_window.winfo_exists():
            self.group_manager.groups_window.deiconify()

    def on_main_window_unmap(self, event):
        if self.group_manager.groups_window and self.group_manager.groups_window.winfo_exists():
            self.group_manager.groups_window.withdraw()
            
            
            
# key_manager.py
import win32com
import win32clipboard  # type: ignore
import keyboard
import win32gui
import win32com.client
import pyperclip
import time
import pyautogui

# Definir CF_HTML ya que no est√° en win32con
CF_HTML = win32clipboard.RegisterClipboardFormat("HTML Format")

class KeyManager:
    def __init__(self, manager):
        self.manager = manager
        self.hotkey = self.manager.hotkey
        self.update_hotkey(None, self.hotkey)

    def update_hotkey(self, old_hotkey, new_hotkey):
        if old_hotkey:
            try:
                keyboard.remove_hotkey(old_hotkey)
            except KeyError:
                print(f"No se pudo eliminar el atajo anterior: {old_hotkey}")

        keyboard.add_hotkey(new_hotkey, self.toggle_window)
        self.current_hotkey = new_hotkey
        print(f"Nuevo atajo configurado: {new_hotkey}")

    def toggle_window(self):
        if not self.manager.is_visible:
            self.manager.root.after(10, self.manager.functions.recalculate_card_heights)
        try:
            if self.manager.is_visible:
                self.hide_window()
            else:
                self.manager.previous_window = win32gui.GetForegroundWindow()
                self.manager.root.after(10, self.show_window)
        except Exception as e:
            print(f"Error al alternar la ventana: {e}")

    def hide_window(self):
        try:
            self.manager.root.attributes('-topmost', False)
            self.manager.root.withdraw()
            self.manager.is_visible = False
            self.restore_focus()
        except Exception as e:
            print(f"Error al ocultar la ventana: {e}")

    def show_window(self):
        try:
            self.manager.previous_window = win32gui.GetForegroundWindow()
            
            # Obtener la posici√≥n actual del cursor
            mouse_x, mouse_y = pyautogui.position()
            
            # Calcular la posici√≥n de la ventana
            window_x = mouse_x - self.manager.window_width // 2
            window_y = mouse_y - self.manager.window_height // 2
            
            # Asegurar que la ventana no se salga de la pantalla
            screen_width, screen_height = pyautogui.size()
            window_x = max(0, min(window_x, screen_width - self.manager.window_width))
            window_y = max(0, min(window_y, screen_height - self.manager.window_height))
            
            self.manager.root.geometry(f"{self.manager.window_width}x{self.manager.window_height}+{window_x}+{window_y}")
            self.manager.window_x = window_x  # Guarda la posici√≥n x de la ventana
            self.manager.window_y = window_y  # Guarda la posici√≥n y de la ventana
            
            self.manager.root.deiconify()
            self.manager.root.geometry("+0+0") 
            self.manager.root.lift()  
            self.manager.root.attributes('-topmost', True)
            
            self.manager.is_visible = True
            
            self.manager.navigation.initialize_focus()
        
            if not hasattr(self.manager, 'current_selection') or not self.manager.current_selection:
                self.manager.current_selection = {'type': 'card', 'index': 0}
            
            self.manager.root.focus_force()
            self.manager.navigation.update_highlights()
            
        except Exception as e:
            print(f"Error al mostrar la ventana: {e}")

    def restore_focus(self):
        if self.manager.previous_window:
            try:
                win32gui.SetForegroundWindow(self.manager.previous_window)
            except Exception as e:
                print(f"Error al restaurar el foco: {e}")
                try:
                    self.manager.root.after(100, lambda: win32gui.SetForegroundWindow(self.manager.previous_window))
                except:
                    pass

    def handle_global_key(self, key):
        if self.manager.is_visible:
            if key in ['Up', 'Down']:
                self.manager.navigation.navigate_vertical(type('Event', (), {'keysym': key})())
            elif key in ['Left', 'Right']:
                self.manager.navigation.navigate_horizontal(type('Event', (), {'keysym': key})())
            elif key == 'Return':
                self.manager.navigation.activate_selected()
            self.manager.root.after(10, self.manager.root.update_idletasks)
            return 'break'  # Prevenir que el evento se propague
        return None

    def setup_global_keys(self):
        keyboard.add_hotkey('up', lambda: self.manager.root.after(0, lambda: self.handle_global_key('Up')))
        keyboard.add_hotkey('down', lambda: self.manager.root.after(0, lambda: self.handle_global_key('Down')))
        keyboard.add_hotkey('left', lambda: self.manager.root.after(0, lambda: self.handle_global_key('Left')))
        keyboard.add_hotkey('right', lambda: self.manager.root.after(0, lambda: self.handle_global_key('Right')))
        keyboard.add_hotkey('enter', lambda: self.manager.root.after(0, lambda: self.handle_global_key('Return')))

    def paste_content(self, clipboard_data):
        try:
            self.hide_window()
            
            if isinstance(clipboard_data, dict):
                text = clipboard_data.get('text', '')
                formatted = clipboard_data.get('formatted')
            else:
                text = str(clipboard_data)
                formatted = None

            if self.manager.paste_with_format and formatted:
                # Pegar con formato
                win32clipboard.OpenClipboard()
                win32clipboard.EmptyClipboard()
                if isinstance(formatted, str) and formatted.startswith('{\\rtf'):
                    win32clipboard.SetClipboardData(win32con.CF_RTF, formatted.encode('utf-8')) 
                elif isinstance(formatted, str):
                    win32clipboard.SetClipboardData(CF_HTML, formatted.encode('utf-8'))
                win32clipboard.CloseClipboard()
            else:
                # Pegar sin formato
                pyperclip.copy(text)
            
            time.sleep(0.05)
            
            if self.manager.previous_window:
                win32gui.SetForegroundWindow(self.manager.previous_window)
                time.sleep(0.05)
                
                shell = win32com.client.Dispatch("WScript.Shell")
                shell.SendKeys("^v")
                
        except Exception as e:
            print(f"Error en el proceso de pegado: {e}")
            
            
            
# navigation.py

import tkinter as tk
import win32gui
from utils import measure_time

class Navigation:
    def __init__(self, manager):
        self.manager = manager

    @measure_time
    def navigate_vertical(self, event):
        if not self.manager.is_visible:
            return
        
        current_type = self.manager.current_selection['type']
        current_index = self.manager.current_selection['index']
        
        try:
            if current_type == 'card':
                items = list(self.manager.clipboard_items.keys())
                if event.keysym == 'Up':
                    if current_index > 0:
                        self.manager.current_selection['index'] = current_index - 1
                    else:
                        # Mover a los botones 1, 2 y pegar
                        self.manager.current_selection = {'type': 'button', 'index': 0}
                elif event.keysym == 'Down':
                    if current_index < len(items) - 1:
                        self.manager.current_selection['index'] = current_index + 1
            
            elif current_type == 'button':
                if event.keysym == 'Up':
                    if current_index < 3:  # Estamos en los botones 1, 2, pegar
                        # Mover a la barra superior
                        self.manager.current_selection = {'type': 'top_button', 'index': 0}
                    else:  # Estamos en la barra superior
                        # No hacer nada, ya estamos en la parte superior
                        pass
                elif event.keysym == 'Down':
                    if current_index < 3:  # Estamos en los botones 1, 2, pegar
                        if len(self.manager.clipboard_items) > 0:
                            # Mover a la primera card
                            self.manager.current_selection = {'type': 'card', 'index': 0}
                    else:  # Estamos en la barra superior
                        # Mover a los botones 1, 2, pegar
                        self.manager.current_selection = {'type': 'button', 'index': 0}
            
            elif current_type == 'top_button':
                if event.keysym == 'Down':
                    # Mover a los botones 1, 2, pegar
                    self.manager.current_selection = {'type': 'button', 'index': 0}
            
            elif current_type == 'icon':
                card_index = current_index // self.manager.icons_per_card
                if event.keysym == 'Up':
                    if card_index > 0:
                        self.manager.current_selection = {'type': 'card', 'index': card_index - 1}
                    else:
                        # Mover a los botones 1, 2, pegar
                        self.manager.current_selection = {'type': 'button', 'index': 0}
                elif event.keysym == 'Down':
                    if card_index < len(self.manager.clipboard_items) - 1:
                        self.manager.current_selection = {'type': 'card', 'index': card_index + 1}
            
            if len(self.manager.cards_frame.winfo_children()) > 0:
                target_widget = None
                if current_type == 'card' and self.manager.current_selection['index'] < len(self.manager.clipboard_items):
                    target_widget = self.manager.cards_frame.winfo_children()[self.manager.current_selection['index']]
                
                if target_widget:
                    self.ensure_visible(target_widget)
            
            self.update_highlights()
            
        except Exception as e:
            print(f"Error en navegaci√≥n vertical: {e}")
            
    @measure_time
    def navigate_horizontal(self, event):
        if not self.manager.is_visible:
            return
        
        current_type = self.manager.current_selection['type']
        current_index = self.manager.current_selection['index']
        
        try:
            if current_type == 'card':
                if event.keysym == 'Right':
                    # Mover al icono de flecha (primer icono)
                    self.manager.current_selection = {'type': 'icon', 'index': current_index * self.manager.icons_per_card}
                # No hay acci√≥n para 'Left' en una card
            
            elif current_type == 'icon':
                card_index = current_index // self.manager.icons_per_card
                icon_position = current_index % self.manager.icons_per_card
                
                if event.keysym == 'Left':
                    if icon_position > 0:
                        # Mover al icono anterior
                        self.manager.current_selection['index'] = current_index - 1
                    else:
                        # Volver a la card
                        self.manager.current_selection = {'type': 'card', 'index': card_index}
                elif event.keysym == 'Right':
                    if icon_position < self.manager.icons_per_card - 1:
                        # Mover al siguiente icono
                        self.manager.current_selection['index'] = current_index + 1
                    # No hay acci√≥n si estamos en el √∫ltimo icono
            
            elif current_type == 'button':
                if current_index < 3:  # Botones 1, 2, pegar
                    if event.keysym == 'Left':
                        self.manager.current_selection['index'] = (current_index - 1) % 3
                    elif event.keysym == 'Right':
                        self.manager.current_selection['index'] = (current_index + 1) % 3
                else:  # Barra superior
                    if event.keysym == 'Left':
                        self.manager.current_selection['index'] = 3 + (current_index - 4) % 3
                    elif event.keysym == 'Right':
                        self.manager.current_selection['index'] = 3 + (current_index - 2) % 3
            
            elif current_type == 'top_button':
                if event.keysym == 'Left':
                    self.manager.current_selection['index'] = (current_index - 1) % 3
                elif event.keysym == 'Right':
                    self.manager.current_selection['index'] = (current_index + 1) % 3
            
            self.update_highlights()
            
        except Exception as e:
            print(f"Error en navegaci√≥n horizontal: {e}")

    @measure_time
    def activate_selected(self, event=None):
        current_type = self.manager.current_selection['type']
        current_index = self.manager.current_selection['index']
        
        if current_type == 'button':
            if current_index == 0:  # Bot√≥n 1
                self.manager.show_groups()
            elif current_index == 1:  # Bot√≥n 2
                self.manager.functions.toggle_paste_format()
            elif current_index == 2:  # Bot√≥n 3 (Borrar Todo)
                self.manager.functions.clear_history()
            elif current_index == 3:  # Bot√≥n Eliminar todas las cards
                self.manager.functions.clear_history()
            elif current_index == 4:  # Bot√≥n Cambiar tema
                self.manager.theme_manager.toggle_theme()
            elif current_index == 5:  # Bot√≥n Cerrar app
                self.manager.functions.exit_app()
        elif current_type == 'card':
            items = list(self.manager.clipboard_items.items())
            if current_index < len(items):
                item_id, item_data = items[current_index]
                clipboard_data = item_data['text']
                self.manager.key_manager.paste_content(clipboard_data)
        elif current_type == 'icon':
            items = list(self.manager.clipboard_items.keys())
            card_index = current_index // self.manager.icons_per_card
            icon_position = current_index % self.manager.icons_per_card
            
            if card_index < len(items):
                item_id = items[card_index]
                if icon_position == 0:  # Arrow
                    self.manager.functions.on_arrow_click(item_id)
                elif icon_position == 1:  # Pin
                    self.manager.functions.toggle_pin(item_id)
                elif icon_position == 2:  # Delete
                    self.manager.functions.delete_item(item_id)

    def initialize_focus(self):
        try:
            # Iniciar la selecci√≥n en la primera card si hay cards disponibles
            if len(self.manager.clipboard_items) > 0:
                self.manager.current_selection = {'type': 'card', 'index': 0}
            else:
                # Si no hay cards, iniciar en el primer bot√≥n principal
                self.manager.current_selection = {'type': 'button', 'index': 0}
            
            self.manager.root.focus_force()
            self.manager.root.update_idletasks()
            self.update_highlights()
            
        except Exception as e:
            print(f"Error al inicializar foco: {e}")

    def handle_focus(self, event=None):
        if self.manager.is_visible:
            self.manager.root.focus_force()

    def ensure_visible(self, widget):
        if widget is None:
            return
            
        try:
            bbox = self.manager.canvas.bbox("all")
            if bbox:
                widget_y = widget.winfo_y()
                canvas_height = self.manager.canvas.winfo_height()
                if widget_y > 0:
                    self.manager.canvas.yview_moveto(widget_y / bbox[3])
        except Exception as e:
            print(f"Error al asegurar visibilidad: {e}")

    @measure_time
    def update_highlights(self):
        self.clear_all_highlights()
        
        current_type = self.manager.current_selection['type']
        current_index = self.manager.current_selection['index']
        
        highlight_color = '#444444' if self.manager.is_dark_mode else '#cccccc'
        icon_highlight_color = '#666666' if self.manager.is_dark_mode else '#aaaaaa'
        
        try:
            if current_type == 'button':
                buttons = [self.manager.button1, self.manager.button2, self.manager.button3]
                if 0 <= current_index < len(buttons):
                    buttons[current_index].configure(bg=highlight_color)
            
            elif current_type == 'top_button':
                top_buttons = [self.manager.clear_button, self.manager.theme_button, self.manager.close_button]
                if 0 <= current_index < len(top_buttons):
                    top_buttons[current_index].configure(bg=highlight_color)
            
            elif current_type == 'card':
                cards = self.manager.cards_frame.winfo_children()
                if current_index < len(cards):
                    card = cards[current_index]
                    self.highlight_entire_card(card, highlight_color)
                    self.ensure_visible(card)
            
            elif current_type == 'icon':
                card_index = current_index // self.manager.icons_per_card
                icon_position = current_index % self.manager.icons_per_card
                cards = self.manager.cards_frame.winfo_children()
                
                if card_index < len(cards):
                    card = cards[card_index]
                    icons_frame = None
                    
                    for child in card.winfo_children():
                        if isinstance(child, tk.Frame) and child.winfo_children() and isinstance(child.winfo_children()[0], tk.Button):
                            icons_frame = child
                            break
                    
                    if icons_frame and icon_position < len(icons_frame.winfo_children()):
                        icons = icons_frame.winfo_children()
                        if 0 <= icon_position < len(icons):
                            icons[icon_position].configure(bg=icon_highlight_color)
                    self.ensure_visible(card)
                    
        except Exception as e:
            print(f"Error al actualizar highlights: {e}")
        
    def clear_all_highlights(self):
        theme = self.manager.theme_manager.colors['dark' if self.manager.is_dark_mode else 'light']
        base_color = theme['card_bg']
        
        buttons = [self.manager.button1, self.manager.button2, self.manager.button3,
                   self.manager.clear_button, self.manager.theme_button, self.manager.close_button]
        for button in buttons:
            button.configure(bg=theme['button_bg'])
        
        for card in self.manager.cards_frame.winfo_children():
            card.configure(bg=base_color)
            
            for child in card.winfo_children():
                child.configure(bg=base_color)
                if isinstance(child, tk.Frame):
                    for subchild in child.winfo_children():
                        if isinstance(subchild, (tk.Label, tk.Button)):
                            subchild.configure(bg=base_color)
                            
    def highlight_entire_card(self, card, color):
        card.configure(bg=color)
    
        text_frame = card.winfo_children()[0]  
        text_frame.configure(bg=color)
        for subwidget in text_frame.winfo_children():
            if isinstance(subwidget, tk.Label):
                subwidget.configure(bg=color)
        
        theme = self.manager.theme_manager.colors['dark' if self.manager.is_dark_mode else 'light']
        icons_frame = card.winfo_children()[-1]
        icons_frame.configure(bg=theme['card_bg'])
        for icon in icons_frame.winfo_children():
            icon.configure(bg=theme['card_bg'])

    def check_window_state(self):
        try:
            actual_visible = self.manager.root.winfo_viewable()
            if actual_visible != self.manager.is_visible:
                print(f"Corrigiendo estado de visibilidad: {self.manager.is_visible} -> {actual_visible}")
                self.manager.is_visible = actual_visible
        except Exception as e:
            print(f"Error al verificar estado de la ventana: {e}")

    def update_active_window(self):
        self.manager.last_active_window = win32gui.GetForegroundWindow()