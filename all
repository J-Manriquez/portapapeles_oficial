// Archivo: data_manager.py

import json
import os

class DataManager:
    def __init__(self, file_path='clipboard_data.json'):
        self.file_path = file_path

    def save_data(self, groups, pinned_items, settings):
        data = {
            'groups': groups,
            'pinned_items': self.encode_pinned_items(pinned_items),
            'settings': settings
        }
        with open(self.file_path, 'w') as f:
            json.dump(data, f, indent=4)
        print(f"All data saved to {self.file_path}")

    def load_data(self):
        if not os.path.exists(self.file_path):
            return {}, {}, {
                'height': 400,
                'width': 295,
                'hotkey': 'v'
            }
        
        with open(self.file_path, 'r') as f:
            data = json.load(f)
        
        groups = data.get('groups', {})
        pinned_items = self.decode_pinned_items(data.get('pinned_items', {}))
        settings = data.get('settings', {
            'height': 400,
            'width': 295,
            'hotkey': 'v'
        })
        
        return groups, pinned_items, settings

    def decode_pinned_items(self, encoded_items):
        decoded_items = {}
        for item_id, item_data in encoded_items.items():
            decoded_item = item_data.copy()
            if isinstance(item_data['text'], dict) and 'format' in item_data['text']:
                decoded_item['text'] = self.decode_formatted_text(item_data['text'])
            decoded_items[item_id] = decoded_item
        return decoded_items
    
    def encode_pinned_items(self, pinned_items):
        encoded_items = {}
        for item_id, item_data in pinned_items.items():
            encoded_item = item_data.copy()
            if isinstance(item_data['text'], dict):
                encoded_item['text'] = self.encode_formatted_text(item_data['text'])
            else:
                # Si el texto no es un diccionario, lo tratamos como texto simple
                encoded_item['text'] = self.encode_formatted_text({'text': item_data['text'], 'formatted': {}})
            encoded_items[item_id] = encoded_item
        return encoded_items

    def encode_formatted_text(self, text_data):
        if isinstance(text_data, str):
            # Si text_data es una cadena, la tratamos como texto simple
            return {
                'text': text_data,
                'format': {}
            }
        elif isinstance(text_data, dict):
            # Si text_data es un diccionario, asumimos que tiene la estructura esperada
            text = text_data.get('text', '')
            formatted = text_data.get('formatted', {})
            
            if isinstance(formatted, dict):
                return {
                    'text': text,
                    'format': {
                        'font': formatted.get('font'),
                        'size': formatted.get('size'),
                        'color': formatted.get('color'),
                        'bold': formatted.get('bold'),
                        'italic': formatted.get('italic'),
                        'rtf': formatted.get('rtf'),
                        'html': formatted.get('html'),
                        'underline': formatted.get('underline'),
                        'strikethrough': formatted.get('strikethrough'),
                        'superscript': formatted.get('superscript'),
                        'subscript': formatted.get('subscript'),
                        'background_color': formatted.get('background_color'),
                        'alignment': formatted.get('alignment'),
                    }
                }
            else:
                # Si 'formatted' no es un diccionario, devolvemos un formato vac√≠o
                return {
                    'text': text,
                    'format': {}
                }
        else:
            # Para cualquier otro tipo, convertimos a string y devolvemos sin formato
            return {
                'text': str(text_data),
                'format': {}
            }
                    
    def decode_formatted_text(self, encoded_text):
        return {
            'text': encoded_text['text'],
            'formatted': encoded_text['format']
        }

// Archivo: functions.py
# functions.py

import base64
import re
import tkinter as tk
import uuid
import win32con # type: ignore
import win32clipboard # type: ignore
import win32gui # type: ignore
import time
import sys
from bs4 import BeautifulSoup
from utils import measure_time, process_text

# Definir CF_HTML ya que no est√° en win32con
CF_HTML = win32clipboard.RegisterClipboardFormat("HTML Format")

class Functions:
    def __init__(self, manager):
        self.manager = manager
        self.min_card_height = 40  # Altura m√≠nima en p√≠xeles (2 l√≠neas + 2*2 padding)
        self.max_card_height = 76  # Altura m√°xima en p√≠xeles (4 l√≠neas + 2*2 padding)
        self.line_height = 18  # Altura estimada de una l√≠nea de texto


    @measure_time
    def create_card(self, item_id, item_data, index):
        card_width = self.manager.window_width - 4  # Ajuste para el padding
        card_height = max(self.min_card_height, self.calculate_card_height(item_data['text']))
        
        # Procesamos el texto para mostrarlo de forma limpia
        if isinstance(item_data['text'], dict):
            processed_text = process_text(item_data['text'].get('text', ''), 3)
        else:
            processed_text = process_text(str(item_data['text']), 3)
        
        # Obt√©n el color de fondo actual
        current_theme = 'dark' if self.manager.is_dark_mode else 'light'
        bg_color = self.manager.theme_manager.colors[current_theme]['card_bg']

        card_container = tk.Frame(self.manager.cards_frame, width=card_width, height=card_height, bg=bg_color)
        card_container.pack(fill=tk.BOTH, padx=2, pady=2)
        card_container.pack_propagate(False)  # Evita que el contenido afecte el tama√±o del contenedor

        text_frame = tk.Frame(card_container, bg=bg_color)
        text_frame.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)

        # Procesamos el texto para mostrarlo de forma limpia
        processed_text = process_text(item_data['text'], 3)

        text_label = tk.Label(text_frame, text=processed_text,
                            justify=tk.LEFT, anchor='w', padx=10, pady=5,
                            bg=card_container['bg'],
                            fg=self.manager.theme_manager.colors['dark' if self.manager.is_dark_mode else 'light']['fg'], width=int(24))
        text_label.pack(fill=tk.X, expand=True, side=tk.LEFT)

        icons_frame = tk.Frame(card_container, bg=card_container['bg'])
        icons_frame.pack(side=tk.RIGHT, padx=3)

        arrow_button = tk.Button(icons_frame, text="‚û°Ô∏è",
                                command=lambda: self.on_arrow_click(item_id),
                                font=('Segoe UI', 10), bd=0,
                                padx=2,
                                bg=card_container['bg'],
                                fg=self.manager.theme_manager.colors['dark' if self.manager.is_dark_mode else 'light']['fg'])
        arrow_button.pack(side=tk.LEFT)
        
        pin_text = "üìå" if item_data['pinned'] else "üìç"
        pin_button = tk.Button(icons_frame, text=pin_text,
                            command=lambda: self.toggle_pin(item_id),
                            font=('Segoe UI', 10), bd=0,
                            padx=2,
                            bg=card_container['bg'],
                            fg=self.manager.theme_manager.colors['dark' if self.manager.is_dark_mode else 'light']['fg'])
        pin_button.pack(side=tk.LEFT)

        delete_button = tk.Button(icons_frame, text="‚úñÔ∏è",
                                command=lambda: self.delete_item(item_id),
                                font=('Segoe UI', 10), bd=0,
                                padx=2,
                                bg=card_container['bg'],
                                fg=self.manager.theme_manager.colors['dark' if self.manager.is_dark_mode else 'light']['fg'])
        delete_button.pack(side=tk.LEFT)
        
        return card_container
    
    def calculate_card_height(self, text_data):
        if isinstance(text_data, dict):
            text = text_data.get('text', '')
        else:
            text = str(text_data)
        lines = len(text.split('\n'))
        content_height = min(lines * self.line_height, 4 * self.line_height)  # M√°ximo 4 l√≠neas
        return min(max(content_height + 4, self.min_card_height), self.max_card_height)
    
    @measure_time
    def refresh_cards(self):
        if not hasattr(self.manager, 'cards_frame') or not self.manager.cards_frame.winfo_exists():
            print("cards_frame no existe o ha sido destruido")
            return
        # Eliminar tarjetas obsoletas
        existing_cards = {child.item_id: child for child in self.manager.cards_frame.winfo_children() if hasattr(child, 'item_id')}
        
        for item_id in list(existing_cards.keys()):
            if item_id not in self.manager.clipboard_items:
                existing_cards[item_id].destroy()
                del existing_cards[item_id]

        # Actualizar o crear nuevas tarjetas
        for index, (item_id, item_data) in enumerate(self.manager.clipboard_items.items()):
            if item_id in existing_cards:
                card = existing_cards[item_id]
                self.update_card(card, item_data)
            else:
                card = self.create_card(item_id, item_data, index)
                card.item_id = item_id

            card.pack(fill=tk.X, padx=2, pady=2)

        # Actualizar la regi√≥n de desplazamiento
        self.manager.canvas.update_idletasks()
        self.manager.canvas.configure(scrollregion=self.manager.canvas.bbox("all"))
        self.recalculate_card_heights()
        # Asegurarse de que el scroll est√© en la parte superior despu√©s de actualizar
        self.manager.canvas.yview_moveto(0)
        

    def update_card(self, card, item_data):
        processed_text = process_text(item_data['text'], 3)
        text_label = card.winfo_children()[0].winfo_children()[0]
        text_label.config(text=processed_text)

        new_height = self.calculate_card_height(processed_text)
        card.config(height=new_height)

        # Actualizar el estado del bot√≥n de pin
        pin_button = card.winfo_children()[1].winfo_children()[1]
        pin_text = "üìå" if item_data['pinned'] else "üìç"
        pin_button.config(text=pin_text)
        
    def apply_theme_to_card(self, card, theme):
        card.configure(bg=theme['card_bg'])
        
        for child in card.winfo_children():
            if isinstance(child, tk.Frame):
                child.configure(bg=theme['card_bg'])
                for subchild in child.winfo_children():
                    if isinstance(subchild, (tk.Label, tk.Button)):
                        subchild.configure(bg=theme['card_bg'], fg=theme['fg'])
            elif isinstance(child, (tk.Label, tk.Button)):
                child.configure(bg=theme['card_bg'], fg=theme['fg'])

    def toggle_pin(self, item_id):
        if item_id in self.manager.clipboard_items:
            self.manager.clipboard_items[item_id]['pinned'] = not self.manager.clipboard_items[item_id]['pinned']
            self.refresh_cards()
            self.manager.group_manager.save_groups()  # Guardar despu√©s de cambiar el estado de anclaje

    def delete_item(self, item_id):
        if item_id in self.manager.clipboard_items and not self.manager.clipboard_items[item_id]['pinned']:
            del self.manager.clipboard_items[item_id]
            self.refresh_cards()
            self.manager.group_manager.save_groups()  # Guardar despu√©s de eliminar un item

    
    def clear_history(self):
        self.manager.clipboard_items = {k: v for k, v in self.manager.clipboard_items.items() if v['pinned']}
        self.refresh_cards()
        self.manager.group_manager.save_groups()  # Guardar despu√©s de limpiar el historial
        if self.manager.current_selection['type'] == 'card':
            self.manager.current_selection = {'type': 'button', 'index': 0}
        self.manager.navigation.update_highlights()

    def on_canvas_configure(self, event):
        self.manager.canvas.configure(scrollregion=self.manager.canvas.bbox("all"))

    def on_mousewheel(self, event):
        self.manager.canvas.yview_scroll(int(-1 * (event.delta / 120)), "units")

    @measure_time
    def monitor_clipboard(self):
        while True:
            try:
                clipboard_content = self.get_clipboard_text()
                if clipboard_content and clipboard_content != self.manager.current_clipboard:
                    self.manager.current_clipboard = clipboard_content
                    if clipboard_content['text'] not in [item['text'].get('text', '') if isinstance(item['text'], dict) else item['text'] for item in self.manager.clipboard_items.values()]:
                        new_id = str(uuid.uuid4())
                        new_item = {
                            'text': clipboard_content,
                            'pinned': False,
                            'with_format': self.manager.paste_with_format
                        }
                        # Usar after para actualizar la GUI en el hilo principal
                        self.manager.root.after(0, self.add_clipboard_item, new_id, new_item)
            except Exception as e:
                print(f"Error en monitor_clipboard: {e}")
            time.sleep(0.5)
            
    def add_clipboard_item(self, new_id, new_item):
        # Aseg√∫rate de que new_item['text'] siempre sea un diccionario
        if isinstance(new_item['text'], str):
            new_item['text'] = {'text': new_item['text'], 'formatted': {}}
        elif not isinstance(new_item['text'], dict):
            new_item['text'] = {'text': str(new_item['text']), 'formatted': {}}

        self.manager.clipboard_items[new_id] = new_item
        if len(self.manager.clipboard_items) > 20:
            unpinned_items = [k for k, v in self.manager.clipboard_items.items() if not v['pinned']]
            if unpinned_items:
                del self.manager.clipboard_items[unpinned_items[-1]]
        self.refresh_cards()
        self.manager.group_manager.save_groups()

    # @measure_time
    def get_clipboard_text(self):
        try:
            win32clipboard.OpenClipboard()
            formats = []
            format_id = win32clipboard.EnumClipboardFormats(0)
            while format_id:
                formats.append(format_id)
                format_id = win32clipboard.EnumClipboardFormats(format_id)
            
            text = None
            format_info = {}
            
            if win32con.CF_UNICODETEXT in formats:
                text = win32clipboard.GetClipboardData(win32con.CF_UNICODETEXT)
            
            if win32con.CF_RTF in formats:
                rtf_data = win32clipboard.GetClipboardData(win32con.CF_RTF)
                format_info = self.extract_format_info_from_rtf(rtf_data)
            elif CF_HTML in formats:
                html_data = win32clipboard.GetClipboardData(CF_HTML)
                format_info = self.extract_format_info_from_html(html_data)
            
            win32clipboard.CloseClipboard()
            
            if text:
                if format_info:
                    return {'text': text, 'formatted': format_info}
                else:
                    return text  # Retorna solo el texto si no hay informaci√≥n de formato
            return None
        except Exception as e:
            print(f"Error al obtener texto del portapapeles: {e}")
            return None
        
    def extract_format_info_from_rtf(self, rtf_data):
        format_info = {'rtf': True}
        
        # Extraer informaci√≥n de fuente
        font_match = re.search(r'\\fonttbl.*?{\\f0\\fnil (.*?);}', rtf_data)
        if font_match:
            format_info['font'] = font_match.group(1)

        # Extraer informaci√≥n de tama√±o
        size_match = re.search(r'\\fs(\d+)', rtf_data)
        if size_match:
            format_info['size'] = int(size_match.group(1)) / 2  # RTF usa el doble del tama√±o real

        # Extraer informaci√≥n de color
        color_match = re.search(r'\\red(\d+)\\green(\d+)\\blue(\d+)', rtf_data)
        if color_match:
            format_info['color'] = (int(color_match.group(1)), int(color_match.group(2)), int(color_match.group(3)))

        # Extraer informaci√≥n de negrita e it√°lica
        format_info['bold'] = r'\b' in rtf_data
        format_info['italic'] = r'\i' in rtf_data

        return format_info

    def extract_format_info_from_html(self, html_data):
        format_info = {'html': True}
        soup = BeautifulSoup(html_data, 'html.parser')
        
        # Buscar el primer elemento con estilo
        styled_element = soup.find(style=True)
        if styled_element:
            style = styled_element['style']
            
            # Extraer informaci√≥n de fuente
            font_match = re.search(r'font-family:\s*(.*?);', style)
            if font_match:
                format_info['font'] = font_match.group(1)

            # Extraer informaci√≥n de tama√±o
            size_match = re.search(r'font-size:\s*(\d+)pt', style)
            if size_match:
                format_info['size'] = int(size_match.group(1))

            # Extraer informaci√≥n de color
            color_match = re.search(r'color:\s*rgb\((\d+),\s*(\d+),\s*(\d+)\)', style)
            if color_match:
                format_info['color'] = (int(color_match.group(1)), int(color_match.group(2)), int(color_match.group(3)))

        # Extraer informaci√≥n de negrita e it√°lica
        format_info['bold'] = bool(soup.find(['strong', 'b']))
        format_info['italic'] = bool(soup.find(['em', 'i']))

        return format_info
    def exit_app(self):
        self.manager.root.quit()
        sys.exit()
    
    @measure_time    
    def toggle_paste_format(self):
        self.manager.paste_with_format = not self.manager.paste_with_format
        new_text = "Con formato" if self.manager.paste_with_format else "Sin formato"
        self.manager.button2.config(text=new_text)
        self.manager.navigation.update_highlights()
        
    @measure_time
    def recalculate_card_heights(self):
        for card in self.manager.cards_frame.winfo_children():
            if hasattr(card, 'item_id'):
                item_data = self.manager.clipboard_items[card.item_id]
                new_height = self.calculate_card_height(item_data['text'])
                card.config(height=new_height)
        
        self.manager.canvas.update_idletasks()
        self.manager.canvas.configure(scrollregion=self.manager.canvas.bbox("all"))
        
    def on_arrow_click(self, item_id):
        if not self.manager.group_manager.groups:
            tk.messagebox.showinfo("Sin Grupos", "No hay grupos disponibles. Cree un grupo primero.")
            return

        dialog = tk.Toplevel(self.manager.root)
        dialog.title("Seleccionar Grupo")
        
        window_width = self.manager.settings['width']
        window_height = self.manager.settings['height']
        
        x = self.manager.window_x + 20
        y = self.manager.window_y + 20
        
        dialog.geometry(f"{window_width}x{window_height}+{x}+{y}")
                
        # dialog.geometry("295x400")
        dialog.configure(bg=self.manager.theme_manager.colors['dark']['bg'])
        dialog.overrideredirect(True)
        dialog.attributes('-topmost', True)

        # Barra de t√≠tulo personalizada
        title_frame = tk.Frame(dialog, bg=dialog.cget('bg'))
        title_frame.pack(fill=tk.X, padx=5, pady=(5, 0))

        title_label = tk.Label(title_frame, text="Seleccionar Grupo", font=('Segoe UI', 10, 'bold'),
                            bg=dialog.cget('bg'), fg=self.manager.theme_manager.colors['dark']['fg'])
        title_label.pack(side=tk.LEFT, padx=5)

        close_button = tk.Button(title_frame, text="‚ùå", command=dialog.destroy,
                                font=('Segoe UI', 10, 'bold'), bd=0, padx=10,
                                bg=self.manager.theme_manager.colors['dark']['button_bg'],
                                fg=self.manager.theme_manager.colors['dark']['button_fg'])
        close_button.pack(side=tk.RIGHT)

        # Contenido
        content_frame = tk.Frame(dialog, bg=dialog.cget('bg'))
        content_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)

        for group_id, group_info in self.manager.group_manager.groups.items():
            group_button = tk.Button(content_frame, text=group_info['name'],
                                    command=lambda gid=group_id: self.add_to_group(item_id, gid, dialog),
                                    bg=self.manager.theme_manager.colors['dark']['button_bg'],
                                    fg=self.manager.theme_manager.colors['dark']['button_fg'],
                                    activebackground=self.manager.theme_manager.colors['dark']['active_bg'],
                                    activeforeground=self.manager.theme_manager.colors['dark']['active_fg'],
                                    bd=0, padx=10, pady=5, width=30, anchor='w')
            group_button.pack(fill=tk.X, pady=2)

        # Hacer la ventana arrastrable
        def start_move(event):
            dialog.x = event.x
            dialog.y = event.y

        def on_move(event):
            deltax = event.x - dialog.x
            deltay = event.y - dialog.y
            x = dialog.winfo_x() + deltax
            y = dialog.winfo_y() + deltay
            dialog.geometry(f"+{x}+{y}")

        title_frame.bind('<Button-1>', start_move)
        title_frame.bind('<B1-Motion>', on_move)

    def add_to_group(self, item_id, group_id, dialog):
        self.manager.group_manager.add_item_to_group(item_id, group_id)
        dialog.destroy()
        # tk.messagebox.showinfo("√âxito", "Item agregado al grupo exitosamente.")

// Archivo: group_content_manager.py
# group_content_manager.py

import tkinter as tk
from tkinter import ttk

from utils import process_text

class GroupContentManager:
    def __init__(self, master, clipboard_manager, theme_manager, settings_manager):
        self.master = master
        self.clipboard_manager = clipboard_manager
        self.theme_manager = theme_manager
        self.settings_manager = settings_manager

        self.min_card_height = 50  # Altura m√≠nima en p√≠xeles (2 l√≠neas + 2*2 padding)
        self.max_card_height = 120  # Altura m√°xima en p√≠xeles (4 l√≠neas + 2*2 padding)
        self.line_height = 10      # Altura estimada de una l√≠nea de texto

    def calculate_card_height(self, text):
        lines = len(text.split('\n'))
        if lines > 2:
            content_height = min(lines * (self.line_height*2), 7 * self.line_height)  # M√°ximo 4 l√≠neas
        else:
            content_height = min(lines * self.line_height, 5 * self.line_height)  # M√°ximo 4 l√≠neas
        return min(max(content_height + 5, self.min_card_height), self.max_card_height)

    def show_group_content(self, group_id):
        group_window = tk.Toplevel(self.master)
        group_window.title(f"Contenido del Grupo: {self.clipboard_manager.group_manager.groups[group_id]['name']}")
        
        window_width = self.settings_manager.settings['width']
        window_height = self.settings_manager.settings['height']
        
        x = self.clipboard_manager.window_x + 20
        y = self.clipboard_manager.window_y + 20
        
        group_window.geometry(f"{window_width}x{window_height}+{x}+{y}")
                
        group_window.overrideredirect(True)
        group_window.configure(bg=self.theme_manager.colors['dark']['bg'])
        group_window.attributes('-topmost', True)

        # Barra de t√≠tulo personalizada
        title_frame = tk.Frame(group_window, bg=self.theme_manager.colors['dark']['bg'])
        title_frame.pack(fill=tk.X, padx=6, pady=(0,0))

        title_label = tk.Label(title_frame, text=f"Grupo: {self.clipboard_manager.group_manager.groups[group_id]['name']}", 
                            font=('Segoe UI', 10, 'bold'),
                            bg=self.theme_manager.colors['dark']['bg'],
                            fg=self.theme_manager.colors['dark']['fg'])
        title_label.pack(side=tk.LEFT, padx=5, pady=5)

        close_button = tk.Button(title_frame, text="‚ùå", command=group_window.destroy,
                                font=('Segoe UI', 10, 'bold'),bd=0, padx=10, width=5, height=2,
                                bg=self.theme_manager.colors['dark']['button_bg'],
                                fg=self.theme_manager.colors['dark']['button_fg'])
        close_button.pack(side=tk.RIGHT)

        # Canvas y scroll para los items
        self.canvas = tk.Canvas(group_window, bg=self.theme_manager.colors['dark']['bg'], highlightthickness=0)
        self.canvas.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)

        scrollbar = ttk.Scrollbar(group_window, orient="vertical", command=self.canvas.yview)
        scrollbar.pack(side=tk.RIGHT, fill=tk.Y)

        self.canvas.configure(yscrollcommand=scrollbar.set)

        self.items_frame = tk.Frame(self.canvas, bg=self.theme_manager.colors['dark']['bg'])
        self.canvas.create_window((0, 0), window=self.items_frame, anchor='nw', width=window_width)
        self.canvas_window = self.canvas.create_window((0, 0), window=self.items_frame, anchor='nw', width=window_width)
        # Configurar el desplazamiento con la rueda del rat√≥n
        def _on_mousewheel(event):
            self.canvas.yview_scroll(int(-1*(event.delta/120)), "units")

        self.canvas.bind_all("<MouseWheel>", _on_mousewheel)

        # Asegurar que el ancho del frame interior se ajuste al canvas
        def _configure_inner_frame(event):
            if self.canvas.winfo_exists():
                self.canvas.itemconfig(self.canvas_window, width=event.width)
        
        self.canvas.bind('<Configure>', _configure_inner_frame)

        # Mostrar items del grupo
        self.refresh_group_content(group_id)

        # Hacer la ventana arrastrable
        def start_move(event):
            group_window.x = event.x
            group_window.y = event.y

        def on_move(event):
            deltax = event.x - group_window.x
            deltay = event.y - group_window.y
            x = group_window.winfo_x() + deltax
            y = group_window.winfo_y() + deltay
            group_window.geometry(f"+{x}+{y}")

        title_frame.bind('<Button-1>', start_move)
        title_frame.bind('<B1-Motion>', on_move)

    def refresh_group_content(self, group_id):
        # Limpiar el frame de items existente
        for widget in self.items_frame.winfo_children():
            widget.destroy()
        
        window_width = self.settings_manager.settings['width']
        window_height = self.settings_manager.settings['height'] - 40  # Ajuste para la barra de t√≠tulo

        current_theme = 'dark'  # Puedes cambiar esto si soportas modo claro/oscuro
        theme = self.theme_manager.colors[current_theme]

        for item in self.clipboard_manager.group_manager.groups[group_id]['items']:
            card_width = window_width - 4  # Ajuste m√≠nimo para el padding
            card_height = max(self.min_card_height, self.calculate_card_height(item['text']))
    
            bg_color = theme['card_bg']
    
            card_container = tk.Frame(self.items_frame, width=card_width, height=card_height, bg=bg_color)
            card_container.pack(fill=tk.X, padx=6, pady=(4,0))
            card_container.pack_propagate(False)  # Evita que el contenido afecte el tama√±o del contenedor

            text_frame = tk.Frame(card_container, bg=bg_color, pady=0)
            text_frame.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)

            # Procesamos el texto para mostrarlo de forma limpia
            processed_text = process_text(item['text'], 2)
            item_name = item.get('name', '')

            # Etiqueta para item_name en negrita y tama√±o de fuente mayor
            if item_name:
                item_name_label = tk.Label(
                    text_frame,
                    text=f"{item_name}:",
                    font=("Segoe UI", 10, "bold"),
                    bg=bg_color,
                    fg=theme['fg'],
                    justify=tk.LEFT,
                    anchor='w',
                    width=int(24)
                )
                item_name_label.pack(padx=2, pady=0, fill=tk.X, side=tk.TOP, anchor='w')

            # Etiqueta para processed_text con fuente regular
            text_label = tk.Label(
                text_frame,
                text=processed_text,
                font=("Segoe UI", 10),
                justify=tk.LEFT,
                anchor='w',
                bg=bg_color,
                fg=theme['fg'],
                width=int(24)
            )
            text_label.pack(padx=6, pady=(0,4), fill=tk.X, expand=True, side=tk.TOP)
            
            icons_frame = tk.Frame(card_container, bg=bg_color)
            icons_frame.pack(side=tk.RIGHT, padx=3)

            edit_button = tk.Button(icons_frame, text="‚úèÔ∏è", 
                                    command=lambda i=item['id']: self.edit_group_item(group_id, i),
                                    font=('Segoe UI', 10), bd=0,
                                    padx=2,
                                    bg=bg_color,
                                    fg=theme['fg'])
            edit_button.pack(side=tk.LEFT)

            delete_button = tk.Button(icons_frame, text="üóëÔ∏è", 
                                    command=lambda i=item['id']: self.remove_item_from_group(group_id, i, self.items_frame),
                                    font=('Segoe UI', 10), bd=0,
                                    padx=2,
                                    bg=bg_color,
                                    fg=theme['fg'])
            delete_button.pack(side=tk.LEFT)

        # Actualizar el scrollregion despu√©s de a√±adir todos los widgets
        self.items_frame.update_idletasks()
        self.canvas.config(scrollregion=self.canvas.bbox("all"))
        
    def remove_item_from_group(self, group_id, item_id, items_frame):
        self.clipboard_manager.group_manager.groups[group_id]['items'] = [item for item in self.clipboard_manager.group_manager.groups[group_id]['items'] if item['id'] != item_id]
        self.clipboard_manager.group_manager.save_groups()
        self.refresh_group_content(group_id)

    def edit_group_item(self, group_id, item_id):
        item = next((item for item in self.clipboard_manager.group_manager.groups[group_id]['items'] if item['id'] == item_id), None)
        if not item:
            return

        dialog = tk.Toplevel(self.master)
        dialog.title("Editar Item")
        
        # Calcula la posici√≥n relativa a la ventana principal
        x = self.clipboard_manager.window_x + 40
        y = self.clipboard_manager.window_y + 40
        
        # Calcular la altura inicial basada en el contenido
        text_lines = item['text'].count('\n') + 1
        initial_height = min(150 + (text_lines * 20), 600)  # 20 p√≠xeles por l√≠nea, m√°ximo 600
        
        dialog.geometry(f"300x{initial_height}+{x}+{y}")
        
        dialog.configure(bg=self.theme_manager.colors['dark']['bg'])
        dialog.overrideredirect(True)
        dialog.attributes('-topmost', True)

        # Barra de t√≠tulo personalizada
        title_frame = tk.Frame(dialog, bg=self.theme_manager.colors['dark']['bg'])
        title_frame.pack(fill=tk.X, padx=4, pady=(4, 0))

        title_label = tk.Label(title_frame, text="Editar Item", font=('Segoe UI', 10, 'bold'),
                            bg=self.theme_manager.colors['dark']['bg'],
                            fg=self.theme_manager.colors['dark']['fg'])
        title_label.pack(side=tk.LEFT, padx=0)

        close_button = tk.Button(title_frame, text="‚ùå", command=dialog.destroy,
                                font=('Segoe UI', 10, 'bold'), bd=0, padx=0,
                                bg=self.theme_manager.colors['dark']['button_bg'],
                                fg=self.theme_manager.colors['dark']['button_fg'])
        close_button.pack(side=tk.RIGHT)
        
        # Contenido
        content_frame = tk.Frame(dialog, bg=self.theme_manager.colors['dark']['bg'])
        content_frame.pack(fill=tk.BOTH, expand=True, padx=4, pady=0)

        name_label = tk.Label(content_frame, text="Nombre del item:",
                            bg=self.theme_manager.colors['dark']['bg'],
                            fg=self.theme_manager.colors['dark']['fg'])
        name_label.pack(anchor='w', pady=(0, 5))

        name_entry = tk.Entry(content_frame, bg=self.theme_manager.colors['dark']['button_bg'],
                            fg=self.theme_manager.colors['dark']['fg'],
                            insertbackground=self.theme_manager.colors['dark']['fg'],
                            font=('Segoe UI', 10))
        name_entry.insert(0, item.get('name', ''))
        name_entry.pack(fill=tk.X, pady=(0, 5))

        text_label = tk.Label(content_frame, text="Texto del item:",
                            bg=self.theme_manager.colors['dark']['bg'],
                            fg=self.theme_manager.colors['dark']['fg'])
        text_label.pack(anchor='w', pady=(0, 5))

        text_entry = tk.Text(content_frame, height=3, bg=self.theme_manager.colors['dark']['button_bg'],
                            fg=self.theme_manager.colors['dark']['fg'],
                            insertbackground=self.theme_manager.colors['dark']['fg'],
                            font=('Segoe UI', 10))
        text_entry.insert(tk.END, item['text'])
        text_entry.pack(fill=tk.BOTH, expand=True, pady=(0, 5))

        def save_item():
            new_name = name_entry.get().strip()
            new_text = text_entry.get("1.0", tk.END).strip()
            if new_text:
                item['name'] = new_name
                item['text'] = new_text
                self.clipboard_manager.group_manager.save_groups()
                dialog.destroy()
                self.refresh_group_content(group_id)

        save_button = tk.Button(content_frame, text="Guardar", command=save_item,
                                bg=self.theme_manager.colors['dark']['button_bg'],
                                fg=self.theme_manager.colors['dark']['button_fg'])
        save_button.pack(fill=tk.X, pady=(0, 5))

        # Hacer la ventana arrastrable
        def start_move(event):
            dialog.x = event.x
            dialog.y = event.y

        def on_move(event):
            deltax = event.x - dialog.x
            deltay = event.y - dialog.y
            x = dialog.winfo_x() + deltax
            y = dialog.winfo_y() + deltay
            dialog.geometry(f"+{x}+{y}")

        title_frame.bind('<Button-1>', start_move)
        title_frame.bind('<B1-Motion>', on_move)

        # Funci√≥n para ajustar din√°micamente la altura de la ventana
        def adjust_dialog_height(event=None):
            content = text_entry.get("1.0", tk.END)
            lines = content.count('\n') + 1
            new_height = min(150 + (lines * 20), 600)  # 100 p√≠xeles base + 20 por l√≠nea, m√°ximo 600
            dialog.geometry(f"300x{new_height}")

        # Vincular la funci√≥n de ajuste al evento de cambio en el texto
        text_entry.bind("<KeyRelease>", adjust_dialog_height)

        dialog.focus_set()
        name_entry.focus()

        # Ajustar la altura inicial
        adjust_dialog_height()

// Archivo: group_manager.py
# group_manager.py

import tkinter as tk
from tkinter import ttk, simpledialog, messagebox
import uuid
from settings_manager import SettingsManager
from group_content_manager import GroupContentManager


class GroupManager:
    def __init__(self, master, clipboard_manager):
        self.master = master
        self.clipboard_manager = clipboard_manager
        self.data_manager = clipboard_manager.data_manager
        self.theme_manager = clipboard_manager.theme_manager
        self.settings = clipboard_manager.settings
        self.settings_manager = clipboard_manager.settings_manager
        self.groups, _, _ = self.data_manager.load_data()
        self.groups_window = None
        self.groups_frame = None
        self.group_content_manager = GroupContentManager(master, clipboard_manager, clipboard_manager.theme_manager, clipboard_manager.settings_manager)

    def show_group_content(self, group_id):
        self.group_content_manager.show_group_content(group_id)

    def show_groups_window(self):
        if self.groups_window is None or not self.groups_window.winfo_exists():
            self.groups_window = tk.Toplevel(self.master)
            self.groups_window.title("Grupos")
            
            window_width = self.settings['width']
            window_height = self.settings['height']
            # self.groups_window.geometry(f"{window_width}x{window_height}+0+0")
            
             # Calcula la posici√≥n relativa a la ventana principal
            x = self.clipboard_manager.window_x + 10
            y = self.clipboard_manager.window_y + 10
            
            self.groups_window.geometry(f"{window_width}x{window_height}+{x}+{y}")
            
            self.groups_window.overrideredirect(True) # Oculta la barra de t√≠tulo
            
            self.groups_window.configure(bg=self.theme_manager.colors['dark']['bg'])
            self.groups_window.attributes('-topmost', True) # Hacer que la ventana est√© siempre en primer plano
            self.master.bind("<Destroy>", self.on_main_window_close) # Vincular el cierre de la ventana principal al cierre de la ventana de grupos

            # Barra de t√≠tulo personalizada
            title_frame = tk.Frame(self.groups_window, bg=self.theme_manager.colors['dark']['bg'])
            title_frame.pack(fill=tk.X, padx=2, pady=(0, 0))

            title_label = tk.Label(title_frame, text="Grupos", font=('Segoe UI', 10, 'bold'), 
                                   bg=self.theme_manager.colors['dark']['bg'], 
                                   fg=self.theme_manager.colors['dark']['fg'])
            title_label.pack(side=tk.LEFT, padx=5)

            # Botones en la barra de t√≠tulo
            buttons_frame = tk.Frame(title_frame, bg=self.theme_manager.colors['dark']['bg'])
            buttons_frame.pack(side=tk.RIGHT, padx=4)

            add_button = tk.Button(buttons_frame, text="‚ûï", command=self.add_group, 
                                   font=('Segoe UI', 10), bd=0, padx=10, width=5, height=2,
                                   bg=self.theme_manager.colors['dark']['button_bg'],
                                   fg=self.theme_manager.colors['dark']['button_fg'])
            add_button.pack(side=tk.LEFT)

            close_button = tk.Button(buttons_frame, text="‚ùå", command=self.groups_window.destroy, 
                                     font=('Segoe UI', 10, 'bold'), bd=0, padx=10, width=5, height=2,
                                     bg=self.theme_manager.colors['dark']['button_bg'],
                                     fg=self.theme_manager.colors['dark']['button_fg'])
            close_button.pack(side=tk.LEFT)

            # # Marco para la lista de grupos
            # self.groups_frame = tk.Frame(self.groups_window, bg=self.theme_manager.colors['dark']['bg'])
            # self.groups_frame.pack(fill=tk.BOTH, expand=True, padx=2, pady=2)

            # # Hacer la ventana arrastrable
            # title_label.bind('<Button-1>', self.start_move)
            # title_label.bind('<B1-Motion>', self.on_move)
            
            # Canvas para scroll y contenedor de grupos
            canvas = tk.Canvas(self.groups_window, bg=self.theme_manager.colors['dark']['bg'], bd=0, highlightthickness=0)
            canvas.pack(fill=tk.BOTH, expand=True, padx=2, pady=2)

            # Scrollbar oculto
            scrollbar = ttk.Scrollbar(self.groups_window, orient=tk.VERTICAL, command=canvas.yview)
            canvas.configure(yscrollcommand=scrollbar.set)

            # Frame contenedor dentro del canvas para el scroll
            self.groups_frame = tk.Frame(canvas, bg=self.theme_manager.colors['dark']['bg'])
            canvas_window = canvas.create_window((0, 0), window=self.groups_frame, anchor='nw', width=295)

            # Ajustar el ancho del frame contenedor al canvas
            def on_canvas_resize(event):
                canvas.itemconfig(canvas_window, width=event.width)

            canvas.bind("<Configure>", on_canvas_resize)

            # Configuraci√≥n de scroll
            def on_frame_configure(event):
                canvas.configure(scrollregion=canvas.bbox("all"))

            self.groups_frame.bind("<Configure>", on_frame_configure)

            # Funci√≥n para desplazamiento con la rueda del mouse
            def _on_mousewheel(event):
                canvas.yview_scroll(int(-1*(event.delta/120)), "units")

            canvas.bind_all("<MouseWheel>", _on_mousewheel)

            # Hacer la ventana arrastrable
            title_label.bind('<Button-1>', self.start_move)
            title_label.bind('<B1-Motion>', self.on_move)

            self.refresh_groups()

        # Si la ventana de grupos ya estaba abierta, llevarla al frente
        else:
            self.groups_window.lift()
            self.groups_window.attributes('-topmost', True)
            self.groups_window.after_idle(self.groups_window.attributes, '-topmost', False)
        
    def start_move(self, event):
        self.x = event.x
        self.y = event.y

    def on_move(self, event):
        deltax = event.x - self.x
        deltay = event.y - self.y
        x = self.groups_window.winfo_x() + deltax
        y = self.groups_window.winfo_y() + deltay
        self.groups_window.geometry(f"+{x}+{y}")

    def refresh_groups(self):
        if self.groups_frame is None or not self.groups_frame.winfo_exists():
            return

        for widget in self.groups_frame.winfo_children():
            widget.destroy()

        for group_id, group_info in self.groups.items():
            group_card = tk.Frame(self.groups_frame, bg=self.theme_manager.colors['dark']['card_bg'], cursor="hand2")
            group_card.pack(fill=tk.X, padx=4, pady=2)
            
            group_card.bind("<Button-1>", lambda e, gid=group_id: self.show_group_content(gid))

            name_label = tk.Label(group_card, text=group_info['name'], font=("Segoe UI", 10, "bold"),
                                bg=self.theme_manager.colors['dark']['card_bg'],
                                fg=self.theme_manager.colors['dark']['fg'])
            name_label.pack(side=tk.LEFT, padx=5, pady=5)

            count_label = tk.Label(group_card, text=f"Items: {len(group_info['items'])}",
                                bg=self.theme_manager.colors['dark']['card_bg'],
                                fg=self.theme_manager.colors['dark']['fg'])
            count_label.pack(side=tk.LEFT, padx=5, pady=5)
            
            delete_button = tk.Button(group_card, text="    üóëÔ∏è", command=lambda gid=group_id: self.delete_group(gid),
                                    font=('Segoe UI', 10), bd=0, bg=self.theme_manager.colors['dark']['button_bg'],
                                    fg=self.theme_manager.colors['dark']['button_fg'])
            delete_button.pack(side=tk.RIGHT, padx=2, pady=5)

            edit_button = tk.Button(group_card, text="‚úèÔ∏è", command=lambda gid=group_id: self.edit_group(gid),
                                    font=('Segoe UI', 10), bd=0, bg=self.theme_manager.colors['dark']['button_bg'],
                                    fg=self.theme_manager.colors['dark']['button_fg'])
            edit_button.pack(side=tk.RIGHT, padx=2, pady=5)

            
            
    def save_groups(self):
        pinned_items = {k: v for k, v in self.clipboard_manager.clipboard_items.items() if v['pinned']}
        # Aseg√∫rate de que cada item pinned tenga la estructura correcta
        for item_id, item_data in pinned_items.items():
            if isinstance(item_data['text'], str):
                pinned_items[item_id]['text'] = {'text': item_data['text'], 'formatted': {}}
            elif not isinstance(item_data['text'], dict):
                pinned_items[item_id]['text'] = {'text': str(item_data['text']), 'formatted': {}}
        
        self.data_manager.save_data(self.groups, pinned_items, self.clipboard_manager.settings)
        print("Groups and pinned items saved")
        
    def edit_group(self, group_id):
        self.show_edit_group_dialog(group_id)

    def delete_group(self, group_id):
        # if tk.messagebox.askyesno("Eliminar Grupo", "¬øEst√° seguro de que desea eliminar este grupo?"):
        del self.groups[group_id]
        self.refresh_groups()
        self.save_groups()

    def add_item_to_group(self, item_id, group_id):
        if group_id in self.groups:
            item_data = self.clipboard_manager.clipboard_items.get(item_id)
            if item_data and item_id not in [item['id'] for item in self.groups[group_id]['items']]:
                self.groups[group_id]['items'].append({
                    'id': item_id,
                    'text': item_data['text']
                })
                self.save_groups()
                if self.groups_window and self.groups_window.winfo_exists():
                    self.refresh_groups()
                print(f"Item {item_id} added to group {group_id}")
                
                # Actualizar la vista principal si es necesario
                if hasattr(self.clipboard_manager, 'refresh_cards'):
                    self.clipboard_manager.refresh_cards()
            else:
                print(f"Item {item_id} already in group {group_id} or not found")
        else:
            print(f"Group {group_id} not found")
            
    def on_main_window_close(self, event):
        if self.groups_window and self.groups_window.winfo_exists():
            self.groups_window.destroy()
            
    # ----------------------------------------------------------------------
   
    
    
    def add_group(self):
        dialog = tk.Toplevel(self.master)
        dialog.title("Nuevo Grupo")
        dialog.geometry("200x115")
        
        # Calcula la posici√≥n relativa a la ventana principal
        x = self.clipboard_manager.window_x + 40
        y = self.clipboard_manager.window_y + 40
        
        dialog.geometry(f"+{x}+{y}")
        
        dialog.configure(bg=self.theme_manager.colors['dark']['bg'])
        dialog.overrideredirect(True)
        dialog.attributes('-topmost', True)

        # Barra de t√≠tulo personalizada
        title_frame = tk.Frame(dialog, bg=self.theme_manager.colors['dark']['bg'])
        title_frame.pack(fill=tk.X, padx=4, pady=(4, 0))

        title_label = tk.Label(title_frame, text="Nuevo Grupo", font=('Segoe UI', 10, 'bold'),
                            bg=self.theme_manager.colors['dark']['bg'],
                            fg=self.theme_manager.colors['dark']['fg'])
        title_label.pack(side=tk.LEFT, padx=0)

        close_button = tk.Button(title_frame, text="‚ùå", command=dialog.destroy,
                                font=('Segoe UI', 10, 'bold'), bd=0, padx=0,
                                bg=self.theme_manager.colors['dark']['button_bg'],
                                fg=self.theme_manager.colors['dark']['button_fg'])
        close_button.pack(side=tk.RIGHT)

        # Contenido
        content_frame = tk.Frame(dialog, bg=self.theme_manager.colors['dark']['bg'])
        content_frame.pack(fill=tk.BOTH, expand=True, padx=4, pady=0)

        name_label = tk.Label(content_frame, text="Nombre del grupo:",
                            bg=self.theme_manager.colors['dark']['bg'],
                            fg=self.theme_manager.colors['dark']['fg'])
        name_label.pack(anchor='w', pady=(0, 5))

        name_entry = tk.Entry(content_frame, bg=self.theme_manager.colors['dark']['button_bg'],
                            fg=self.theme_manager.colors['dark']['fg'],
                            insertbackground=self.theme_manager.colors['dark']['fg'],
                            relief=tk.FLAT,  # Quita el efecto 3D
                            bd=0,  # Quita el borde
                            highlightthickness=1,  # A√±ade un borde fino
                            highlightcolor=self.theme_manager.colors['dark'].get('highlight', '#555555'),  # Color del borde cuando tiene foco
                            highlightbackground=self.theme_manager.colors['dark'].get('border', '#333333'))  # Color del borde cuando no tiene foco
        name_entry.pack(fill=tk.X, pady=(0, 0))

        def save_group():
            name = name_entry.get().strip()
            if name:
                group_id = str(uuid.uuid4())
                self.groups[group_id] = {'name': name, 'items': []}
                self.refresh_groups()
                self.save_groups()
                dialog.destroy()

        save_button = tk.Button(content_frame, text="Guardar", command=save_group,
                                bg=self.theme_manager.colors['dark']['button_bg'],
                                fg=self.theme_manager.colors['dark']['button_fg'],
                                activebackground=self.theme_manager.colors['dark'].get('active_bg', '#4E4E4E'),
                                activeforeground=self.theme_manager.colors['dark'].get('active_fg', '#FFFFFF'),
                                relief=tk.FLAT,  # Elimina el estilo 3D
                                bd=0,  # Elimina el borde
                                padx=4, pady=5)
        save_button.pack(fill=tk.X, expand=True, pady=(0, 0))

        # Hacer la ventana arrastrable
        def start_move(event):
            dialog.x = event.x
            dialog.y = event.y

        def on_move(event):
            deltax = event.x - dialog.x
            deltay = event.y - dialog.y
            x = dialog.winfo_x() + deltax
            y = dialog.winfo_y() + deltay
            dialog.geometry(f"+{x}+{y}")

        title_frame.bind('<Button-1>', start_move)
        title_frame.bind('<B1-Motion>', on_move)

        # Centrar el di√°logo en la pantalla
        dialog.update_idletasks()
        width = dialog.winfo_width()
        height = dialog.winfo_height()
        x = (dialog.winfo_screenwidth() // 2) - (width // 2)
        y = (dialog.winfo_screenheight() // 2) - (height // 2)
        dialog.geometry('{}x{}+{}+{}'.format(width, height, x, y))

        dialog.focus_set()
        name_entry.focus()
        
    # ----------------------------------------------------------------------------------
    
    def show_edit_group_dialog(self, group_id):
        dialog = tk.Toplevel(self.master)
        dialog.title("Editar Grupo")
        # dialog.geometry("200x115")
        
        # Calcula la posici√≥n relativa a la ventana principal
        x = self.clipboard_manager.window_x + 40
        y = self.clipboard_manager.window_y + 40
        
        dialog.geometry(f"200x115+{x}+{y}")
        
        dialog.configure(bg=self.theme_manager.colors['dark']['bg'])
        dialog.overrideredirect(True)
        dialog.attributes('-topmost', True)

        # Barra de t√≠tulo personalizada
        title_frame = tk.Frame(dialog, bg=self.theme_manager.colors['dark']['bg'])
        title_frame.pack(fill=tk.X, padx=4, pady=(4, 0))

        title_label = tk.Label(title_frame, text="Editar Grupo", font=('Segoe UI', 10, 'bold'),
                            bg=self.theme_manager.colors['dark']['bg'],
                            fg=self.theme_manager.colors['dark']['fg'])
        title_label.pack(side=tk.LEFT, padx=0)

        close_button = tk.Button(title_frame, text="‚ùå", command=dialog.destroy,
                                font=('Segoe UI', 10, 'bold'), bd=0, padx=0,
                                bg=self.theme_manager.colors['dark']['button_bg'],
                                fg=self.theme_manager.colors['dark']['button_fg'])
        close_button.pack(side=tk.RIGHT)

        # Contenido
        content_frame = tk.Frame(dialog, bg=self.theme_manager.colors['dark']['bg'])
        content_frame.pack(fill=tk.BOTH, expand=True, padx=4, pady=0)

        name_label = tk.Label(content_frame, text="Nuevo nombre del grupo:",
                            bg=self.theme_manager.colors['dark']['bg'],
                            fg=self.theme_manager.colors['dark']['fg'])
        name_label.pack(anchor='w', pady=(0, 5))

        name_entry = tk.Entry(content_frame, bg=self.theme_manager.colors['dark']['button_bg'],
                            fg=self.theme_manager.colors['dark']['fg'],
                            insertbackground=self.theme_manager.colors['dark']['fg'],
                            relief=tk.FLAT,  # Quita el efecto 3D
                            bd=0,  # Quita el borde
                            highlightthickness=1,  # A√±ade un borde fino
                            highlightcolor=self.theme_manager.colors['dark'].get('highlight', '#555555'),  # Color del borde cuando tiene foco
                            highlightbackground=self.theme_manager.colors['dark'].get('border', '#333333'))  # Color del borde cuando no tiene foco
        name_entry.insert(0, self.groups[group_id]['name'])
        name_entry.pack(fill=tk.X, pady=(0, 0))

        def save_group():
            new_name = name_entry.get().strip()
            if new_name:
                self.groups[group_id]['name'] = new_name
                self.refresh_groups()
                self.save_groups()
                dialog.destroy()

        save_button = tk.Button(content_frame, text="Guardar", command=save_group,
                                bg=self.theme_manager.colors['dark']['button_bg'],
                                fg=self.theme_manager.colors['dark']['button_fg'],
                                activebackground=self.theme_manager.colors['dark'].get('active_bg', '#4E4E4E'),
                                activeforeground=self.theme_manager.colors['dark'].get('active_fg', '#FFFFFF'),
                                relief=tk.FLAT,  # Elimina el estilo 3D
                                bd=0,  # Elimina el borde
                                padx=4, pady=5)
        save_button.pack(fill=tk.X, expand=True, pady=(0, 0))  # Hace que el bot√≥n ocupe todo el ancho disponible

        # Hacer la ventana arrastrable
        def start_move(event):
            dialog.x = event.x
            dialog.y = event.y

        def on_move(event):
            deltax = event.x - dialog.x
            deltay = event.y - dialog.y
            x = dialog.winfo_x() + deltax
            y = dialog.winfo_y() + deltay
            dialog.geometry(f"+{x}+{y}")

        title_frame.bind('<Button-1>', start_move)
        title_frame.bind('<B1-Motion>', on_move)

        # Centrar el di√°logo en la pantalla
        dialog.update_idletasks()
        width = dialog.winfo_width()
        height = dialog.winfo_height()
        x = (dialog.winfo_screenwidth() // 2) - (width // 2)
        y = (dialog.winfo_screenheight() // 2) - (height // 2)
        dialog.geometry('{}x{}+{}+{}'.format(width, height, x, y))

        dialog.focus_set()
        name_entry.focus()

// Archivo: key_manager.py
# key_manager.py
import win32com
import win32clipboard
import keyboard
import win32gui
import win32com.client
import pyperclip
import time
import pyautogui
import win32api
import win32con
import ctypes
import re
from bs4 import BeautifulSoup

# Definir CF_HTML ya que no est√° en win32con
CF_HTML = win32clipboard.RegisterClipboardFormat("HTML Format")

class KeyManager:
    def __init__(self, manager):
        self.manager = manager
        self.hotkey = self.manager.hotkey
        self.current_hotkey = None
        self.update_hotkey(None, self.hotkey)
        self.original_cursor_pos = None

    def update_hotkey(self, old_hotkey, new_hotkey):
        if old_hotkey:
            try:
                keyboard.remove_hotkey(old_hotkey)
            except KeyError:
                print(f"No se pudo eliminar el atajo anterior: {old_hotkey}")

        if not new_hotkey.lower().startswith('alt+'):
            new_hotkey = 'alt+' + new_hotkey
        
        keyboard.add_hotkey(new_hotkey, self.toggle_window)
        self.current_hotkey = new_hotkey
        print(f"Nuevo atajo configurado: {new_hotkey}")

    def toggle_window(self):
        print("Toggling window")
        if not self.manager.is_visible:
            print("Showing window")
            self.original_cursor_pos = win32gui.GetCursorPos()
            self.show_window()
        else:
            print("Hiding window")
            self.hide_window()

    def hide_window(self):
        self.manager.root.withdraw()
        self.manager.is_visible = False
        self.restore_focus()
        if self.original_cursor_pos:
            win32api.SetCursorPos(self.original_cursor_pos)
        self.setup_global_keys()

    def show_window(self):
        print("In show_window function")
        try:
            self.manager.previous_window = win32gui.GetForegroundWindow()
            # Obtener la posici√≥n actual del cursor
            mouse_x, mouse_y = pyautogui.position()
            
            # Calcular la posici√≥n de la ventana
            window_x = mouse_x - self.manager.window_width // 2
            window_y = mouse_y - self.manager.window_height // 2
            
            # Asegurar que la ventana no se salga de la pantalla
            screen_width, screen_height = pyautogui.size()
            window_x = max(0, min(window_x, screen_width - self.manager.window_width))
            window_y = max(0, min(window_y, screen_height - self.manager.window_height))
            
            self.manager.root.geometry(f"{self.manager.window_width}x{self.manager.window_height}+{window_x}+{window_y}")
            self.manager.window_x = window_x  # Guarda la posici√≥n x de la ventana
            self.manager.window_y = window_y  # Guarda la posici√≥n y de la ventana
            
            self.manager.root.deiconify()
            self.manager.root.lift()
            self.manager.root.attributes('-topmost', True)
            self.manager.is_visible = True
            self.manager.navigation.initialize_focus()
            self.setup_global_keys()
            
            # Actualizar la regi√≥n de desplazamiento del canvas
            self.manager.canvas.update_idletasks()
            self.manager.canvas.configure(scrollregion=self.manager.canvas.bbox("all"))
            
            self.manager.root.update_idletasks()
            self.manager.root.after(100, lambda: self.manager.root.attributes('-topmost', False))
            self.manager.root.focus_force()
            
        except Exception as e:
            print(f"Error al mostrar la ventana: {e}")

    def restore_focus(self):
        if self.manager.previous_window:
            try:
                win32gui.SetForegroundWindow(self.manager.previous_window)
            except Exception as e:
                print(f"Error al restaurar el foco: {e}")
                try:
                    self.manager.root.after(100, lambda: win32gui.SetForegroundWindow(self.manager.previous_window))
                except:
                    pass

    def setup_global_keys(self):
        keyboard.unhook_all()
        keyboard.add_hotkey(self.current_hotkey, self.toggle_window)
        keyboard.add_hotkey('up', lambda: self.handle_global_key('Up'))
        keyboard.add_hotkey('down', lambda: self.handle_global_key('Down'))
        keyboard.add_hotkey('left', lambda: self.handle_global_key('Left'))
        keyboard.add_hotkey('right', lambda: self.handle_global_key('Right'))
        keyboard.add_hotkey('enter', lambda: self.handle_global_key('Return'))

    def handle_global_key(self, key):
        if self.manager.is_visible:
            print(f"Handling global key: {key}")
            if key in ['Up', 'Down']:
                self.manager.navigation.navigate_vertical(type('Event', (), {'keysym': key})())
            elif key in ['Left', 'Right']:
                self.manager.navigation.navigate_horizontal(type('Event', (), {'keysym': key})())
            elif key == 'Return':
                self.manager.navigation.activate_selected()
            
            self.manager.root.update_idletasks()
            self.manager.root.after(10, self.manager.root.update)
            self.manager.root.after(20, self.restore_cursor_position)

    def restore_cursor_position(self):
        if self.original_cursor_pos:
            win32api.SetCursorPos(self.original_cursor_pos)

    def paste_content(self, clipboard_data):
        try:
            self.hide_window()
            current_cursor_pos = win32gui.GetCursorPos()
            
            if isinstance(clipboard_data, dict):
                text = clipboard_data.get('text', '')
                format_info = clipboard_data.get('formatted', {})
            else:
                text = str(clipboard_data)
                format_info = {}

            if self.manager.paste_with_format and format_info:
                formatted_content = self.apply_format_to_text(text, format_info)
                win32clipboard.OpenClipboard()
                win32clipboard.EmptyClipboard()
                win32clipboard.SetClipboardData(win32con.CF_UNICODETEXT, formatted_content)
                win32clipboard.CloseClipboard()
            else:
                pyperclip.copy(text)
            
            time.sleep(0.05)
            
            if self.manager.previous_window:
                win32gui.SetForegroundWindow(self.manager.previous_window)
                time.sleep(0.05)
                
                win32api.SetCursorPos(current_cursor_pos)
                
                shell = win32com.client.Dispatch("WScript.Shell")
                shell.SendKeys("^v")
            
            self.original_cursor_pos = None
            
        except Exception as e:
            print(f"Error en el proceso de pegado: {e}")
        finally:
            if self.original_cursor_pos:
                win32api.SetCursorPos(self.original_cursor_pos)
            self.original_cursor_pos = None

    def apply_format_to_text(self, text, format_info):
        if 'rtf' in format_info:
            return self.apply_rtf_format(text, format_info)
        elif 'html' in format_info:
            return self.apply_html_format(text, format_info)
        else:
            return text

    def apply_rtf_format(self, text, format_info):
        rtf = r"{\rtf1\ansi\deff0"
        if format_info.get('font'):
            rtf += r"{\fonttbl{\f0\fnil " + format_info['font'] + r";}}"
        if format_info.get('color'):
            rtf += r"{\colortbl;\red" + str(format_info['color'][0]) + r"\green" + str(format_info['color'][1]) + r"\blue" + str(format_info['color'][2]) + r";}"
        rtf += r"\f0"
        if format_info.get('size'):
            rtf += r"\fs" + str(int(format_info['size'] * 2))
        if format_info.get('bold'):
            rtf += r"\b"
        if format_info.get('italic'):
            rtf += r"\i"
        rtf += " " + text.replace("\n", r"\par ") + r"}"
        return rtf

    def apply_html_format(self, text, format_info):
        html = "<div style='"
        if format_info.get('font'):
            html += f"font-family: {format_info['font']}; "
        if format_info.get('size'):
            html += f"font-size: {format_info['size']}pt; "
        if format_info.get('color'):
            html += f"color: rgb{format_info['color']}; "
        html += "'>"
        if format_info.get('bold'):
            html += "<strong>"
        if format_info.get('italic'):
            html += "<em>"
        html += text
        if format_info.get('italic'):
            html += "</em>"
        if format_info.get('bold'):
            html += "</strong>"
        html += "</div>"
        return html

// Archivo: main.py
# main.py
import keyboard
import sys
import tkinter as tk
from structure import ClipboardManager

def main():
    root = tk.Tk()
    show_settings = "--show-settings" in sys.argv
    app = ClipboardManager(root, show_settings)
    # Aplicar las configuraciones iniciales
    root.geometry(f"{app.settings_manager.settings['width']}x{app.settings_manager.settings['height']}+0+0")
    
    # if show_settings:
    #     root.after(100, app.settings_manager.show_settings_window)
    
    # Configurar el atajo de teclado global
    keyboard.add_hotkey(app.hotkey, app.key_manager.toggle_window)
    
    root.mainloop()

if __name__ == "__main__":
    main()

// Archivo: main_screen_navigation.py
# main_screen_navigation.py

import tkinter as tk

class MainScreenNavigation:
    def __init__(self, manager):
        self.manager = manager
        self.navigation_order = ['top_buttons', 'main_buttons', 'cards']   

    def navigate_vertical(self, event):
        print(f"MainScreenNavigation: Navigating vertically {event.keysym}")
        current_type = self.manager.current_selection['type']
        current_index = self.manager.current_selection['index']
        print(f"Before navigation: type={current_type}, index={current_index}")
        
        if event.keysym == 'Up':
            self.move_up(current_type, current_index)
        elif event.keysym == 'Down':
            self.move_down(current_type, current_index)

        self.update_highlights()
        self.ensure_visible()
        print(f"After navigation: type={self.manager.current_selection['type']}, index={self.manager.current_selection['index']}")
        self.update_highlights()

    def move_up(self, current_type, current_index):
        if current_type in ['cards', 'icons']:
            if current_index > 0:
                self.manager.current_selection['index'] = current_index - 1
            else:
                self.manager.current_selection = {'type': 'main_buttons', 'index': 0}
        elif current_type == 'main_buttons':
            self.manager.current_selection = {'type': 'top_buttons', 'index': 0}
        elif current_type == 'top_buttons':
            # Si ya estamos en los botones superiores, no hacemos nada
            pass
        print(f"After move_up: {self.manager.current_selection}")
        
    def move_down(self, current_type, current_index):
        if current_type == 'top_buttons':
            self.manager.current_selection = {'type': 'main_buttons', 'index': 0}
        elif current_type == 'main_buttons':
            if self.get_cards_count() > 0:
                self.manager.current_selection = {'type': 'cards', 'index': 0}
        elif current_type == 'cards':
            if current_index < self.get_cards_count() - 1:
                self.manager.current_selection['index'] = current_index + 1
        print(f"After move_down: {self.manager.current_selection}")
        
    def navigate_horizontal(self, event):
        print(f"MainScreenNavigation: Navigating horizontally {event.keysym}")  
        current_type = self.manager.current_selection['type']
        current_index = self.manager.current_selection['index']

        if event.keysym == 'Left':
            self.move_left(current_type, current_index)
        elif event.keysym == 'Right':
            self.move_right(current_type, current_index)

        self.update_highlights()

    def move_left(self, current_type, current_index):
        if current_type in ['top_buttons', 'main_buttons']:
            self.manager.current_selection['index'] = (current_index - 1) % self.get_button_count(current_type)
        elif current_type == 'icons':
            if current_index % 3 > 0:
                self.manager.current_selection['index'] = current_index - 1
            else:
                self.manager.current_selection = {'type': 'cards', 'index': current_index // 3}

    def move_right(self, current_type, current_index):
        if current_type in ['top_buttons', 'main_buttons']:
            self.manager.current_selection['index'] = (current_index + 1) % self.get_button_count(current_type)
        elif current_type == 'cards':
            self.manager.current_selection = {'type': 'icons', 'index': current_index * 3}
        elif current_type == 'icons':
            if current_index % 3 < 2:
                self.manager.current_selection['index'] = current_index + 1

    def activate_selected(self, event=None):
        current_type = self.manager.current_selection['type']
        current_index = self.manager.current_selection['index']

        if current_type == 'main_buttons':
            self.activate_main_button(current_index)
        elif current_type == 'top_buttons':
            self.activate_top_button(current_index)
        elif current_type == 'cards':
            self.activate_card(current_index)
        elif current_type == 'icons':
            self.activate_icon(current_index)

    def activate_main_button(self, index):
        if index == 0:  # Bot√≥n Grupos
            self.manager.show_groups()
        elif index == 1:  # Bot√≥n Pegar (con/sin formato)
            self.manager.functions.toggle_paste_format()
        elif index == 2:  # Bot√≥n Borrar Todo
            self.manager.functions.clear_history()

    def activate_top_button(self, index):
        if index == 0:  # Bot√≥n Cambiar tema
            self.manager.theme_manager.toggle_theme()
        elif index == 1:  # Bot√≥n Configuraci√≥n
            self.manager.show_settings()
        elif index == 2:  # Bot√≥n Cerrar app
            self.manager.functions.exit_app()

    def activate_card(self, index):
        items = list(self.manager.clipboard_items.items())
        if index < len(items):
            item_id, item_data = items[index]
            clipboard_data = item_data['text']
            self.manager.key_manager.paste_content(clipboard_data)

    def activate_icon(self, index):
        items = list(self.manager.clipboard_items.keys())
        card_index = index // 3
        icon_position = index % 3
        
        if card_index < len(items):
            item_id = items[card_index]
            if icon_position == 0:  # Arrow
                self.manager.functions.on_arrow_click(item_id)
            elif icon_position == 1:  # Pin
                self.manager.functions.toggle_pin(item_id)
            elif icon_position == 2:  # Delete
                self.manager.functions.delete_item(item_id)

    def initialize_focus(self):
        if self.get_cards_count() > 0:
            self.manager.current_selection = {'type': 'cards', 'index': 0}
        else:
            self.manager.current_selection = {'type': 'main_buttons', 'index': 0}
        
        self.manager.root.focus_force()
        self.manager.root.update_idletasks()
        self.update_highlights()
    
    def update_highlights(self):
        print("Updating highlights")
        self.clear_all_highlights()
        
        current_type = self.manager.current_selection['type']
        current_index = self.manager.current_selection['index']
        
        highlight_color = '#444444' if self.manager.is_dark_mode else '#cccccc'
        icon_highlight_color = '#666666' if self.manager.is_dark_mode else '#aaaaaa'
        
        if current_type == 'main_buttons':
            buttons = [self.manager.button1, self.manager.button2, self.manager.button3]
            if 0 <= current_index < len(buttons):
                buttons[current_index].configure(bg=highlight_color)
        
        elif current_type == 'top_buttons':
            top_buttons = [self.manager.theme_button, self.manager.clear_button, self.manager.close_button]
            if 0 <= current_index < len(top_buttons):
                top_buttons[current_index].configure(bg=highlight_color)
        
        elif current_type == 'cards':
            cards = self.manager.cards_frame.winfo_children()
            if current_index < len(cards):
                self.highlight_entire_card(cards[current_index], highlight_color)
        
        elif current_type == 'icons':
            card_index = current_index // 3
            icon_position = current_index % 3
            cards = self.manager.cards_frame.winfo_children()
            
            if card_index < len(cards):
                card = cards[card_index]
                icons_frame = self.find_icons_frame(card)
                
                if icons_frame and icon_position < len(icons_frame.winfo_children()):
                    icons = icons_frame.winfo_children()
                    if 0 <= icon_position < len(icons):
                        self.highlight_entire_card(card, highlight_color)
                        icons[icon_position].configure(bg=icon_highlight_color)
                        
        print(f"Highlighted: {current_type}, index: {current_index}")
        self.manager.root.update_idletasks()
        self.manager.root.after(10, self.manager.root.update)

    def highlight_entire_card(self, card, color):
        card.configure(bg=color)
        for child in card.winfo_children():
            if isinstance(child, tk.Frame):
                child.configure(bg=color)
                for subchild in child.winfo_children():
                    if isinstance(subchild, (tk.Label, tk.Button)):
                        subchild.configure(bg=color)
            elif isinstance(child, (tk.Label, tk.Button)):
                child.configure(bg=color)

    def clear_all_highlights(self):
        theme = self.manager.theme_manager.colors['dark' if self.manager.is_dark_mode else 'light']
        base_color = theme['card_bg']
        button_color = theme['button_bg']
        
        buttons = [self.manager.button1, self.manager.button2, self.manager.button3,
                self.manager.theme_button, self.manager.clear_button, self.manager.close_button]
        for button in buttons:
            button.configure(bg=button_color)
        
        for card in self.manager.cards_frame.winfo_children():
            self.reset_card_colors(card, base_color, button_color)

    def reset_card_colors(self, card, base_color, button_color):
        card.configure(bg=base_color)
        for child in card.winfo_children():
            if isinstance(child, tk.Frame):
                child.configure(bg=base_color)
                for subchild in child.winfo_children():
                    if isinstance(subchild, tk.Label):
                        subchild.configure(bg=base_color)
                    elif isinstance(subchild, tk.Button):
                        subchild.configure(bg=button_color)
            elif isinstance(child, tk.Label):
                child.configure(bg=base_color)
            elif isinstance(child, tk.Button):
                child.configure(bg=button_color)

    def ensure_visible(self):
        current_type = self.manager.current_selection['type']
        current_index = self.manager.current_selection['index']
        
        if current_type == 'cards':
            cards = self.manager.cards_frame.winfo_children()
            if current_index < len(cards):
                widget = cards[current_index]
                bbox = self.manager.canvas.bbox("all")
                if bbox:
                    widget_y = widget.winfo_y()
                    canvas_height = self.manager.canvas.winfo_height()
                    if widget_y > 0:
                        self.manager.canvas.yview_moveto(widget_y / bbox[3])

    def get_cards_count(self):
        return len(self.manager.cards_frame.winfo_children())

    def get_button_count(self, button_type):
        if button_type == 'top_buttons':
            return 3  # Asumiendo que siempre hay 3 botones superiores
        elif button_type == 'main_buttons':
            return 3  # Asumiendo que siempre hay 3 botones principales

    def find_icons_frame(self, card):
        for child in card.winfo_children():
            if isinstance(child, tk.Frame) and child.winfo_children() and isinstance(child.winfo_children()[0], tk.Button):
                return child
        return None

// Archivo: navigation.py
# navigation.py

from main_screen_navigation import MainScreenNavigation
# from groups_screen_navigation import GroupsScreenNavigation
# from settings_screen_navigation import SettingsScreenNavigation

class Navigation:
    def __init__(self, manager):
        self.manager = manager
        self.strategies = {
            'main': MainScreenNavigation(manager),
            # 'groups': GroupsScreenNavigation(manager),
            # 'settings': SettingsScreenNavigation(manager)
        }
        self.current_strategy = self.strategies['main']

    def set_strategy(self, screen_type):
        if screen_type in self.strategies:
            self.current_strategy = self.strategies[screen_type]
            print(f"Estrategia de navegaci√≥n cambiada a: {screen_type}")
        else:
            print(f"Estrategia de navegaci√≥n no reconocida: {screen_type}")

    def navigate_vertical(self, event):
        print(f"Navigating vertically: {event.keysym}")  # A√±ade este print para depuraci√≥n
        self.current_strategy.navigate_vertical(event)

    def navigate_horizontal(self, event):
        print(f"Navigating horizontally: {event.keysym}")  # A√±ade este print para depuraci√≥n
        self.current_strategy.navigate_horizontal(event)

    def activate_selected(self, event=None):
        print("Activating selected")  # A√±ade este print para depuraci√≥n
        self.current_strategy.activate_selected(event)

    def update_highlights(self):
        self.current_strategy.update_highlights()


    def get_cards_count(self):
        return len(self.manager.cards_frame.winfo_children()) if hasattr(self.manager, 'cards_frame') else 0

    def initialize_focus(self):
        if self.get_cards_count() > 0:
            self.manager.current_selection = {'type': 'cards', 'index': 0}
        else:
            self.manager.current_selection = {'type': 'main_buttons', 'index': 0}
        
        self.update_highlights()
        self.manager.root.update_idletasks()

    def handle_focus(self, event=None):
        if self.manager.is_visible:
            self.manager.root.focus_force()

    def check_window_state(self):
        try:
            actual_visible = self.manager.root.winfo_viewable()
            if actual_visible != self.manager.is_visible:
                print('**********'f"Corrigiendo estado de visibilidad: {self.manager.is_visible} -> {actual_visible}")
                self.manager.is_visible = actual_visible
        except Exception as e:
            print(f"Error al verificar estado de la ventana: {e}")

    def update_active_window(self):
        import win32gui
        self.manager.last_active_window = win32gui.GetForegroundWindow()

    def get_current_selection(self):
        return self.manager.current_selection

    def set_current_selection(self, selection_type, index):
        self.manager.current_selection = {'type': selection_type, 'index': index}
        self.update_highlights()

    def get_clipboard_items(self):
        return self.manager.clipboard_items

    def get_cards_frame(self):
        return self.manager.cards_frame

    def get_canvas(self):
        return self.manager.canvas

    def is_dark_mode(self):
        return self.manager.is_dark_mode

    def get_theme_colors(self):
        return self.manager.theme_manager.colors

// Archivo: navigation_strategies.py
# navigation_strategies.py

from abc import ABC, abstractmethod

class NavigationStrategy(ABC):
    @abstractmethod
    def navigate_vertical(self, event):
        pass

    @abstractmethod
    def navigate_horizontal(self, event):
        pass

    @abstractmethod
    def activate_selected(self, event=None):
        pass

    @abstractmethod
    def update_highlights(self):
        pass

    @abstractmethod
    def initialize_focus(self):
        pass

# Nota: Las implementaciones concretas de MainScreenNavigation, GroupsScreenNavigation,
# y SettingsScreenNavigation ahora est√°n en archivos separados.

// Archivo: settings_manager.py
# settings_manager.py

import json
import os
import sys
import tkinter as tk
from tkinter import ttk

class SettingsManager:
    def __init__(self, master, clipboard_manager):
        self.master = master
        self.clipboard_manager = clipboard_manager
        self.settings_window = None
        self.settings = None      
          
    def initialize_settings(self):
        # Llama a este m√©todo despu√©s de que ClipboardManager haya inicializado completamente
        self.settings = self.clipboard_manager.settings
        
    def save_settings(self):
        groups, pinned_items, _ = self.clipboard_manager.data_manager.load_data()
        self.clipboard_manager.data_manager.save_data(groups, pinned_items, self.settings)
        
    def show_settings_window(self):
        if self.settings_window is None or not self.settings_window.winfo_exists():
            self.settings_window = tk.Toplevel(self.master)
            self.settings_window.title("Configuraciones")
            
            window_width = self.settings['width']
            window_height = self.settings['height']

            # Usa las coordenadas de la ventana principal o una posici√≥n predeterminada
            x = getattr(self.clipboard_manager, 'window_x', 0) + 50
            y = getattr(self.clipboard_manager, 'window_y', 0) + 50
            
            self.settings_window.geometry(f"{window_width}x{window_height}+{x}+{y}")
            
            self.settings_window.overrideredirect(True)
            self.settings_window.configure(bg=self.clipboard_manager.theme_manager.colors['dark']['bg'])
            self.settings_window.attributes('-topmost', True)

            # Barra de t√≠tulo personalizada
            title_frame = tk.Frame(self.settings_window, bg=self.clipboard_manager.theme_manager.colors['dark']['bg'])
            title_frame.pack(fill=tk.X, padx=6, pady=(0, 0))

            title_label = tk.Label(title_frame, text="Configuraciones", font=('Segoe UI', 10, 'bold'), 
                                   bg=self.clipboard_manager.theme_manager.colors['dark']['bg'], 
                                   fg=self.clipboard_manager.theme_manager.colors['dark']['fg'])
            title_label.pack(side=tk.LEFT, padx=5)

            close_button = tk.Button(title_frame, text="‚ùå", command=self.settings_window.destroy, 
                                     font=('Segoe UI', 10, 'bold'), bd=0, padx=10, width=5, height=2,
                                     bg=self.clipboard_manager.theme_manager.colors['dark']['button_bg'],
                                     fg=self.clipboard_manager.theme_manager.colors['dark']['button_fg'])
            close_button.pack(side=tk.RIGHT)

            # Canvas para scroll y contenedor de configuraciones
            canvas = tk.Canvas(self.settings_window, bg=self.clipboard_manager.theme_manager.colors['dark']['bg'], bd=0, highlightthickness=0)
            canvas.pack(fill=tk.BOTH, expand=True, padx=2, pady=2)

            # Scrollbar oculto
            scrollbar = ttk.Scrollbar(self.settings_window, orient=tk.VERTICAL, command=canvas.yview)
            canvas.configure(yscrollcommand=scrollbar.set)

            # Frame contenedor dentro del canvas para el scroll
            self.settings_frame = tk.Frame(canvas, bg=self.clipboard_manager.theme_manager.colors['dark']['bg'])
            canvas_window = canvas.create_window((0, 0), window=self.settings_frame, anchor='nw', width=295)

            # Ajustar el ancho del frame contenedor al canvas
            def on_canvas_resize(event):
                canvas.itemconfig(canvas_window, width=event.width)

            canvas.bind("<Configure>", on_canvas_resize)

            # Configuraci√≥n de scroll
            def on_frame_configure(event):
                canvas.configure(scrollregion=canvas.bbox("all"))

            self.settings_frame.bind("<Configure>", on_frame_configure)

            # Funci√≥n para desplazamiento con la rueda del mouse
            def _on_mousewheel(event):
                canvas.yview_scroll(int(-1*(event.delta/120)), "units")

            canvas.bind_all("<MouseWheel>", _on_mousewheel)

            # Crear cards de configuraci√≥n
            subtitle = tk.Label(self.settings_frame, text="Tecla de activaci√≥n", 
                        font=('Segoe UI', 10, 'bold'),
                        bg=self.clipboard_manager.theme_manager.colors['dark']['bg'],
                        fg=self.clipboard_manager.theme_manager.colors['dark']['fg'],
                        anchor='w')
            subtitle.pack(fill=tk.X, padx=4, pady=(10, 5), anchor='w')
            self.create_setting_card("Alt+", self.settings['hotkey'])
            
            subtitle = tk.Label(self.settings_frame, text="Dimensiones de la app", 
                        font=('Segoe UI', 10, 'bold'),
                        bg=self.clipboard_manager.theme_manager.colors['dark']['bg'],
                        fg=self.clipboard_manager.theme_manager.colors['dark']['fg'],
                        anchor='w')
            subtitle.pack(fill=tk.X, padx=4, pady=(10, 5), anchor='w')
            self.create_setting_card("Alto", str(self.settings['height']))
            self.create_setting_card("Ancho", str(self.settings['width']))

            # Hacer la ventana arrastrable
            title_label.bind('<Button-1>', self.start_move)
            title_label.bind('<B1-Motion>', self.on_move)

        else:
            self.settings_window.lift()
            self.settings_window.attributes('-topmost', True)
            self.settings_window.after_idle(self.settings_window.attributes, '-topmost', False)

    def create_setting_card(self, setting_name, default_value):
        card = tk.Frame(self.settings_frame, bg=self.clipboard_manager.theme_manager.colors['dark']['card_bg'])
        card.pack(fill=tk.X, padx=4, pady=2)

        label = tk.Label(card, text=f"{setting_name}: {default_value}", 
                         bg=self.clipboard_manager.theme_manager.colors['dark']['card_bg'],
                         fg=self.clipboard_manager.theme_manager.colors['dark']['fg'],
                         anchor='w', padx=5, pady=5)
        label.pack(side=tk.LEFT, fill=tk.X, expand=True)

        edit_button = tk.Button(card, text="‚úèÔ∏è", 
                                command=lambda: self.toggle_edit_mode(card, label, edit_button, setting_name, default_value),
                                font=('Segoe UI', 10), bd=0,
                                bg=self.clipboard_manager.theme_manager.colors['dark']['button_bg'],
                                fg=self.clipboard_manager.theme_manager.colors['dark']['button_fg'])
        edit_button.pack(side=tk.RIGHT, padx=2, pady=2)

    def toggle_edit_mode(self, card, label, button, setting_name, current_value):
        if button['text'] == "‚úèÔ∏è":
            # Cambiar a modo edici√≥n
            entry = tk.Entry(card, bg=self.clipboard_manager.theme_manager.colors['dark']['button_bg'],
                             fg=self.clipboard_manager.theme_manager.colors['dark']['fg'],
                             insertbackground=self.clipboard_manager.theme_manager.colors['dark']['fg'])
            entry.insert(0, current_value)
            entry.pack(side=tk.LEFT, fill=tk.X, expand=True, padx=5, pady=5)
            label.pack_forget()
            button.configure(text="üíæ")
        else:
            # Guardar cambios
            entry = [child for child in card.winfo_children() if isinstance(child, tk.Entry)][0]
            new_value = entry.get()
            label.configure(text=f"{setting_name}: {new_value}")
            entry.destroy()
            label.pack(side=tk.LEFT, fill=tk.X, expand=True)
            button.configure(text="‚úèÔ∏è")
            
            # Actualizar configuraciones
            if setting_name == "Alto":
                self.settings['height'] = int(new_value)
            elif setting_name == "Ancho":
                self.settings['width'] = int(new_value)
            elif setting_name == "Alt+":
                old_hotkey = self.settings['hotkey']
                new_hotkey = 'alt+' + new_value
                self.settings['hotkey'] = new_value  # Guarda solo la letra
                self.clipboard_manager.key_manager.update_hotkey(f"alt+{old_hotkey}", new_hotkey)
                
            self.save_settings()
            self.restart_app()
            
    def restart_app(self):
        python = sys.executable
        os.execl(python, python, *sys.argv, "--show-settings")
            
    def start_move(self, event):
        self.x = event.x
        self.y = event.y

    def on_move(self, event):
        deltax = event.x - self.x
        deltay = event.y - self.y
        x = self.settings_window.winfo_x() + deltax
        y = self.settings_window.winfo_y() + deltay
        self.settings_window.geometry(f"+{x}+{y}")

// Archivo: structure.py
# structure.py

import tkinter as tk
from tkinter import ttk
import threading
import win32gui
import pyautogui

from functions import Functions
from key_manager import KeyManager
from navigation import Navigation
from theme_manager import ThemeManager
from group_manager import GroupManager
from data_manager import DataManager
from settings_manager import SettingsManager

class ClipboardManager:
    def __init__(self, root, show_settings=False):
        self.root = root
        self.root.title("Portapapeles")

        self.data_manager = DataManager()
        groups, pinned_items, settings = self.data_manager.load_data()
        
        self.settings = settings
        self.settings_manager = SettingsManager(self.root, self)
        self.settings_manager.initialize_settings()

        self.window_width = settings['width']
        self.window_height = settings['height']
        self.window_x = 0
        self.window_y = 0

        self.root.overrideredirect(True)
        self.root.attributes('-topmost', True)
        self.root.protocol("WM_DELETE_WINDOW", self.on_close)  # Manejar el cierre de la ventana

        
        self.root.withdraw()
        self.is_visible = False

        self.previous_window = None

        self.clipboard_items = {}
        for item_id, item_data in pinned_items.items():
            if isinstance(item_data['text'], dict):
                self.clipboard_items[item_id] = item_data
            else:
                # Si el texto no es un diccionario, lo convertimos a la estructura esperada
                self.clipboard_items[item_id] = {
                    'text': {'text': item_data['text'], 'formatted': {}},
                    'pinned': item_data['pinned']
                }
        self.current_clipboard = ""
        self.selected_index = None
        self.current_selection = {'type': 'button', 'index': 0}
        self.is_dark_mode = True
        
        self.paste_with_format = False
        
        self.previous_window = None
        self.last_active_window = None
        self.selected_button = None
        self.selected_card = None
        self.selected_icon = None
        self.total_buttons = 6
        self.top_buttons = 3
        self.icons_per_card = 3
        
        self.hotkey = f"alt+{settings['hotkey']}"

        self.theme_manager = ThemeManager(self)
        self.functions = Functions(self)
        self.key_manager = KeyManager(self)
        self.group_manager = GroupManager(self.root, self)
        
        self.group_manager.groups = groups
        
        self.create_gui()
        self.load_saved_data()
        
        self.navigation = Navigation(self)
        
        self.theme_manager.apply_theme()

        self.monitor_thread = threading.Thread(target=self.functions.monitor_clipboard, daemon=True)
        self.monitor_thread.start()

        self.key_manager.update_hotkey(None, self.settings_manager.settings['hotkey'])
        
        # self.root.protocol("WM_DELETE_WINDOW", self.on_close)
        
        if show_settings:
            self.root.after(100, self.settings_manager.show_settings_window)
        
        self.root.after(1000, self.navigation.check_window_state)
        self.key_manager.setup_global_keys()
        
        # scroll
        self.canvas.configure(yscrollcommand=self.scrollbar.set)
        self.canvas.bind('<Configure>', self.on_canvas_configure)
        self.cards_frame.bind('<Configure>', lambda e: self.canvas.configure(scrollregion=self.canvas.bbox("all")))
        
    def force_update(self):
        self.root.update_idletasks()
        self.root.update()
            
    def on_close(self):
        self.root.withdraw()
        self.is_visible = False

    def create_gui(self):
        self.main_frame = ttk.Frame(self.root, style='Main.TFrame')
        self.main_frame.pack(fill=tk.BOTH, expand=True)

        self.title_frame = tk.Frame(self.main_frame, bg=self.theme_manager.colors['dark']['bg'])
        self.title_frame.pack(fill=tk.X, padx=3, pady=(0,6))

        self.title_label = tk.Label(self.title_frame, text="Portapapeles", font=('Segoe UI', 10, 'bold'), bg=self.theme_manager.colors['dark']['bg'], fg=self.theme_manager.colors['dark']['fg'])
        self.title_label.pack(side=tk.LEFT, padx=5)

        buttons_frame = tk.Frame(self.title_frame, bg=self.theme_manager.colors['dark']['bg'])
        buttons_frame.pack(side=tk.RIGHT, padx=4)

        self.theme_button = tk.Button(buttons_frame, text="üåô", command=self.theme_manager.toggle_theme, font=('Segoe UI', 10), bd=0, padx=10, width=5, height=2)
        self.theme_button.pack(side=tk.LEFT)

        self.clear_button = tk.Button(buttons_frame, text="    üñ•Ô∏è", command=self.show_settings, font=('Segoe UI', 10), bd=0, padx=10, width=5, height=2)
        self.clear_button.pack(side=tk.LEFT)

        self.close_button = tk.Button(buttons_frame, text="‚ùå", command=self.functions.exit_app, font=('Segoe UI', 10, 'bold'), bd=0, padx=10, width=5, height=2)
        self.close_button.pack(side=tk.LEFT)

        main_buttons_frame = tk.Frame(self.main_frame, bg=self.theme_manager.colors['dark']['bg'])
        main_buttons_frame.pack(fill=tk.X, padx=6, pady=0)

        self.button1 = tk.Button(main_buttons_frame, text="Grupos", 
                                 command=self.show_groups, font=('Segoe UI', 10), 
                                 bg=self.theme_manager.colors['dark']['button_bg'], 
                                 fg=self.theme_manager.colors['dark']['button_fg'],
                                 relief=tk.FLAT,
                                 bd=0,
                                 highlightthickness=1,
                                 pady=8)
        self.button1.pack(side=tk.LEFT, fill=tk.X, expand=True, padx=1, pady=0)

        self.button2 = tk.Button(main_buttons_frame, text="Sin formato", 
                                 command=self.functions.toggle_paste_format, font=('Segoe UI', 10), 
                                 bg=self.theme_manager.colors['dark']['button_bg'], 
                                 fg=self.theme_manager.colors['dark']['button_fg'],
                                 relief=tk.FLAT,
                                 bd=0,
                                 highlightthickness=1,
                                 pady=8) 
        self.button2.pack(side=tk.LEFT, fill=tk.X, expand=True, padx=1, pady=0)

        self.button3 = tk.Button(main_buttons_frame, text="Borrar Todo", 
                                 command=self.functions.clear_history, font=('Segoe UI', 10), 
                                 bg=self.theme_manager.colors['dark']['button_bg'], 
                                 fg=self.theme_manager.colors['dark']['button_fg'],
                                 relief=tk.FLAT,
                                 bd=0,
                                 highlightthickness=1,
                                 pady=8)                               
        self.button3.pack(side=tk.LEFT, fill=tk.X, expand=True, padx=1, pady=0)

        self.canvas = tk.Canvas(self.main_frame, bd=0, highlightthickness=0)
        self.canvas.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)
        
        self.cards_frame = tk.Frame(self.canvas, bg=self.theme_manager.colors['dark']['bg'])
        self.canvas_window = self.canvas.create_window((0, 0), window=self.cards_frame, anchor='nw')

        self.scrollbar = ttk.Scrollbar(self.main_frame, orient=tk.VERTICAL, command=self.canvas.yview)
        self.canvas.configure(yscrollcommand=self.scrollbar.set)

        # Variables para el movimiento de la ventana
        self._drag_data = {"x": 0, "y": 0, "item": None}

        # Vincular eventos para mover la ventana
        self.title_label.bind('<Button-1>', self.start_move)
        self.title_label.bind('<ButtonRelease-1>', self.stop_move)
        self.title_label.bind('<B1-Motion>', self.on_move)
        
        # Vincula eventos de scroll
        self.canvas.bind('<Configure>', self.on_canvas_configure)
        self.cards_frame.bind('<Configure>', self.on_frame_configure)
        self.canvas.bind_all("<MouseWheel>", self.on_mousewheel)

    def scrollbar_set(self, start, end):
        # Este m√©todo se llama cuando el canvas actualiza su regi√≥n de scroll
        self.canvas.yview_moveto(float(start))

    def show_groups(self):
        self.group_manager.show_groups_window()
        self.navigation.set_strategy('groups')

    def show_settings(self):
        self.settings_manager.show_settings_window()
        self.navigation.set_strategy('settings')

    def show_main_screen(self):
        # L√≥gica para mostrar la pantalla principal
        self.navigation.set_strategy('main')

    def load_saved_data(self):
        groups, pinned_items, _ = self.data_manager.load_data()
        self.group_manager.groups = groups
        self.clipboard_items.update(pinned_items)
        self.functions.refresh_cards()

    def on_main_window_map(self, event):
        if self.group_manager.groups_window and self.group_manager.groups_window.winfo_exists():
            self.group_manager.groups_window.deiconify()

    def on_main_window_unmap(self, event):
        if self.group_manager.groups_window and self.group_manager.groups_window.winfo_exists():
            self.group_manager.groups_window.withdraw()

    def start_move(self, event):
        self._drag_data["x"] = event.x
        self._drag_data["y"] = event.y

    def stop_move(self, event):
        self._drag_data["x"] = 0
        self._drag_data["y"] = 0
        self._drag_data["item"] = None

    def on_move(self, event):
        delta_x = event.x - self._drag_data["x"]
        delta_y = event.y - self._drag_data["y"]
        x = self.root.winfo_x() + delta_x
        y = self.root.winfo_y() + delta_y
        self.root.geometry(f"+{x}+{y}")
        self.window_x = x
        self.window_y = y

    def on_canvas_configure(self, event):
        self.canvas.configure(scrollregion=self.canvas.bbox("all"))
        width = event.width
        self.canvas.itemconfig(self.canvas_window, width=width)

    def on_frame_configure(self, event):
        self.canvas.configure(scrollregion=self.canvas.bbox("all"))

    def on_mousewheel(self, event):
        # Asegurarse de que el canvas tenga el foco
        self.canvas.focus_set()
        # Scroll
        self.canvas.yview_scroll(int(-1 * (event.delta / 120)), "units")
        
    def on_scroll(self, *args):
        # Este m√©todo se llama cuando se realiza un scroll
        if len(args) == 3 and isinstance(args[2], str):
            self.canvas.yview_moveto(args[0])
        elif len(args) == 2 and isinstance(args[0], str):
            self.canvas.yview_scroll(int(args[1]), args[0])

// Archivo: theme_manager.py
#theme_manager.py

import tkinter as tk
from tkinter import ttk

class ThemeManager:
    def __init__(self, manager):
        self.manager = manager
        self.colors = {
            'dark': {
                'bg': '#1e1e1e',
                'fg': '#ffffff',
                'button_bg': '#333333',
                'button_fg': '#ffffff',
                'listbox_bg': '#2d2d2d',
                'listbox_fg': '#ffffff',
                'active_bg': '#4E4E4E',  # A√±adido
                'active_fg': '#FFFFFF',  # A√±adido
                'card_bg': '#333333'
            },
            'light': {
                'bg': '#f0f0f0',
                'fg': '#000000',
                'button_bg': '#e0e0e0',
                'button_fg': '#000000',
                'listbox_bg': '#ffffff',
                'listbox_fg': '#000000',
                'active_bg': '#D0D0D0',  # A√±adido
                'active_fg': '#000000',  # A√±adido
                'card_bg': '#ffffff'
            }
        }

    def toggle_theme(self):
        self.manager.is_dark_mode = not self.manager.is_dark_mode
        self.manager.theme_button.config(text="üåô" if self.manager.is_dark_mode else "‚òÄÔ∏è")
        self.apply_theme()

    def apply_theme(self):
        theme = self.colors['dark'] if self.manager.is_dark_mode else self.colors['light']
        
        self.manager.root.configure(bg=theme['bg'])
        self.manager.main_frame.configure(style='Main.TFrame')
        self.manager.title_frame.configure(bg=theme['bg'])
        self.manager.title_label.configure(bg=theme['bg'], fg=theme['fg'])
        
        self.manager.clear_button.configure(
            bg=theme['button_bg'],
            fg=theme['button_fg'],
            activebackground=theme['button_bg'],
            activeforeground=theme['button_fg']
        )
        self.manager.theme_button.configure(
            bg=theme['button_bg'],
            fg=theme['button_fg'],
            activebackground=theme['button_bg'],
            activeforeground=theme['button_fg']
        )
        
        self.manager.close_button.configure(
            bg=theme['button_bg'],
            fg=theme['button_fg'],
            activebackground=theme['button_bg'],
            activeforeground=theme['button_fg']
        )

        self.manager.button1.configure(
            bg=theme['button_bg'],
            fg=theme['button_fg'],
            activebackground=theme['button_bg'],
            activeforeground=theme['button_fg']
        )

        self.manager.button2.configure(
            bg=theme['button_bg'],
            fg=theme['button_fg'],
            activebackground=theme['button_bg'],
            activeforeground=theme['button_fg']
        )

        self.manager.button3.configure(
            bg=theme['button_bg'],
            fg=theme['button_fg'],
            activebackground=theme['button_bg'],
            activeforeground=theme['button_fg']
        )

        self.manager.canvas.configure(bg=theme['bg'])
        self.manager.cards_frame.configure(bg=theme['bg'])
        
        self.manager.functions.refresh_cards()

        style = ttk.Style()  
        style.theme_use('clam')  
        style.configure('Main.TFrame', background=theme['bg'])

// Archivo: utils.py
# utils.py

import time

def measure_time(func):
    def wrapper(*args, **kwargs):
        start_time = time.time()
        result = func(*args, **kwargs)
        end_time = time.time()
        print(f"{func.__name__} tom√≥ {(end_time - start_time) * 1000:.2f} ms")
        return result
    return wrapper

def process_text(text_data, cant_lineas):
    """
    Procesa el texto para mostrarlo de forma limpia y ordenada
    """
    # Comprueba si text_data es un diccionario y extrae el texto
    if isinstance(text_data, dict):
        text = text_data.get('text', '')
    else:
        text = str(text_data)

    # Eliminamos espacios extras y tabulaciones al inicio y final
    text = text.strip()
    
    # Dividimos el texto en l√≠neas
    lines = text.splitlines()
    
    # Eliminamos l√≠neas vac√≠as consecutivas y espacios extras
    clean_lines = []
    prev_empty = False
    for line in lines:
        line = line.strip()
        
        # Si la l√≠nea est√° vac√≠a
        if not line:
            if not prev_empty:  # Solo mantenemos una l√≠nea vac√≠a
                clean_lines.append('')
                prev_empty = True
        else:
            clean_lines.append(line)
            prev_empty = False
    
    # Tomamos solo las primeras 'cant_lineas' para la vista previa
    preview_lines = clean_lines[:cant_lineas]
    
    # Si hay m√°s l√≠neas, indicamos cu√°ntas m√°s hay
    if len(clean_lines) > cant_lineas:
        remaining_lines = len(clean_lines) - cant_lineas
        preview_lines.append(f"+ {remaining_lines} l√≠neas m√°s")
        
    # Unimos las l√≠neas con saltos de l√≠nea
    return '\n'.join(preview_lines)
