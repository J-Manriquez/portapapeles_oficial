// Archivo: data_manager.py

import json
import os

class DataManager:
    def __init__(self, file_path='clipboard_data.json'):
        self.file_path = file_path

    def save_data(self, groups, pinned_items, settings):
        data = {
            'groups': groups,
            'pinned_items': self.encode_pinned_items(pinned_items),
            'settings': settings
        }
        with open(self.file_path, 'w') as f:
            json.dump(data, f, indent=4)
        print(f"All data saved to {self.file_path}")

    def load_data(self):
        if not os.path.exists(self.file_path):
            return {}, {}, {
                'height': 400,
                'width': 295,
                'hotkey': 'v'
            }
        
        with open(self.file_path, 'r') as f:
            data = json.load(f)
        
        groups = data.get('groups', {})
        pinned_items = self.decode_pinned_items(data.get('pinned_items', {}))
        settings = data.get('settings', {
            'height': 400,
            'width': 295,
            'hotkey': 'v'
        })
        
        return groups, pinned_items, settings

    def decode_pinned_items(self, encoded_items):
        decoded_items = {}
        for item_id, item_data in encoded_items.items():
            decoded_item = item_data.copy()
            if isinstance(item_data['text'], dict) and 'format' in item_data['text']:
                decoded_item['text'] = self.decode_formatted_text(item_data['text'])
            decoded_items[item_id] = decoded_item
        return decoded_items
    
    def encode_pinned_items(self, pinned_items):
        encoded_items = {}
        for item_id, item_data in pinned_items.items():
            encoded_item = item_data.copy()
            if isinstance(item_data['text'], dict):
                encoded_item['text'] = self.encode_formatted_text(item_data['text'])
            else:
                # Si el texto no es un diccionario, lo tratamos como texto simple
                encoded_item['text'] = self.encode_formatted_text({'text': item_data['text'], 'formatted': {}})
            encoded_items[item_id] = encoded_item
        return encoded_items

    def encode_formatted_text(self, text_data):
        if isinstance(text_data, str):
            # Si text_data es una cadena, la tratamos como texto simple
            return {
                'text': text_data,
                'format': {}
            }
        elif isinstance(text_data, dict):
            # Si text_data es un diccionario, asumimos que tiene la estructura esperada
            text = text_data.get('text', '')
            formatted = text_data.get('formatted', {})
            
            if isinstance(formatted, dict):
                return {
                    'text': text,
                    'format': {
                        'font': formatted.get('font'),
                        'size': formatted.get('size'),
                        'color': formatted.get('color'),
                        'bold': formatted.get('bold'),
                        'italic': formatted.get('italic'),
                        'rtf': formatted.get('rtf'),
                        'html': formatted.get('html'),
                        'underline': formatted.get('underline'),
                        'strikethrough': formatted.get('strikethrough'),
                        'superscript': formatted.get('superscript'),
                        'subscript': formatted.get('subscript'),
                        'background_color': formatted.get('background_color'),
                        'alignment': formatted.get('alignment'),
                    }
                }
            else:
                # Si 'formatted' no es un diccionario, devolvemos un formato vac√≠o
                return {
                    'text': text,
                    'format': {}
                }
        else:
            # Para cualquier otro tipo, convertimos a string y devolvemos sin formato
            return {
                'text': str(text_data),
                'format': {}
            }
                    
    def decode_formatted_text(self, encoded_text):
        return {
            'text': encoded_text['text'],
            'formatted': encoded_text['format']
        }

// Archivo: functions.py
# functions.py

import base64
import re
import tkinter as tk
import uuid
import win32con # type: ignore
import win32clipboard # type: ignore
import win32gui # type: ignore
import time
import sys
from tkinter import ttk
from bs4 import BeautifulSoup
from utils import measure_time, process_text

# Definir CF_HTML ya que no est√° en win32con
CF_HTML = win32clipboard.RegisterClipboardFormat("HTML Format")

class Functions:
    def __init__(self, manager):
        self.manager = manager
        self.min_card_height = 40  # Altura m√≠nima en p√≠xeles (2 l√≠neas + 2*2 padding)
        self.max_card_height = 76  # Altura m√°xima en p√≠xeles (4 l√≠neas + 2*2 padding)
        self.line_height = 18  # Altura estimada de una l√≠nea de texto


    @measure_time
    def create_card(self, item_id, item_data, index):
        card_width = self.manager.window_width - 4  # Ajuste para el padding
        card_height = max(self.min_card_height, self.calculate_card_height(item_data['text']))
        
        # Procesamos el texto para mostrarlo de forma limpia
        if isinstance(item_data['text'], dict):
            processed_text = process_text(item_data['text'].get('text', ''), 3)
        else:
            processed_text = process_text(str(item_data['text']), 3)
        
        # Obt√©n el color de fondo actual
        current_theme = 'dark' if self.manager.is_dark_mode else 'light'
        bg_color = self.manager.theme_manager.colors[current_theme]['card_bg']

        card_container = tk.Frame(self.manager.cards_frame, width=card_width, height=card_height, bg=bg_color)
        card_container.pack(fill=tk.BOTH, padx=2, pady=2)
        card_container.pack_propagate(False)  # Evita que el contenido afecte el tama√±o del contenedor

        text_frame = tk.Frame(card_container, bg=bg_color)
        text_frame.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)

        # Procesamos el texto para mostrarlo de forma limpia
        processed_text = process_text(item_data['text'], 3)

        text_label = tk.Label(text_frame, text=processed_text,
                            justify=tk.LEFT, anchor='w', padx=10, pady=5,
                            bg=card_container['bg'],
                            fg=self.manager.theme_manager.colors['dark' if self.manager.is_dark_mode else 'light']['fg'], width=int(24))
        text_label.pack(fill=tk.X, expand=True, side=tk.LEFT)

        icons_frame = tk.Frame(card_container, bg=card_container['bg'])
        icons_frame.pack(side=tk.RIGHT, padx=3)

        arrow_button = tk.Button(icons_frame, text="‚û°Ô∏è",
                                command=lambda: self.on_arrow_click(item_id),
                                font=('Segoe UI', 10), bd=0,
                                padx=2,
                                bg=card_container['bg'],
                                fg=self.manager.theme_manager.colors['dark' if self.manager.is_dark_mode else 'light']['fg'])
        arrow_button.pack(side=tk.LEFT)
        
        pin_text = "üìå" if item_data['pinned'] else "üìç"
        pin_button = tk.Button(icons_frame, text=pin_text,
                            command=lambda: self.toggle_pin(item_id),
                            font=('Segoe UI', 10), bd=0,
                            padx=2,
                            bg=card_container['bg'],
                            fg=self.manager.theme_manager.colors['dark' if self.manager.is_dark_mode else 'light']['fg'])
        pin_button.pack(side=tk.LEFT)

        delete_button = tk.Button(icons_frame, text="‚úñÔ∏è",
                                command=lambda: self.delete_item(item_id),
                                font=('Segoe UI', 10), bd=0,
                                padx=2,
                                bg=card_container['bg'],
                                fg=self.manager.theme_manager.colors['dark' if self.manager.is_dark_mode else 'light']['fg'])
        delete_button.pack(side=tk.LEFT)
        
        # Agregar bindings para la tarjeta completa
        card_container.bind('<Button-1>', lambda e: self.activate_card(index))
        text_label.bind('<Button-1>', lambda e: self.activate_card(index))

        # Configurar bindings para los iconos
        arrow_button.bind('<Button-1>', lambda e: self.activate_card_icon(index, 0))
        pin_button.bind('<Button-1>', lambda e: self.activate_card_icon(index, 1))
        delete_button.bind('<Button-1>', lambda e: self.activate_card_icon(index, 2))
        
        return card_container
    
    def activate_card(self, index: int) -> None:
        """Activa una tarjeta espec√≠fica"""
        self.manager.navigation.current_strategy.state['current_selection'] = {
            'type': 'cards',
            'index': index
        }
        self.manager.navigation.current_strategy.activate_selected()

    def activate_card_icon(self, card_index: int, icon_index: int) -> None:
        """Activa un icono espec√≠fico de una tarjeta"""
        self.manager.navigation.current_strategy.state['current_selection'] = {
            'type': 'icons',
            'index': card_index * 3 + icon_index
        }
        self.manager.navigation.current_strategy.activate_selected()
        
    def calculate_card_height(self, text_data):
        if isinstance(text_data, dict):
            text = text_data.get('text', '')
        else:
            text = str(text_data)
        lines = len(text.split('\n'))
        content_height = min(lines * self.line_height, 4 * self.line_height)  # M√°ximo 4 l√≠neas
        return min(max(content_height + 4, self.min_card_height), self.max_card_height)
    
    @measure_time
    def refresh_cards(self):
        if not hasattr(self.manager, 'cards_frame') or not self.manager.cards_frame.winfo_exists():
            print("cards_frame no existe o ha sido destruido")
            return
        # Eliminar tarjetas obsoletas
        existing_cards = {child.item_id: child for child in self.manager.cards_frame.winfo_children() if hasattr(child, 'item_id')}
        
        for item_id in list(existing_cards.keys()):
            if item_id not in self.manager.clipboard_items:
                existing_cards[item_id].destroy()
                del existing_cards[item_id]

        # Actualizar o crear nuevas tarjetas
        for index, (item_id, item_data) in enumerate(self.manager.clipboard_items.items()):
            if item_id in existing_cards:
                card = existing_cards[item_id]
                self.update_card(card, item_data)
            else:
                card = self.create_card(item_id, item_data, index)
                card.item_id = item_id

            card.pack(fill=tk.X, padx=2, pady=2)

        # Actualizar la regi√≥n de desplazamiento
        self.manager.canvas.update_idletasks()
        self.manager.canvas.configure(scrollregion=self.manager.canvas.bbox("all"))
        self.recalculate_card_heights()
        # Asegurarse de que el scroll est√© en la parte superior despu√©s de actualizar
        self.manager.canvas.yview_moveto(0)
        

    def update_card(self, card, item_data):
        processed_text = process_text(item_data['text'], 3)
        text_label = card.winfo_children()[0].winfo_children()[0]
        text_label.config(text=processed_text)

        new_height = self.calculate_card_height(processed_text)
        card.config(height=new_height)

        # Actualizar el estado del bot√≥n de pin
        pin_button = card.winfo_children()[1].winfo_children()[1]
        pin_text = "üìå" if item_data['pinned'] else "üìç"
        pin_button.config(text=pin_text)
        
    def apply_theme_to_card(self, card, theme):
        card.configure(bg=theme['card_bg'])
        
        for child in card.winfo_children():
            if isinstance(child, tk.Frame):
                child.configure(bg=theme['card_bg'])
                for subchild in child.winfo_children():
                    if isinstance(subchild, (tk.Label, tk.Button)):
                        subchild.configure(bg=theme['card_bg'], fg=theme['fg'])
            elif isinstance(child, (tk.Label, tk.Button)):
                child.configure(bg=theme['card_bg'], fg=theme['fg'])

    def toggle_pin(self, item_id):
        if item_id in self.manager.clipboard_items:
            self.manager.clipboard_items[item_id]['pinned'] = not self.manager.clipboard_items[item_id]['pinned']
            self.refresh_cards()
            self.manager.group_manager.save_groups()  # Guardar despu√©s de cambiar el estado de anclaje

    def delete_item(self, item_id):
        if item_id in self.manager.clipboard_items and not self.manager.clipboard_items[item_id]['pinned']:
            del self.manager.clipboard_items[item_id]
            self.refresh_cards()
            self.manager.group_manager.save_groups()  # Guardar despu√©s de eliminar un item

    
    def clear_history(self):
        self.manager.clipboard_items = {k: v for k, v in self.manager.clipboard_items.items() if v['pinned']}
        self.refresh_cards()
        self.manager.group_manager.save_groups()  # Guardar despu√©s de limpiar el historial
        if self.manager.current_selection['type'] == 'card':
            self.manager.current_selection = {'type': 'button', 'index': 0}
        self.manager.navigation.update_highlights()

    def on_canvas_configure(self, event):
        self.manager.canvas.configure(scrollregion=self.manager.canvas.bbox("all"))

    def on_mousewheel(self, event):
        self.manager.canvas.yview_scroll(int(-1 * (event.delta / 120)), "units")

    @measure_time
    def monitor_clipboard(self):
        while True:
            try:
                clipboard_content = self.get_clipboard_text()
                if clipboard_content and clipboard_content != self.manager.current_clipboard:
                    self.manager.current_clipboard = clipboard_content
                    if clipboard_content['text'] not in [item['text'].get('text', '') if isinstance(item['text'], dict) else item['text'] for item in self.manager.clipboard_items.values()]:
                        new_id = str(uuid.uuid4())
                        new_item = {
                            'text': clipboard_content,
                            'pinned': False,
                            'with_format': self.manager.paste_with_format
                        }
                        # Usar after para actualizar la GUI en el hilo principal
                        self.manager.root.after(0, self.add_clipboard_item, new_id, new_item)
            except Exception as e:
                print(f"Error en monitor_clipboard: {e}")
            time.sleep(0.5)
            
    def add_clipboard_item(self, new_id, new_item):
        # Aseg√∫rate de que new_item['text'] siempre sea un diccionario
        if isinstance(new_item['text'], str):
            new_item['text'] = {'text': new_item['text'], 'formatted': {}}
        elif not isinstance(new_item['text'], dict):
            new_item['text'] = {'text': str(new_item['text']), 'formatted': {}}

        self.manager.clipboard_items[new_id] = new_item
        if len(self.manager.clipboard_items) > 20:
            unpinned_items = [k for k, v in self.manager.clipboard_items.items() if not v['pinned']]
            if unpinned_items:
                del self.manager.clipboard_items[unpinned_items[-1]]
        self.refresh_cards()
        self.manager.group_manager.save_groups()

    # @measure_time
    def get_clipboard_text(self):
        try:
            win32clipboard.OpenClipboard()
            formats = []
            format_id = win32clipboard.EnumClipboardFormats(0)
            while format_id:
                formats.append(format_id)
                format_id = win32clipboard.EnumClipboardFormats(format_id)
            
            text = None
            format_info = {}
            
            if win32con.CF_UNICODETEXT in formats:
                text = win32clipboard.GetClipboardData(win32con.CF_UNICODETEXT)
            
            if win32con.CF_RTF in formats:
                rtf_data = win32clipboard.GetClipboardData(win32con.CF_RTF)
                format_info = self.extract_format_info_from_rtf(rtf_data)
            elif CF_HTML in formats:
                html_data = win32clipboard.GetClipboardData(CF_HTML)
                format_info = self.extract_format_info_from_html(html_data)
            
            win32clipboard.CloseClipboard()
            
            if text:
                if format_info:
                    return {'text': text, 'formatted': format_info}
                else:
                    return text  # Retorna solo el texto si no hay informaci√≥n de formato
            return None
        except Exception as e:
            print(f"Error al obtener texto del portapapeles: {e}")
            return None
        
    def extract_format_info_from_rtf(self, rtf_data):
        format_info = {'rtf': True}
        
        # Extraer informaci√≥n de fuente
        font_match = re.search(r'\\fonttbl.*?{\\f0\\fnil (.*?);}', rtf_data)
        if font_match:
            format_info['font'] = font_match.group(1)

        # Extraer informaci√≥n de tama√±o
        size_match = re.search(r'\\fs(\d+)', rtf_data)
        if size_match:
            format_info['size'] = int(size_match.group(1)) / 2  # RTF usa el doble del tama√±o real

        # Extraer informaci√≥n de color
        color_match = re.search(r'\\red(\d+)\\green(\d+)\\blue(\d+)', rtf_data)
        if color_match:
            format_info['color'] = (int(color_match.group(1)), int(color_match.group(2)), int(color_match.group(3)))

        # Extraer informaci√≥n de negrita e it√°lica
        format_info['bold'] = r'\b' in rtf_data
        format_info['italic'] = r'\i' in rtf_data

        return format_info

    def extract_format_info_from_html(self, html_data):
        format_info = {'html': True}
        soup = BeautifulSoup(html_data, 'html.parser')
        
        # Buscar el primer elemento con estilo
        styled_element = soup.find(style=True)
        if styled_element:
            style = styled_element['style']
            
            # Extraer informaci√≥n de fuente
            font_match = re.search(r'font-family:\s*(.*?);', style)
            if font_match:
                format_info['font'] = font_match.group(1)

            # Extraer informaci√≥n de tama√±o
            size_match = re.search(r'font-size:\s*(\d+)pt', style)
            if size_match:
                format_info['size'] = int(size_match.group(1))

            # Extraer informaci√≥n de color
            color_match = re.search(r'color:\s*rgb\((\d+),\s*(\d+),\s*(\d+)\)', style)
            if color_match:
                format_info['color'] = (int(color_match.group(1)), int(color_match.group(2)), int(color_match.group(3)))

        # Extraer informaci√≥n de negrita e it√°lica
        format_info['bold'] = bool(soup.find(['strong', 'b']))
        format_info['italic'] = bool(soup.find(['em', 'i']))

        return format_info
    
    def exit_app(self):
        self.manager.root.quit()
        sys.exit()
    
    @measure_time    
    def toggle_paste_format(self):
        self.manager.paste_with_format = not self.manager.paste_with_format
        new_text = "Con formato" if self.manager.paste_with_format else "Sin formato"
        self.manager.button2.config(text=new_text)
        self.manager.navigation.update_highlights()
        
    @measure_time
    def recalculate_card_heights(self):
        for card in self.manager.cards_frame.winfo_children():
            if hasattr(card, 'item_id'):
                item_data = self.manager.clipboard_items[card.item_id]
                new_height = self.calculate_card_height(item_data['text'])
                card.config(height=new_height)
        
        self.manager.canvas.update_idletasks()
        self.manager.canvas.configure(scrollregion=self.manager.canvas.bbox("all"))
        
    # def on_arrow_click(self, item_id):
    #     if not self.manager.group_manager.groups:
    #         tk.messagebox.showinfo("Sin Grupos", "No hay grupos disponibles. Cree un grupo primero.")
    #         return

    #     dialog = tk.Toplevel(self.manager.root)
    #     dialog.title("Seleccionar Grupo")
        
    #     window_width = self.manager.settings['width']
    #     window_height = self.manager.settings['height']
        
    #     x = self.manager.window_x + 20
    #     y = self.manager.window_y + 20
        
    #     dialog.geometry(f"{window_width}x{window_height}+{x}+{y}")
                
    #     # dialog.geometry("295x400")
    #     dialog.configure(bg=self.manager.theme_manager.colors['dark']['bg'])
    #     dialog.overrideredirect(True)
    #     dialog.attributes('-topmost', True)

    #     # Barra de t√≠tulo personalizada
    #     title_frame = tk.Frame(dialog, bg=dialog.cget('bg'))
    #     title_frame.pack(fill=tk.X, padx=5, pady=(5, 0))

    #     title_label = tk.Label(title_frame, text="Seleccionar Grupo", font=('Segoe UI', 10, 'bold'),
    #                         bg=dialog.cget('bg'), fg=self.manager.theme_manager.colors['dark']['fg'])
    #     title_label.pack(side=tk.LEFT, padx=5)

    #     close_button = tk.Button(title_frame, text="‚ùå", command=dialog.destroy,
    #                             font=('Segoe UI', 10, 'bold'), bd=0, padx=10,
    #                             bg=self.manager.theme_manager.colors['dark']['button_bg'],
    #                             fg=self.manager.theme_manager.colors['dark']['button_fg'])
    #     close_button.pack(side=tk.RIGHT)

    #     # Contenido
    #     content_frame = tk.Frame(dialog, bg=dialog.cget('bg'))
    #     content_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)

    #     for group_id, group_info in self.manager.group_manager.groups.items():
    #         group_button = tk.Button(content_frame, text=group_info['name'],
    #                                 command=lambda gid=group_id: self.add_to_group(item_id, gid, dialog),
    #                                 bg=self.manager.theme_manager.colors['dark']['button_bg'],
    #                                 fg=self.manager.theme_manager.colors['dark']['button_fg'],
    #                                 activebackground=self.manager.theme_manager.colors['dark']['active_bg'],
    #                                 activeforeground=self.manager.theme_manager.colors['dark']['active_fg'],
    #                                 bd=0, padx=10, pady=5, width=30, anchor='w')
    #         group_button.pack(fill=tk.X, pady=2)

    #     # Hacer la ventana arrastrable
    #     def start_move(event):
    #         dialog.x = event.x
    #         dialog.y = event.y

    #     def on_move(event):
    #         deltax = event.x - dialog.x
    #         deltay = event.y - dialog.y
    #         x = dialog.winfo_x() + deltax
    #         y = dialog.winfo_y() + deltay
    #         dialog.geometry(f"+{x}+{y}")

    #     title_frame.bind('<Button-1>', start_move)
    #     title_frame.bind('<B1-Motion>', on_move)

    # def add_to_group(self, item_id, group_id, dialog):
    #     self.manager.group_manager.add_item_to_group(item_id, group_id)
    #     dialog.destroy()
    #     # tk.messagebox.showinfo("√âxito", "Item agregado al grupo exitosamente.")
    
    def on_arrow_click(self, item_id):
        self.select_group(item_id)
        self.manager.navigation.set_strategy('select_group')
        
    def select_group(self, item_id):
        if not self.manager.group_manager.groups:
            tk.messagebox.showinfo("Sin Grupos", "No hay grupos disponibles. Cree un grupo primero.")
            return
        
        # Ocultar la ventana principal
        self.manager.root.withdraw()
        dialog = tk.Toplevel(self.manager.root)
        self.manager.select_group_dialog = dialog  # Guarda una referencia al di√°logo
        
        dialog.title("Seleccionar Grupo")
        
        window_width = self.manager.settings['width']
        window_height = self.manager.settings['height']
        
        x = self.manager.window_x
        y = self.manager.window_y
        
        dialog.geometry(f"{window_width}x{window_height}+{x}+{y}")
            
        dialog.configure(bg=self.manager.theme_manager.colors['dark']['bg'])
        dialog.overrideredirect(True)
        dialog.attributes('-topmost', True)
        # Barra de t√≠tulo personalizada
        title_frame = tk.Frame(dialog, bg=dialog.cget('bg'))
        title_frame.pack(fill=tk.X, padx=5, pady=(0, 4))
        title_label = tk.Label(title_frame, text="Seleccionar Grupo", font=('Segoe UI', 10, 'bold'),
                            bg=dialog.cget('bg'), fg=self.manager.theme_manager.colors['dark']['fg'])
        title_label.pack(side=tk.LEFT, padx=5)
        close_button = tk.Button(title_frame, text="‚ùå", command=lambda: self.close_dialog(dialog),
                                font=('Segoe UI', 10, 'bold'), bd=0, padx=10, width=5, height=2,
                                bg=self.manager.theme_manager.colors['dark']['button_bg'],
                                fg=self.manager.theme_manager.colors['dark']['button_fg'])
        close_button.pack(side=tk.RIGHT)
        # Canvas para scroll y contenedor de grupos
        canvas = tk.Canvas(dialog, bg=dialog.cget('bg'), bd=0, highlightthickness=0)
        canvas.pack(fill=tk.BOTH, expand=True, padx=5, pady=0)
        # Scrollbar
        scrollbar = ttk.Scrollbar(dialog, orient=tk.VERTICAL, command=canvas.yview)
        canvas.configure(yscrollcommand=scrollbar.set)
        # Frame contenedor dentro del canvas para el scroll
        content_frame = tk.Frame(canvas, bg=dialog.cget('bg'))
        canvas_window = canvas.create_window((0, 0), window=content_frame, anchor='nw', width=295)
        # Ajustar el ancho del frame contenedor al canvas
        def on_canvas_resize(event):
            canvas.itemconfig(canvas_window, width=event.width)
        canvas.bind("<Configure>", on_canvas_resize)
        # Configuraci√≥n de scroll
        def on_frame_configure(event):
            canvas.configure(scrollregion=canvas.bbox("all"))
        content_frame.bind("<Configure>", on_frame_configure)
        # Funci√≥n para desplazamiento con la rueda del mouse
        def _on_mousewheel(event):
            canvas.yview_scroll(int(-1*(event.delta/120)), "units")
        canvas.bind_all("<MouseWheel>", _on_mousewheel)
        for group_id, group_info in self.manager.group_manager.groups.items():
            group_button = tk.Button(content_frame, text=group_info['name'],
                                    command=lambda gid=group_id: self.add_to_group(item_id, gid, dialog),
                                    bg=self.manager.theme_manager.colors['dark']['button_bg'],
                                    fg=self.manager.theme_manager.colors['dark']['button_fg'],
                                    activebackground=self.manager.theme_manager.colors['dark']['active_bg'],
                                    activeforeground=self.manager.theme_manager.colors['dark']['active_fg'],
                                    bd=0, padx=10, pady=5, width=30, anchor='w')
            group_button.pack(fill=tk.X, pady=2)
        # Hacer la ventana arrastrable
        def start_move(event):
            dialog.x = event.x
            dialog.y = event.y
        def on_move(event):
            deltax = event.x - dialog.x
            deltay = event.y - dialog.y
            x = dialog.winfo_x() + deltax
            y = dialog.winfo_y() + deltay
            dialog.geometry(f"+{x}+{y}")
        title_frame.bind('<Button-1>', start_move)
        title_frame.bind('<B1-Motion>', on_move)
        # Configurar la navegaci√≥n para la pantalla de selecci√≥n de grupo
        self.manager.navigation.set_strategy('select_group')
        self.manager.select_group_keys.activate()
    def close_dialog(self, dialog):
        dialog.destroy()
        self.manager.root.deiconify()
        self.manager.navigation.set_strategy('main')  # Volver a la estrategia de navegaci√≥n principal
        self.manager.main_screen_keys.activate()  # Reactivar 
        if hasattr(self.manager, 'select_group_dialog'):
            delattr(self.manager, 'select_group_dialog')
    def add_to_group(self, item_id, group_id, dialog):
        self.manager.group_manager.add_item_to_group(item_id, group_id)
        dialog.destroy()
        self.manager.root.deiconify()
        self.manager.navigation.set_strategy('main')  # Volver a la estrategia de navegaci√≥n principal
        if hasattr(self.manager, 'select_group_dialog'):
            delattr(self.manager, 'select_group_dialog')


// Archivo: groups_manager.py
# group_manager.py

import tkinter as tk
from tkinter import ttk, simpledialog, messagebox
import uuid
from settings_manager import SettingsManager
from group_content_manager import GroupContentManager
import logging

logging.getLogger('chardet').setLevel(logging.WARNING)
logging.basicConfig(level=logging.DEBUG, format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

class GroupManager:
    def __init__(self, master, clipboard_manager):
        self.master = master
        self.clipboard_manager = clipboard_manager
        self.data_manager = clipboard_manager.data_manager
        self.theme_manager = clipboard_manager.theme_manager
        self.settings = clipboard_manager.settings
        self.settings_manager = clipboard_manager.settings_manager
        self.groups, _, _ = self.data_manager.load_data()
        self.groups_window = None
        self.groups_frame = None
        self.group_content_manager = GroupContentManager(master, clipboard_manager, clipboard_manager.theme_manager, clipboard_manager.settings_manager)
        self.canvas = None
        self.scrollbar = None
        self.add_button = None
        self.close_button = None

    def show_group_content(self, group_id):
        if self.groups_window:
            self.groups_window.withdraw()  # Oculta la ventana de grupos
        self.group_content_manager.show_group_content(group_id)


    def show_groups_window(self):
        logger.debug("Intentando mostrar la ventana de grupos")
        if self.groups_window is None or not self.groups_window.winfo_exists():
            logger.debug("Creando nueva ventana de grupos")
            self.groups_window = tk.Toplevel(self.master)
            self.groups_window.title("Grupos")
            
            window_width = self.settings['width']
            window_height = self.settings['height']
            
            x = self.clipboard_manager.window_x 
            y = self.clipboard_manager.window_y 
            
            self.groups_window.geometry(f"{window_width}x{window_height}+{x}+{y}")
            
            self.groups_window.overrideredirect(True)
            self.groups_window.configure(bg=self.theme_manager.colors['dark']['bg'])
            self.groups_window.attributes('-topmost', True)
            self.master.bind("<Destroy>", self.on_main_window_close)

            # Barra de t√≠tulo personalizada
            title_frame = tk.Frame(self.groups_window, bg=self.theme_manager.colors['dark']['bg'])
            title_frame.pack(fill=tk.X, padx=2, pady=(0, 0))

            title_label = tk.Label(title_frame, text="Grupos", font=('Segoe UI', 10, 'bold'), 
                                   bg=self.theme_manager.colors['dark']['bg'], 
                                   fg=self.theme_manager.colors['dark']['fg'])
            title_label.pack(side=tk.LEFT, padx=5)

            # Botones en la barra de t√≠tulo
            buttons_frame = tk.Frame(title_frame, bg=self.theme_manager.colors['dark']['bg'])
            buttons_frame.pack(side=tk.RIGHT, padx=4)

            self.add_button = tk.Button(buttons_frame, text="‚ûï", command=self.add_group, 
                                   font=('Segoe UI', 10), bd=0, padx=10, width=5, height=2,
                                   bg=self.theme_manager.colors['dark']['button_bg'],
                                   fg=self.theme_manager.colors['dark']['button_fg'])
            self.add_button.pack(side=tk.LEFT)

            self.close_button = tk.Button(buttons_frame, text="‚ùå", command=self.close_groups_window, 
                                     font=('Segoe UI', 10, 'bold'), bd=0, padx=10, width=5, height=2,
                                     bg=self.theme_manager.colors['dark']['button_bg'],
                                     fg=self.theme_manager.colors['dark']['button_fg'])
            self.close_button.pack(side=tk.LEFT)
            
            # Canvas para scroll y contenedor de grupos
            self.canvas = tk.Canvas(self.groups_window, bg=self.theme_manager.colors['dark']['bg'], bd=0, highlightthickness=0)
            self.canvas.pack(fill=tk.BOTH, expand=True, padx=2, pady=2)

            # Scrollbar
            self.scrollbar = ttk.Scrollbar(self.groups_window, orient=tk.VERTICAL, command=self.canvas.yview)
            self.canvas.configure(yscrollcommand=self.scrollbar.set)

            # Frame contenedor dentro del canvas para el scroll
            self.groups_frame = tk.Frame(self.canvas, bg=self.theme_manager.colors['dark']['bg'])
            canvas_window = self.canvas.create_window((0, 0), window=self.groups_frame, anchor='nw')

            # Ajustar el ancho del frame contenedor al canvas
            def on_canvas_resize(event):
                self.canvas.itemconfig(canvas_window, width=event.width)

            self.canvas.bind("<Configure>", on_canvas_resize)

            # Configuraci√≥n de scroll
            def on_frame_configure(event):
                self.canvas.configure(scrollregion=self.canvas.bbox("all"))

            self.groups_frame.bind("<Configure>", on_frame_configure)

            # Funci√≥n para desplazamiento con la rueda del mouse
            def _on_mousewheel(event):
                self.canvas.yview_scroll(int(-1*(event.delta/120)), "units")

            self.canvas.bind_all("<MouseWheel>", _on_mousewheel)

            # Hacer la ventana arrastrable
            title_label.bind('<Button-1>', self.start_move)
            title_label.bind('<B1-Motion>', self.on_move)

            self.refresh_groups()

            # Configurar eventos de teclado
            self.groups_window.bind('<Up>', lambda e: self.clipboard_manager.navigation.navigate_vertical(e))
            self.groups_window.bind('<Down>', lambda e: self.clipboard_manager.navigation.navigate_vertical(e))
            self.groups_window.bind('<Left>', lambda e: self.clipboard_manager.navigation.navigate_horizontal(e))
            self.groups_window.bind('<Right>', lambda e: self.clipboard_manager.navigation.navigate_horizontal(e))
            self.groups_window.bind('<Return>', lambda e: self.clipboard_manager.navigation.activate_selected(e))

            # Mostrar la ventana despu√©s de configurarla completamente
            self.groups_window.deiconify()
            self.groups_window.focus_force()
            
            # Inicializar el foco despu√©s de que la ventana est√© visible
            self.groups_window.after(100, self.clipboard_manager.navigation.initialize_focus)
        else:
            logger.debug("Mostrando ventana de grupos existente")
            self.groups_window.deiconify()
            self.groups_window.focus_force()

        self.clipboard_manager.navigation.set_strategy('groups')
        logger.debug("Ventana de grupos mostrada y estrategia de navegaci√≥n configurada")

        # Restaurar la posici√≥n del scroll
        # if hasattr(self, 'scroll_position'):
        #     self.canvas.yview_moveto(self.scroll_position)
         
    def close_groups_window(self):
        if self.canvas:
            # Guardar la posici√≥n actual del scroll
            self.scroll_position = self.canvas.yview()[0]
        self.groups_window.withdraw()
        self.clipboard_manager.show_main_screen()
        
    def start_move(self, event):
        self.x = event.x
        self.y = event.y

    def on_move(self, event):
        deltax = event.x - self.x
        deltay = event.y - self.y
        x = self.groups_window.winfo_x() + deltax
        y = self.groups_window.winfo_y() + deltay
        self.groups_window.geometry(f"+{x}+{y}")

    def refresh_groups(self):
        logger.debug("Refrescando grupos")
        if self.groups_frame is None or not self.groups_frame.winfo_exists():
            return

        for widget in self.groups_frame.winfo_children():
            widget.destroy()

        for group_id, group_info in self.groups.items():
            group_card = tk.Frame(self.groups_frame, bg=self.theme_manager.colors['dark']['card_bg'], cursor="hand2")
            group_card.pack(fill=tk.X, padx=4, pady=2)
            
            group_card.bind("<Button-1>", lambda e, gid=group_id: self.show_group_content(gid))

            name_label = tk.Label(group_card, text=group_info['name'], font=("Segoe UI", 10, "bold"),
                                bg=self.theme_manager.colors['dark']['card_bg'],
                                fg=self.theme_manager.colors['dark']['fg'], 
                                width=int(17), justify=tk.LEFT, anchor='w',)
            name_label.pack(side=tk.LEFT, padx=5, pady=5)

            count_label = tk.Label(group_card, text=f"Items: {len(group_info['items'])}",
                                bg=self.theme_manager.colors['dark']['card_bg'],
                                fg=self.theme_manager.colors['dark']['fg'])
            count_label.pack(side=tk.LEFT, padx=5, pady=2)
            
            # Frame para los iconos
            icons_frame = tk.Frame(group_card, bg=self.theme_manager.colors['dark']['card_bg'])
            icons_frame.pack(side=tk.RIGHT, padx=3)

            edit_button = tk.Button(icons_frame, text="‚úèÔ∏è", command=lambda gid=group_id: self.edit_group(gid),
                        font=('Segoe UI', 10), bd=0, highlightthickness=0,padx=4,
                        bg=self.clipboard_manager.theme_manager.colors['dark']['button_bg'],
                        fg=self.clipboard_manager.theme_manager.colors['dark']['button_fg'])
            edit_button.pack(side=tk.LEFT)

            delete_button = tk.Button(icons_frame, text="‚ùå", command=lambda gid=group_id: self.delete_group(gid),
                          font=('Segoe UI', 10), bd=0, highlightthickness=0, padx=4,
                          bg=self.clipboard_manager.theme_manager.colors['dark']['button_bg'],
                          fg=self.clipboard_manager.theme_manager.colors['dark']['button_fg'])
            delete_button.pack(side=tk.LEFT)

        # logger.debug(f"Grupos refrescados: {len(self.groups)} grupos")

            
            
    def save_groups(self):
        pinned_items = {k: v for k, v in self.clipboard_manager.clipboard_items.items() if v['pinned']}
        # Aseg√∫rate de que cada item pinned tenga la estructura correcta
        for item_id, item_data in pinned_items.items():
            if isinstance(item_data['text'], str):
                pinned_items[item_id]['text'] = {'text': item_data['text'], 'formatted': {}}
            elif not isinstance(item_data['text'], dict):
                pinned_items[item_id]['text'] = {'text': str(item_data['text']), 'formatted': {}}
        
        self.data_manager.save_data(self.groups, pinned_items, self.clipboard_manager.settings)
        print("Groups and pinned items saved")
        
    def edit_group(self, group_id):
        self.show_edit_group_dialog(group_id)

    def delete_group(self, group_id):
        # if tk.messagebox.askyesno("Eliminar Grupo", "¬øEst√° seguro de que desea eliminar este grupo?"):
        del self.groups[group_id]
        self.refresh_groups()
        self.save_groups()

    def add_item_to_group(self, item_id, group_id):
        if group_id in self.groups:
            item_data = self.clipboard_manager.clipboard_items.get(item_id)
            if item_data and item_id not in [item['id'] for item in self.groups[group_id]['items']]:
                self.groups[group_id]['items'].append({
                    'id': item_id,
                    'text': item_data['text']
                })
                self.save_groups()
                if self.groups_window and self.groups_window.winfo_exists():
                    self.refresh_groups()
                print(f"Item {item_id} added to group {group_id}")
                
                # Actualizar la vista principal si es necesario
                if hasattr(self.clipboard_manager, 'refresh_cards'):
                    self.clipboard_manager.refresh_cards()
            else:
                print(f"Item {item_id} already in group {group_id} or not found")
        else:
            print(f"Group {group_id} not found")
            
    def on_main_window_close(self, event):
        if self.groups_window and self.groups_window.winfo_exists():
            self.groups_window.destroy()
            
    def close_groups_window(self):
        self.groups_window.destroy()
        self.clipboard_manager.show_main_screen()
            
    # ----------------------------------------------------------------------
    
    def show_group_dialog(self, group_id=None):
        is_edit = group_id is not None
        dialog = tk.Toplevel(self.master)
        dialog.title("Editar Grupo" if is_edit else "Nuevo Grupo")
        
        x = self.clipboard_manager.window_x + 40
        y = self.clipboard_manager.window_y + 40
        
        dialog.geometry(f"200x114+{x}+{y}")
        
        dialog.configure(bg=self.theme_manager.colors['dark']['bg'])
        dialog.overrideredirect(True)
        dialog.attributes('-topmost', True)

        # Barra de t√≠tulo personalizada
        title_frame = tk.Frame(dialog, bg=self.theme_manager.colors['dark']['bg'])
        title_frame.pack(fill=tk.X, padx=4, pady=(4, 0))

        title_label = tk.Label(title_frame, text="Editar Grupo" if is_edit else "Nuevo Grupo", 
                            font=('Segoe UI', 10, 'bold'),
                            bg=self.theme_manager.colors['dark']['bg'],
                            fg=self.theme_manager.colors['dark']['fg'])
        title_label.pack(side=tk.LEFT, padx=0)

        close_button = tk.Button(title_frame, text="‚ùå", command=dialog.destroy,
                                font=('Segoe UI', 10, 'bold'), bd=0, padx=0,
                                bg=self.theme_manager.colors['dark']['button_bg'],
                                fg=self.theme_manager.colors['dark']['button_fg'])
        close_button.pack(side=tk.RIGHT)

        # Contenido
        content_frame = tk.Frame(dialog, bg=self.theme_manager.colors['dark']['bg'])
        content_frame.pack(fill=tk.BOTH, expand=True, padx=4, pady=0)

        name_label = tk.Label(content_frame, text="Nombre del grupo:",
                            bg=self.theme_manager.colors['dark']['bg'],
                            fg=self.theme_manager.colors['dark']['fg'])
        name_label.pack(anchor='w', pady=(0, 5))

        name_entry = tk.Entry(content_frame, bg=self.theme_manager.colors['dark']['button_bg'],
                            fg=self.theme_manager.colors['dark']['fg'],
                            insertbackground=self.theme_manager.colors['dark']['fg'],
                            relief=tk.FLAT, bd=0, highlightthickness=1,
                            highlightcolor=self.theme_manager.colors['dark'].get('highlight', '#555555'),
                            highlightbackground=self.theme_manager.colors['dark'].get('border', '#333333'))
        name_entry.pack(fill=tk.X, pady=(0, 5))

        if is_edit:
            name_entry.insert(0, self.groups[group_id]['name'])

        def save_group():
            name = name_entry.get().strip()
            if name:
                if is_edit:
                    self.groups[group_id]['name'] = name
                else:
                    new_group_id = str(uuid.uuid4())
                    self.groups[new_group_id] = {'name': name, 'items': []}
                self.refresh_groups()
                self.save_groups()
                dialog.destroy()

        save_button = tk.Button(content_frame, text="Guardar", command=save_group,
                                bg=self.theme_manager.colors['dark']['button_bg'],
                                fg=self.theme_manager.colors['dark']['button_fg'],
                                activebackground=self.theme_manager.colors['dark'].get('active_bg', '#4E4E4E'),
                                activeforeground=self.theme_manager.colors['dark'].get('active_fg', '#FFFFFF'),
                                relief=tk.FLAT, bd=0, padx=4, pady=6)
        save_button.pack(fill=tk.X, pady=(0, 0))

        # Hacer la ventana arrastrable
        def start_move(event):
            dialog.x = event.x
            dialog.y = event.y

        def on_move(event):
            deltax = event.x - dialog.x
            deltay = event.y - dialog.y
            x = dialog.winfo_x() + deltax
            y = dialog.winfo_y() + deltay
            dialog.geometry(f"+{x}+{y}")

        title_frame.bind('<Button-1>', start_move)
        title_frame.bind('<B1-Motion>', on_move)

        dialog.focus_set()
        name_entry.focus()

    def add_group(self):
        self.show_group_dialog()

    def edit_group(self, group_id):
        self.show_group_dialog(group_id)    
    

// Archivo: group_content_manager.py
# group_content_manager.py

import tkinter as tk
from tkinter import ttk

from utils import process_text

class GroupContentManager:
    def __init__(self, master, clipboard_manager, theme_manager, settings_manager):
        self.master = master
        self.clipboard_manager = clipboard_manager
        self.theme_manager = theme_manager
        self.settings_manager = settings_manager
        self.content_window = None
        self.canvas = None
        self.scrollbar = None
        self.items_frame = None

        self.min_card_height = 50  # Altura m√≠nima en p√≠xeles (2 l√≠neas + 2*2 padding)
        self.max_card_height = 120  # Altura m√°xima en p√≠xeles (4 l√≠neas + 2*2 padding)
        self.line_height = 10      # Altura estimada de una l√≠nea de texto

    def calculate_card_height(self, text_data):
        if isinstance(text_data, dict):
            text = text_data.get('text', '')
        else:
            text = str(text_data)
        
        lines = len(text.split('\n'))
        if lines > 2:
            content_height = min(lines * (self.line_height*2), 7 * self.line_height)  # M√°ximo 4 l√≠neas
        else:
            content_height = min(lines * self.line_height, 5 * self.line_height)  # M√°ximo 4 l√≠neas
        return min(max(content_height + 5, self.min_card_height), self.max_card_height)

    def show_group_content(self, group_id):
        if self.content_window is None or not self.content_window.winfo_exists():
            self.content_window = tk.Toplevel(self.master)
            self.content_window.title(f"Contenido del Grupo: {self.clipboard_manager.group_manager.groups[group_id]['name']}")
            
            window_width = self.settings_manager.settings['width']
            window_height = self.settings_manager.settings['height']
            
            x = self.clipboard_manager.window_x 
            y = self.clipboard_manager.window_y 
            
            self.content_window.geometry(f"{window_width}x{window_height}+{x}+{y}")
                    
            self.content_window.overrideredirect(True)
            self.content_window.configure(bg=self.theme_manager.colors['dark']['bg'])
            self.content_window.attributes('-topmost', True)

            # Barra de t√≠tulo personalizada
            title_frame = tk.Frame(self.content_window, bg=self.theme_manager.colors['dark']['bg'])
            title_frame.pack(fill=tk.X, padx=6, pady=(0,0))

            title_label = tk.Label(title_frame, text=f"Grupo: {self.clipboard_manager.group_manager.groups[group_id]['name']}", 
                                font=('Segoe UI', 10, 'bold'),
                                bg=self.theme_manager.colors['dark']['bg'],
                                fg=self.theme_manager.colors['dark']['fg'])
            title_label.pack(side=tk.LEFT, padx=5, pady=5)

            close_button = tk.Button(title_frame, text="‚ùå", command=lambda: self.close_content_window(group_id),
                                    font=('Segoe UI', 10, 'bold'),bd=0, padx=10, width=5, height=2,
                                    bg=self.theme_manager.colors['dark']['button_bg'],
                                    fg=self.theme_manager.colors['dark']['button_fg'])
            close_button.pack(side=tk.RIGHT)

            # Canvas y scroll para los items
            self.canvas = tk.Canvas(self.content_window, bg=self.theme_manager.colors['dark']['bg'], highlightthickness=0)
            self.canvas.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)

            self.scrollbar = ttk.Scrollbar(self.content_window, orient="vertical", command=self.canvas.yview)
            self.scrollbar.pack(side=tk.RIGHT, fill=tk.Y)

            self.canvas.configure(yscrollcommand=self.scrollbar.set)

            self.items_frame = tk.Frame(self.canvas, bg=self.theme_manager.colors['dark']['bg'])
            self.canvas.create_window((0, 0), window=self.items_frame, anchor='nw', width=window_width)
            self.canvas_window = self.canvas.create_window((0, 0), window=self.items_frame, anchor='nw', width=window_width)

            # Configurar el desplazamiento con la rueda del rat√≥n
            def _on_mousewheel(event):
                self.canvas.yview_scroll(int(-1*(event.delta/120)), "units")

            self.canvas.bind_all("<MouseWheel>", _on_mousewheel)

            # Asegurar que el ancho del frame interior se ajuste al canvas
            def _configure_inner_frame(event):
                if self.canvas.winfo_exists():
                    self.canvas.itemconfig(self.canvas_window, width=event.width)
            
            self.canvas.bind('<Configure>', _configure_inner_frame)

            # Hacer la ventana arrastrable
            title_frame.bind('<Button-1>', self.start_move)
            title_frame.bind('<B1-Motion>', self.on_move)

        else:
            self.content_window.deiconify()  # Muestra la ventana si estaba oculta
            self.content_window.lift()
            self.content_window.attributes('-topmost', True)
            self.content_window.after_idle(self.content_window.attributes, '-topmost', False)

        # Mostrar items del grupo
        self.refresh_group_content(group_id)

        # Restaurar la posici√≥n del scroll
        if hasattr(self, 'scroll_position'):
            self.canvas.yview_moveto(self.scroll_position)

    def close_content_window(self, group_id):
        if self.canvas:
            # Guardar la posici√≥n actual del scroll
            self.scroll_position = self.canvas.yview()[0]
        self.content_window.withdraw()
        self.clipboard_manager.group_manager.show_groups_window()

    def start_move(self, event):
        self.x = event.x
        self.y = event.y

    def on_move(self, event):
        deltax = event.x - self.x
        deltay = event.y - self.y
        x = self.content_window.winfo_x() + deltax
        y = self.content_window.winfo_y() + deltay
        self.content_window.geometry(f"+{x}+{y}")
        
    def refresh_group_content(self, group_id):
        # Limpiar el frame de items existente
        for widget in self.items_frame.winfo_children():
            widget.destroy()
        
        window_width = self.settings_manager.settings['width']
        window_height = self.settings_manager.settings['height'] - 40  # Ajuste para la barra de t√≠tulo

        current_theme = 'dark'  # Puedes cambiar esto si soportas modo claro/oscuro
        theme = self.theme_manager.colors[current_theme]

        for item in self.clipboard_manager.group_manager.groups[group_id]['items']:
            card_width = window_width - 4  # Ajuste m√≠nimo para el padding
            card_height = max(self.min_card_height, self.calculate_card_height(item['text']))
    
            bg_color = theme['card_bg']
    
            card_container = tk.Frame(self.items_frame, width=card_width, height=card_height, bg=bg_color)
            card_container.pack(fill=tk.X, padx=6, pady=(4,0))
            card_container.pack_propagate(False)  # Evita que el contenido afecte el tama√±o del contenedor

            text_frame = tk.Frame(card_container, bg=bg_color, pady=0)
            text_frame.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)

            # Procesamos el texto para mostrarlo de forma limpia
            processed_text = process_text(item['text'], 2)
            item_name = item.get('name', '')

            # Etiqueta para item_name en negrita y tama√±o de fuente mayor
            if item_name:
                item_name_label = tk.Label(
                    text_frame,
                    text=f"{item_name}:",
                    font=("Segoe UI", 10, "bold"),
                    bg=bg_color,
                    fg=theme['fg'],
                    justify=tk.LEFT,
                    anchor='w',
                    width=int(24)
                )
                item_name_label.pack(padx=2, pady=0, fill=tk.X, side=tk.TOP, anchor='w')

            # Etiqueta para processed_text con fuente regular
            text_label = tk.Label(
                text_frame,
                text=processed_text,
                font=("Segoe UI", 10),
                justify=tk.LEFT,
                anchor='w',
                bg=bg_color,
                fg=theme['fg'],
                width=int(24)
            )
            text_label.pack(padx=6, pady=(0,4), fill=tk.X, expand=True, side=tk.TOP)
            
            icons_frame = tk.Frame(card_container, bg=bg_color)
            icons_frame.pack(side=tk.RIGHT, padx=3)

            edit_button = tk.Button(icons_frame, text="‚úèÔ∏è", 
                                    command=lambda i=item['id']: self.edit_group_item(group_id, i),
                                    font=('Segoe UI', 10), bd=0,
                                    padx=2,
                                    bg=bg_color,
                                    fg=theme['fg'])
            edit_button.pack(side=tk.LEFT)

            delete_button = tk.Button(icons_frame, text="üóëÔ∏è", 
                                    command=lambda i=item['id']: self.remove_item_from_group(group_id, i, self.items_frame),
                                    font=('Segoe UI', 10), bd=0,
                                    padx=2,
                                    bg=bg_color,
                                    fg=theme['fg'])
            delete_button.pack(side=tk.LEFT)

        # Actualizar el scrollregion despu√©s de a√±adir todos los widgets
        self.items_frame.update_idletasks()
        self.canvas.config(scrollregion=self.canvas.bbox("all"))
        
    def remove_item_from_group(self, group_id, item_id, items_frame):
        self.clipboard_manager.group_manager.groups[group_id]['items'] = [item for item in self.clipboard_manager.group_manager.groups[group_id]['items'] if item['id'] != item_id]
        self.clipboard_manager.group_manager.save_groups()
        self.refresh_group_content(group_id)

    def edit_group_item(self, group_id, item_id):
        item = next((item for item in self.clipboard_manager.group_manager.groups[group_id]['items'] if item['id'] == item_id), None)
        if not item:
            return

        dialog = tk.Toplevel(self.master)
        dialog.title("Editar Item")
        
        x = self.clipboard_manager.window_x + 40
        y = self.clipboard_manager.window_y + 40
        
        if isinstance(item['text'], dict):
            text = item['text'].get('text', '')
            original_format = item['text'].get('formatted', {})
        else:
            text = str(item['text'])
            original_format = {}
        
        text_lines = text.count('\n') + 1
        initial_height = min(150 + (text_lines * 20), 600)
        
        dialog.geometry(f"300x{initial_height}+{x}+{y}")
        
        dialog.configure(bg=self.theme_manager.colors['dark']['bg'])
        dialog.overrideredirect(True)
        dialog.attributes('-topmost', True)

        title_frame = tk.Frame(dialog, bg=self.theme_manager.colors['dark']['bg'])
        title_frame.pack(fill=tk.X, padx=4, pady=(4, 0))

        title_label = tk.Label(title_frame, text="Editar Item", font=('Segoe UI', 10, 'bold'),
                            bg=self.theme_manager.colors['dark']['bg'],
                            fg=self.theme_manager.colors['dark']['fg'])
        title_label.pack(side=tk.LEFT, padx=0)

        close_button = tk.Button(title_frame, text="‚ùå", command=dialog.destroy,
                                font=('Segoe UI', 10, 'bold'), bd=0, padx=0,
                                bg=self.theme_manager.colors['dark']['button_bg'],
                                fg=self.theme_manager.colors['dark']['button_fg'])
        close_button.pack(side=tk.RIGHT)
        
        content_frame = tk.Frame(dialog, bg=self.theme_manager.colors['dark']['bg'])
        content_frame.pack(fill=tk.BOTH, expand=True, padx=4, pady=0)

        name_label = tk.Label(content_frame, text="Nombre del item:",
                            bg=self.theme_manager.colors['dark']['bg'],
                            fg=self.theme_manager.colors['dark']['fg'])
        name_label.pack(anchor='w', pady=(0, 5))

        name_entry = tk.Entry(content_frame, bg=self.theme_manager.colors['dark']['button_bg'],
                            fg=self.theme_manager.colors['dark']['fg'],
                            insertbackground=self.theme_manager.colors['dark']['fg'],
                            font=('Segoe UI', 10))
        name_entry.insert(0, item.get('name', ''))
        name_entry.pack(fill=tk.X, pady=(0, 5))

        text_label = tk.Label(content_frame, text="Texto del item:",
                            bg=self.theme_manager.colors['dark']['bg'],
                            fg=self.theme_manager.colors['dark']['fg'])
        text_label.pack(anchor='w', pady=(0, 5))

        text_entry = tk.Text(content_frame, height=3, bg=self.theme_manager.colors['dark']['button_bg'],
                            fg=self.theme_manager.colors['dark']['fg'],
                            insertbackground=self.theme_manager.colors['dark']['fg'],
                            font=('Segoe UI', 10))
        text_entry.insert(tk.END, text)
        text_entry.pack(fill=tk.BOTH, expand=True, pady=(0, 5))

        def save_item():
            new_name = name_entry.get().strip()
            new_text = text_entry.get("1.0", tk.END).strip()
            if new_text:
                item['name'] = new_name
                if new_text != text:
                    # Si el texto ha cambiado, eliminamos el formato
                    item['text'] = {'text': new_text, 'formatted': {}}
                else:
                    # Si el texto no ha cambiado, mantenemos el formato original
                    item['text'] = {'text': new_text, 'formatted': original_format}
                self.clipboard_manager.group_manager.save_groups()
                dialog.destroy()
                self.refresh_group_content(group_id)

        save_button = tk.Button(content_frame, text="Guardar", command=save_item,
                                bg=self.theme_manager.colors['dark']['button_bg'],
                                fg=self.theme_manager.colors['dark']['button_fg'])
        save_button.pack(fill=tk.X, pady=(0, 5))

        # C√≥digo para hacer la ventana arrastrable
        def start_move(event):
            dialog.x = event.x
            dialog.y = event.y

        def on_move(event):
            deltax = event.x - dialog.x
            deltay = event.y - dialog.y
            x = dialog.winfo_x() + deltax
            y = dialog.winfo_y() + deltay
            dialog.geometry(f"+{x}+{y}")

        title_frame.bind('<Button-1>', start_move)
        title_frame.bind('<B1-Motion>', on_move)

        # Funci√≥n para ajustar din√°micamente la altura de la ventana
        def adjust_dialog_height(event=None):
            content = text_entry.get("1.0", tk.END)
            lines = content.count('\n') + 1
            new_height = min(150 + (lines * 20), 600)
            dialog.geometry(f"300x{new_height}")

        text_entry.bind("<KeyRelease>", adjust_dialog_height)

        dialog.focus_set()
        name_entry.focus()

        adjust_dialog_height()

// Archivo: keys_groups_screen.py
# keys_groups_screen.py

from key_screen_config import ScreenKeyConfig
from enum import Enum
import logging

logger = logging.getLogger(__name__)

class GroupScreenAction(Enum):
    """Enumera las acciones disponibles en la pantalla de grupos"""
    NAVIGATE_UP = "up"
    NAVIGATE_DOWN = "down"
    NAVIGATE_LEFT = "left"
    NAVIGATE_RIGHT = "right"
    ACTIVATE = "return"
    ADD_GROUP = "alt+n"
    BACK_TO_MAIN = "escape"

class GroupsScreenKeyConfig(ScreenKeyConfig):
    def __init__(self, key_handler, manager):
        super().__init__(key_handler)
        self.manager = manager
        self.screen_name = "groups"
        self.actions = {}
        self.setup_keys()
        logger.debug("GroupsScreenKeyConfig initialized")

    def setup_keys(self) -> None:
        """Configura las teclas espec√≠ficas para la pantalla de grupos"""
        self.register_action(GroupScreenAction.NAVIGATE_UP, 
                           lambda: self.handle_navigation('up'))
        self.register_action(GroupScreenAction.NAVIGATE_DOWN, 
                           lambda: self.handle_navigation('down'))
        self.register_action(GroupScreenAction.NAVIGATE_LEFT, 
                           lambda: self.handle_navigation('left'))
        self.register_action(GroupScreenAction.NAVIGATE_RIGHT, 
                           lambda: self.handle_navigation('right'))
        self.register_action(GroupScreenAction.ACTIVATE, 
                           self.handle_activation)
        
        # Atajos adicionales espec√≠ficos de la pantalla de grupos
        self.register_action(GroupScreenAction.ADD_GROUP, 
                           self.manager.group_manager.add_group)
        self.register_action(GroupScreenAction.BACK_TO_MAIN, 
                           self.manager.show_main_screen)
        
        logger.debug("Groups screen keys setup completed")

    def register_action(self, action: GroupScreenAction, callback: callable) -> None:
        """Registra una acci√≥n con su callback correspondiente"""
        self.actions[action] = callback
        if isinstance(action.value, str):
            self.register_hotkey(action.value, callback)
        logger.debug(f"Registered action: {action.name}")

    def handle_navigation(self, direction: str) -> None:
        """Maneja los eventos de navegaci√≥n"""
        event = type('Event', (), {'keysym': direction.capitalize()})()
        
        # Actualizar el estado de selecci√≥n en el manager
        current_selection = self.manager.navigation.current_strategy.state['current_selection']
        self.manager.current_selection = current_selection
        
        if direction in ['up', 'down']:
            self.manager.navigation.navigate_vertical(event)
        else:
            self.manager.navigation.navigate_horizontal(event)
        logger.debug(f"Groups screen navigation: {direction}")

    def handle_activation(self):
        """Maneja la activaci√≥n del elemento seleccionado"""
        print("GroupsScreenKeyConfig: Handling activation")  # Debug
        self.manager.navigation.current_strategy.activate_selected()
        logger.debug("Groups screen item activated")

    def activate(self) -> None:
        """Activa la configuraci√≥n de teclas para la pantalla de grupos"""
        super().activate()
        for action, callback in self.actions.items():
            if isinstance(action.value, str) and action.value.startswith('alt+'):
                self.key_handler.global_hotkeys.register_hotkey(action.value, callback)
        logger.info("Groups screen key configuration activated")

    def deactivate(self) -> None:
        """Desactiva la configuraci√≥n de teclas de la pantalla de grupos"""
        super().deactivate()
        for action in self.actions:
            if isinstance(action.value, str) and action.value.startswith('alt+'):
                self.key_handler.global_hotkeys.unregister_hotkey(action.value)
        logger.info("Groups screen key configuration deactivated")

// Archivo: keys_main_screen.py
# main_screen_keys.py

from key_screen_config import ScreenKeyConfig
import logging

logger = logging.getLogger(__name__)

class MainScreenKeyConfig(ScreenKeyConfig):
    def __init__(self, key_handler, manager):
        super().__init__(key_handler)
        self.manager = manager

    def setup_keys(self):
        self.register_hotkey('up', lambda: self.handle_navigation('up'))
        self.register_hotkey('down', lambda: self.handle_navigation('down'))
        self.register_hotkey('left', lambda: self.handle_navigation('left'))
        self.register_hotkey('right', lambda: self.handle_navigation('right'))
        self.register_hotkey('return', self.handle_activation)
        logger.debug("Main screen keys setup completed")

    def handle_navigation(self, direction):
        if direction in ['up', 'down']:
            self.manager.navigation.navigate_vertical(type('Event', (), {'keysym': direction.capitalize()})())
        elif direction in ['left', 'right']:
            self.manager.navigation.navigate_horizontal(type('Event', (), {'keysym': direction.capitalize()})())
        logger.debug(f"Main screen navigation: {direction}")

    def handle_activation(self):
        self.manager.navigation.activate_selected()
        logger.debug("Main screen item activated")

// Archivo: key_handler.py
# key_handler.py
import keyboard
import win32gui
import win32api
import win32clipboard
import win32com.client
import win32con
import pyautogui
import pyperclip
import time
import logging
from typing import Dict, Callable, Optional

logger = logging.getLogger(__name__)

class GlobalHotkeyManager:
    """Maneja los atajos de teclado globales de la aplicaci√≥n"""
    
    def __init__(self):
        self._hotkeys: Dict[str, Callable] = {}
        keyboard.unhook_all()
    
    def register_hotkey(self, key: str, callback: Callable) -> None:
        """Registra un nuevo atajo global"""
        if key in self._hotkeys:
            keyboard.remove_hotkey(key)
        self._hotkeys[key] = callback
        keyboard.add_hotkey(key, callback)
        logger.debug(f"Registered global hotkey: {key}")
    
    def unregister_hotkey(self, key: str) -> None:
        """Elimina un atajo global"""
        if key in self._hotkeys:
            keyboard.remove_hotkey(key)
            del self._hotkeys[key]
            logger.debug(f"Unregistered global hotkey: {key}")
    
    def update_hotkey(self, old_key: Optional[str], new_key: str, callback: Callable) -> None:
        """Actualiza un atajo existente con una nueva tecla"""
        if old_key:
            self.unregister_hotkey(old_key)
        self.register_hotkey(new_key, callback)
        logger.debug(f"Updated hotkey from {old_key} to {new_key}")

class KeyHandler:
    """Coordinador principal del sistema de teclas"""
    
    def __init__(self, manager):
        self.manager = manager
        self.global_hotkeys = GlobalHotkeyManager()
        self.current_screen = 'main'
        # self.screen_specific_hotkeys: Dict[str, Dict[str, Callable]] = {}
        self.screen_specific_hotkeys = {}
        self.original_cursor_pos = None
        
        # Inicializar el hotkey principal
        self.setup_main_hotkey()
        
    def register_global_hotkey(self, key: str, callback: Callable) -> None:
        """Registra un atajo de teclado global"""
        self.global_hotkeys.register_hotkey(key, callback)
        
    def register_screen_hotkey(self, screen: str, key: str, callback: Callable) -> None:
        """Registra un atajo de teclado espec√≠fico para una pantalla"""
        if screen not in self.screen_specific_hotkeys:
            self.screen_specific_hotkeys[screen] = {}
        self.screen_specific_hotkeys[screen][key] = callback
        logger.debug(f"Registered screen hotkey: {key} for screen {screen}")

    def unregister_screen_hotkey(self, screen: str, key: str) -> None:
        """Elimina un atajo de teclado espec√≠fico de una pantalla"""
        if screen in self.screen_specific_hotkeys and key in self.screen_specific_hotkeys[screen]:
            del self.screen_specific_hotkeys[screen][key]
            logger.debug(f"Unregistered screen hotkey: {key} for screen {screen}")

    def set_current_screen(self, screen: str) -> None:
        """Establece la pantalla actual para manejar los atajos de teclado"""
        self.current_screen = screen
        logger.debug(f"Set current screen to: {screen}")

    def handle_key_press(self, event):
        """Maneja las pulsaciones de teclas"""
        print(f"KeyHandler received key: {event.keysym}")  # Debug
        key = event.keysym.lower()
        
        # Manejar teclas espec√≠ficas de la pantalla actual
        if self.current_screen in self.screen_specific_hotkeys:
            if key in self.screen_specific_hotkeys[self.current_screen]:
                print(f"Executing screen-specific handler for {key}")  # Debug
                self.screen_specific_hotkeys[self.current_screen][key]()
                return True
        
        # Propagar el evento a la estrategia de navegaci√≥n actual
        if self.manager.is_visible:
            self.manager.navigation.handle_keyboard_event(event)
            return True
        
        # Manejar teclas globales
        if key in self.global_hotkeys._hotkeys:
            print(f"Executing global handler for {key}")  # Debug
            self.global_hotkeys._hotkeys[key]()
            return True
            
        return False

    def setup_main_hotkey(self) -> None:
        """Configura el atajo principal de la aplicaci√≥n"""
        hotkey = self.manager.hotkey
        if not hotkey.lower().startswith('alt+'):
            hotkey = 'alt+' + hotkey
        self.global_hotkeys.register_hotkey(hotkey, self.toggle_window)
        
    def toggle_window(self) -> None:
        """Alterna la visibilidad de la ventana principal"""
        logger.debug("Toggling window")
        if not self.manager.is_visible:
            self.show_window()
        else:
            self.hide_window()
            
    def show_window(self) -> None:
        """Muestra la ventana principal"""
        try:
            self.manager.previous_window = win32gui.GetForegroundWindow()
            self.original_cursor_pos = win32gui.GetCursorPos()
            
            # Posicionar ventana
            mouse_x, mouse_y = pyautogui.position()
            window_x = mouse_x - self.manager.window_width // 2
            window_y = mouse_y - self.manager.window_height // 2
            
            # Ajustar a los l√≠mites de la pantalla
            screen_width, screen_height = pyautogui.size()
            window_x = max(0, min(window_x, screen_width - self.manager.window_width))
            window_y = max(0, min(window_y, screen_height - self.manager.window_height))
            
            self.manager.root.geometry(f"{self.manager.window_width}x{self.manager.window_height}+{window_x}+{window_y}")
            self.manager.window_x = window_x
            self.manager.window_y = window_y
            
            self._show_and_focus_window()
            
            # Inicializar el foco y la navegaci√≥n
            self.manager.navigation.initialize_focus()
            
        except Exception as e:
            logger.error(f"Error showing window: {e}")
            
    def _show_and_focus_window(self) -> None:
        """Muestra y enfoca la ventana principal"""
        self.manager.root.deiconify()
        self.manager.root.lift()
        self.manager.root.attributes('-topmost', True)
        self.manager.is_visible = True
        self.manager.navigation.initialize_focus()
        
        self.manager.canvas.update_idletasks()
        self.manager.canvas.configure(scrollregion=self.manager.canvas.bbox("all"))
        
        self.manager.root.update_idletasks()
        self.manager.root.after(100, lambda: self.manager.root.attributes('-topmost', False))
        self.manager.root.focus_force()

    def hide_window(self) -> None:
        """Oculta la ventana principal"""
        self.manager.root.withdraw()
        self.manager.is_visible = False
        self.restore_focus()
        if self.original_cursor_pos:
            win32api.SetCursorPos(self.original_cursor_pos)
            self.original_cursor_pos = None

    def restore_focus(self) -> None:
        """Restaura el foco a la ventana anterior"""
        if self.manager.previous_window:
            try:
                win32gui.SetForegroundWindow(self.manager.previous_window)
            except Exception as e:
                logger.error(f"Error restoring focus: {e}")
                try:
                    self.manager.root.after(100, lambda: win32gui.SetForegroundWindow(self.manager.previous_window))
                except:
                    pass

    def restore_cursor_position(self):
        if self.original_cursor_pos:
            win32api.SetCursorPos(self.original_cursor_pos)

    def paste_content(self, clipboard_data):
        try:
            self.hide_window()
            current_cursor_pos = win32gui.GetCursorPos()
            
            if isinstance(clipboard_data, dict):
                text = clipboard_data.get('text', '')
                format_info = clipboard_data.get('formatted', {})
            else:
                text = str(clipboard_data)
                format_info = {}

            if self.manager.paste_with_format and format_info:
                formatted_content = self.apply_format_to_text(text, format_info)
                win32clipboard.OpenClipboard()
                win32clipboard.EmptyClipboard()
                win32clipboard.SetClipboardData(win32con.CF_UNICODETEXT, formatted_content)
                win32clipboard.CloseClipboard()
            else:
                pyperclip.copy(text)
            
            time.sleep(0.05)
            
            if self.manager.previous_window:
                win32gui.SetForegroundWindow(self.manager.previous_window)
                time.sleep(0.05)
                
                win32api.SetCursorPos(current_cursor_pos)
                
                shell = win32com.client.Dispatch("WScript.Shell")
                shell.SendKeys("^v")
            
            self.original_cursor_pos = None
            
        except Exception as e:
            print(f"Error en el proceso de pegado: {e}")
        finally:
            if self.original_cursor_pos:
                win32api.SetCursorPos(self.original_cursor_pos)
            self.original_cursor_pos = None

    def apply_format_to_text(self, text, format_info):
        if 'rtf' in format_info:
            return self.apply_rtf_format(text, format_info)
        elif 'html' in format_info:
            return self.apply_html_format(text, format_info)
        else:
            return text

    def apply_rtf_format(self, text, format_info):
        rtf = r"{\rtf1\ansi\deff0"
        if format_info.get('font'):
            rtf += r"{\fonttbl{\f0\fnil " + format_info['font'] + r";}}"
        if format_info.get('color'):
            rtf += r"{\colortbl;\red" + str(format_info['color'][0]) + r"\green" + str(format_info['color'][1]) + r"\blue" + str(format_info['color'][2]) + r";}"
        rtf += r"\f0"
        if format_info.get('size'):
            rtf += r"\fs" + str(int(format_info['size'] * 2))
        if format_info.get('bold'):
            rtf += r"\b"
        if format_info.get('italic'):
            rtf += r"\i"
        rtf += " " + text.replace("\n", r"\par ") + r"}"
        return rtf

    def apply_html_format(self, text, format_info):
        html = "<div style='"
        if format_info.get('font'):
            html += f"font-family: {format_info['font']}; "
        if format_info.get('size'):
            html += f"font-size: {format_info['size']}pt; "
        if format_info.get('color'):
            html += f"color: rgb{format_info['color']}; "
        html += "'>"
        if format_info.get('bold'):
            html += "<strong>"
        if format_info.get('italic'):
            html += "<em>"
        html += text
        if format_info.get('italic'):
            html += "</em>"
        if format_info.get('bold'):
            html += "</strong>"
        html += "</div>"
        return html



// Archivo: key_screen_config.py
# screen_key_config.py

from abc import ABC, abstractmethod
import logging

logger = logging.getLogger(__name__)

class ScreenKeyConfig(ABC):
    def __init__(self, key_handler):
        self.key_handler = key_handler
        self.screen_name = self.__class__.__name__.lower().replace('keyconfig', '')
        self.hotkeys = {}

    @abstractmethod
    def setup_keys(self):
        """
        Configurar las teclas espec√≠ficas para esta pantalla.
        Debe ser implementado por cada subclase.
        """
        pass

    def register_hotkey(self, key, callback):
        """
        Registrar una tecla r√°pida para esta pantalla.
        """
        self.hotkeys[key] = callback
        self.key_handler.register_screen_hotkey(self.screen_name, key, callback)
        logger.debug(f"Registered hotkey '{key}' for screen '{self.screen_name}'")

    def unregister_all_hotkeys(self):
        """
        Desregistrar todas las teclas r√°pidas de esta pantalla.
        """
        for key in self.hotkeys:
            self.key_handler.unregister_screen_hotkey(self.screen_name, key)
        self.hotkeys.clear()
        logger.debug(f"Unregistered all hotkeys for screen '{self.screen_name}'")

    def activate(self):
        """
        Activar la configuraci√≥n de teclas para esta pantalla.
        """
        self.key_handler.set_current_screen(self.screen_name)
        self.setup_keys()
        logger.info(f"Activated key configuration for screen '{self.screen_name}'")

    def deactivate(self):
        """
        Desactivar la configuraci√≥n de teclas para esta pantalla.
        """
        self.unregister_all_hotkeys()
        logger.info(f"Deactivated key configuration for screen '{self.screen_name}'")

    @abstractmethod
    def handle_navigation(self, direction):
        """
        Manejar la navegaci√≥n en una direcci√≥n espec√≠fica.
        Debe ser implementado por cada subclase.
        """
        pass

    @abstractmethod
    def handle_activation(self):
        """
        Manejar la activaci√≥n del elemento seleccionado actualmente.
        Debe ser implementado por cada subclase.
        """
        pass

// Archivo: main.py
# main.py
import keyboard
import sys
import tkinter as tk
from structure import ClipboardManager

def main():
    root = tk.Tk()
    show_settings = "--show-settings" in sys.argv
    app = ClipboardManager(root, show_settings)
    # Aplicar las configuraciones iniciales
    root.geometry(f"{app.settings_manager.settings['width']}x{app.settings_manager.settings['height']}+0+0")
    
    # Configurar el atajo de teclado global
    app.key_handler.register_global_hotkey(app.hotkey, app.key_handler.toggle_window)
    
    # Configurar manejo de teclas para la ventana principal
    root.bind('<Key>', app.key_handler.handle_key_press)
    
    root.mainloop()

if __name__ == "__main__":
    main()

// Archivo: navigation.py

import logging
from typing import Dict, Optional, Any
from enum import Enum, auto
from navigation_main_screen import MainScreenNavigation
from navigation_groups_screen import GroupsScreenNavigation

logger = logging.getLogger(__name__)

class ScreenType(Enum):
    MAIN = auto()
    GROUPS = auto()
    SETTINGS = auto()

class Navigation:
    def __init__(self, manager):
        self.manager = manager
        self.strategies = {}
        self._initialize_strategies()
        self.current_strategy = None
        self.navigation_state = {'enabled': True}
        
        self.strategies: Dict[ScreenType, Any] = {
            ScreenType.MAIN: MainScreenNavigation(manager),
            ScreenType.GROUPS: GroupsScreenNavigation(manager),
        }
        self.current_strategy = self.strategies[ScreenType.MAIN]
        self.current_screen = ScreenType.MAIN
        logger.debug("Navigation initialized")
        
    def _initialize_strategies(self):
        """Inicializa las estrategias de navegaci√≥n con manejo de errores"""
        try:
            self.strategies = {
                ScreenType.MAIN: MainScreenNavigation(self.manager),
                ScreenType.GROUPS: GroupsScreenNavigation(self.manager)
            }
            self.set_strategy('main')
        except Exception as e:
            logger.error(f"Error initializing navigation strategies: {e}")
            raise

    def set_strategy(self, screen_type: str) -> None:
        """Cambia la estrategia de navegaci√≥n con verificaciones"""
        try:
            screen_mapping = {
                'main': ScreenType.MAIN,
                'groups': ScreenType.GROUPS,
                'settings': ScreenType.SETTINGS
            }
            
            if screen_type not in screen_mapping:
                raise ValueError(f"Invalid screen type: {screen_type}")

            screen_enum = screen_mapping[screen_type]
            if screen_enum in self.strategies:
                self.current_screen = screen_enum
                self.current_strategy = self.strategies[screen_enum]
                self._configure_screen_navigation(screen_enum)
                logger.debug(f"Navigation strategy set to: {screen_type}")
            else:
                raise ValueError(f"No strategy found for screen: {screen_type}")
        except Exception as e:
            logger.error(f"Error setting navigation strategy: {e}")
            self._fallback_to_main_strategy()
    
    def _fallback_to_main_strategy(self):
        """Sistema de recuperaci√≥n para casos de error"""
        try:
            logger.warning("Falling back to main navigation strategy")
            self.current_strategy = self.strategies['main']
            self.manager.show_main_screen()
        except Exception as e:
            logger.critical(f"Critical error in navigation fallback: {e}")

    def set_strategy(self, screen_type: str) -> None:
        """Cambia la estrategia de navegaci√≥n seg√∫n la pantalla"""
        screen_mapping = {
            'main': ScreenType.MAIN,
            'groups': ScreenType.GROUPS,
            'settings': ScreenType.SETTINGS
        }
        
        if screen_type not in screen_mapping:
            logger.error(f"Unknown screen type: {screen_type}")
            return
            
        screen_enum = screen_mapping[screen_type]
        if screen_enum in self.strategies:
            self.current_screen = screen_enum
            self.current_strategy = self.strategies[screen_enum]
            self._configure_screen_navigation(screen_enum)
            logger.debug(f"Navigation strategy set to: {screen_type}")
        else:
            logger.error(f"No strategy found for screen: {screen_type}")

    def _configure_screen_navigation(self, screen_type: ScreenType) -> None:
        """Configura la navegaci√≥n espec√≠fica para cada pantalla"""
        if screen_type == ScreenType.MAIN:
            self.manager.main_screen_keys.activate()
            if hasattr(self.manager, 'groups_screen_keys'):
                self.manager.groups_screen_keys.deactivate()
        elif screen_type == ScreenType.GROUPS:
            self.manager.main_screen_keys.deactivate()
            if hasattr(self.manager, 'groups_screen_keys'):
                self.manager.groups_screen_keys.activate()

    def handle_keyboard_event(self, event):
        """Maneja los eventos de teclado"""
        print(f"Navigation received keyboard event: {event.keysym}")  # Debug
        try:
            if not self.navigation_state['enabled']:
                return
                
            key = event.keysym.lower()
            print(f"Processing key: {key}")  # Debug
            
            # Manejar Enter expl√≠citamente
            if key == 'return':
                print("Enter key detected, activating selection")  # Debug
                self.current_strategy.activate_selected()  # Llamar directamente a la estrategia actual
                return
                
            # Resto de la navegaci√≥n
            if key in ['up', 'down']:
                self.navigate_vertical(event)
            elif key in ['left', 'right']:
                self.navigate_horizontal(event)
                
        except Exception as e:
            logger.error(f"Error handling keyboard event: {e}")
            
    def handle_escape(self) -> None:
        """Maneja la tecla Escape seg√∫n el contexto"""
        if self.current_screen != ScreenType.MAIN:
            self.manager.show_main_screen()
        else:
            self.manager.key_handler.hide_window()

    def navigate_vertical(self, event) -> None:
        """Gestiona la navegaci√≥n vertical"""
        logger.debug(f"Vertical navigation: {event.keysym}")
        self.current_strategy.navigate_vertical(event)
        self.update_highlights()
        self.ensure_visible()

    def navigate_horizontal(self, event) -> None:
        """Gestiona la navegaci√≥n horizontal"""
        logger.debug(f"Horizontal navigation: {event.keysym}")
        self.current_strategy.navigate_horizontal(event)
        self.update_highlights()

    def activate_selected(self, event=None) -> None:
        """Activa el elemento seleccionado actualmente"""
        logger.debug("Activating selected item")
        self.current_strategy.activate_selected(event)

    def update_highlights(self) -> None:
        """Actualiza los destacados visuales"""
        logger.debug("Updating highlights")
        self.current_strategy.update_highlights()

    def initialize_focus(self) -> None:
        """Inicializa el foco en la pantalla actual"""
        logger.debug("Initializing focus")
        self.current_strategy.initialize_focus()

    def ensure_visible(self) -> None:
        """Asegura que el elemento seleccionado est√© visible"""
        self.current_strategy.ensure_visible()
        logger.debug("Ensuring selected item visibility")

    def refresh_navigation(self) -> None:
        """Refresca el estado de navegaci√≥n actual"""
        logger.debug("Refreshing navigation")
        self.initialize_focus()
        self.update_highlights()
        if hasattr(self.current_strategy, 'refresh_view'):
            self.current_strategy.refresh_view()

    def get_current_selection(self) -> dict:
        """Obtiene la selecci√≥n actual"""
        return self.manager.current_selection

    def set_current_selection(self, selection_type: str, index: int) -> None:
        """Establece la selecci√≥n actual"""
        self.manager.current_selection = {'type': selection_type, 'index': index}
        self.update_highlights()
        logger.debug(f"Current selection set to: {self.manager.current_selection}")

    def get_cards_count(self) -> int:
        """Obtiene el n√∫mero de tarjetas en la vista actual"""
        return self.current_strategy.get_cards_count()

    def on_window_focus(self, event) -> None:
        """Maneja el evento de obtenci√≥n de foco de la ventana"""
        logger.debug("Window gained focus")
        self.refresh_navigation()

    def on_window_unfocus(self, event) -> None:
        """Maneja el evento de p√©rdida de foco de la ventana"""
        logger.debug("Window lost focus")
        # Implementar l√≥gica adicional si es necesario
        
    def check_window_state(self) -> None:
        """Verifica y corrige el estado de visibilidad de la ventana"""
        try:
            actual_visible = self.manager.root.winfo_viewable()
            if actual_visible != self.manager.is_visible:
                logger.info(f"Correcting visibility state: {self.manager.is_visible} -> {actual_visible}")
                self.manager.is_visible = actual_visible
        except Exception as e:
            logger.error(f"Error checking window state: {e}")
        
        # Programar la pr√≥xima verificaci√≥n
        self.manager.root.after(1000, self.check_window_state)

// Archivo: navigation_groups_screen.py
# navigation_groups_screen.py

from enum import Enum
from typing import List, Optional, Dict
import tkinter as tk
import logging

logger = logging.getLogger(__name__)

class GroupScreenElement(Enum):
    TOP_BUTTONS = "top_buttons"
    GROUP_CARDS = "group_cards"
    ICONS = "card_icons"

class GroupsScreenNavigation:
    def __init__(self, manager):
        self.manager = manager
        self.navigation_state = {'enabled': True}
        self.navigation_order = [
            GroupScreenElement.TOP_BUTTONS,
            GroupScreenElement.GROUP_CARDS
        ]
        self.current_element: Optional[GroupScreenElement] = None
        self.current_index: int = 0
        self.state: Dict = self._initialize_state()
        logger.debug("GroupsScreenNavigation initialized")

    def _initialize_state(self) -> Dict:
        """Inicializa el estado de navegaci√≥n"""
        return {
            'current_selection': {'type': 'group_cards', 'index': 0},
            'highlight_colors': {
                'dark': {'normal': '#444444', 'icon': '#666666'},
                'light': {'normal': '#cccccc', 'icon': '#aaaaaa'}
            }
        }

    def initialize_focus(self) -> None:
        """Inicializa el foco en la pantalla de grupos"""
        if self.get_cards_count() > 0:
            self.state['current_selection'] = {'type': 'group_cards', 'index': 0}
        else:
            self.state['current_selection'] = {'type': 'top_buttons', 'index': 0}
        
        self.navigation_state['enabled'] = True
        self.update_highlights()
        logger.debug(f"Groups focus initialized: {self.state['current_selection']}")

    def navigate_vertical(self, event) -> None:
        """Gestiona la navegaci√≥n vertical"""
        direction = 1 if event.keysym == 'Down' else -1
        self._update_selection_vertical(direction)
        self.update_highlights()
        self.ensure_visible()
        logger.debug(f"Vertical navigation: {event.keysym}")

    def _update_selection_vertical(self, direction: int) -> None:
        """Actualiza la selecci√≥n actual en direcci√≥n vertical"""
        current_type = self.state['current_selection']['type']
        current_index = self.state['current_selection']['index']

        if direction > 0:  # Down
            if current_type == GroupScreenElement.TOP_BUTTONS.value:
                if self.get_cards_count() > 0:
                    self.state['current_selection'] = {
                        'type': GroupScreenElement.GROUP_CARDS.value,
                        'index': 0
                    }
            elif current_type == GroupScreenElement.GROUP_CARDS.value:
                if current_index < self.get_cards_count() - 1:
                    self.state['current_selection']['index'] = current_index + 1
        else:  # Up
            if current_type == GroupScreenElement.GROUP_CARDS.value:
                if current_index > 0:
                    self.state['current_selection']['index'] = current_index - 1
                else:
                    self.state['current_selection'] = {
                        'type': GroupScreenElement.TOP_BUTTONS.value,
                        'index': 0
                    }

    def navigate_horizontal(self, event) -> None:
        """Gestiona la navegaci√≥n horizontal"""
        direction = 1 if event.keysym == 'Right' else -1
        self._update_selection_horizontal(direction)
        self.update_highlights()
        logger.debug(f"Horizontal navigation: {event.keysym}")

    def _update_selection_horizontal(self, direction: int) -> None:
        """Actualiza la selecci√≥n actual en direcci√≥n horizontal"""
        current_type = self.state['current_selection']['type']
        current_index = self.state['current_selection']['index']

        if direction > 0:  # Right
            if current_type == GroupScreenElement.TOP_BUTTONS.value:
                button_count = len(self.get_top_buttons())
                self.state['current_selection']['index'] = (current_index + 1) % button_count
            elif current_type == GroupScreenElement.GROUP_CARDS.value:
                self.state['current_selection'] = {
                    'type': GroupScreenElement.ICONS.value,
                    'index': current_index * 2  # Solo 2 iconos por tarjeta en grupos
                }
            elif current_type == GroupScreenElement.ICONS.value:
                if current_index % 2 < 1:  # Solo 2 iconos por tarjeta
                    self.state['current_selection']['index'] = current_index + 1
        else:  # Left
            if current_type == GroupScreenElement.TOP_BUTTONS.value:
                button_count = len(self.get_top_buttons())
                self.state['current_selection']['index'] = (current_index - 1) % button_count
            elif current_type == GroupScreenElement.ICONS.value:
                if current_index % 2 > 0:
                    self.state['current_selection']['index'] = current_index - 1
                else:
                    self.state['current_selection'] = {
                        'type': GroupScreenElement.GROUP_CARDS.value,
                        'index': current_index // 2
                    }

    def activate_selected(self, event=None) -> None:
        """Activa el elemento seleccionado actualmente"""
        current_type = self.state['current_selection']['type']
        current_index = self.state['current_selection']['index']

        actions = {
            GroupScreenElement.TOP_BUTTONS.value: self._activate_top_button,
            GroupScreenElement.GROUP_CARDS.value: self._activate_group_card,
            GroupScreenElement.ICONS.value: self._activate_icon
        }

        if handler := actions.get(current_type):
            handler(current_index)
            logger.debug(f"Activated {current_type} at index {current_index}")

    def update_highlights(self) -> None:
        """Actualiza los destacados visuales"""
        self._clear_all_highlights()
        self._highlight_current_selection()
        logger.debug("Highlights updated")

    def _clear_all_highlights(self) -> None:
        """Limpia todos los destacados visuales"""
        theme = self.manager.theme_manager.colors[
            'dark' if self.manager.is_dark_mode else 'light'
        ]
        base_color = theme['card_bg']
        button_color = theme['button_bg']

        # Limpiar botones superiores
        for button in self.get_top_buttons():
            button.configure(bg=button_color)

        # Limpiar tarjetas y sus iconos
        for card in self.manager.group_manager.groups_frame.winfo_children():
            self._reset_card_colors(card, base_color, button_color)

    def _highlight_card(self, card: tk.Frame, color: str) -> None:
        """Resalta una tarjeta espec√≠fica y sus elementos"""
        card.configure(bg=color)
        for child in card.winfo_children():
            if isinstance(child, tk.Frame):
                child.configure(bg=color)
                for subchild in child.winfo_children():
                    if isinstance(subchild, tk.Label):
                        subchild.configure(bg=color)
                    elif isinstance(subchild, tk.Button):
                        # No cambiar el color de los botones aqu√≠
                        # a menos que estemos en modo tarjeta
                        if self.state['current_selection']['type'] == GroupScreenElement.GROUP_CARDS.value:
                            subchild.configure(bg=color)
            elif isinstance(child, tk.Label):
                child.configure(bg=color)
            elif isinstance(child, tk.Button):
                if self.state['current_selection']['type'] == GroupScreenElement.GROUP_CARDS.value:
                    child.configure(bg=color)

    def _reset_card_colors(self, card: tk.Frame, base_color: str, button_color: str) -> None:
        """Resetea los colores de una tarjeta espec√≠fica y sus elementos"""
        card.configure(bg=base_color)
        for child in card.winfo_children():
            if isinstance(child, tk.Frame):
                child.configure(bg=base_color)
                for subchild in child.winfo_children():
                    if isinstance(subchild, tk.Label):
                        subchild.configure(bg=base_color)
                    elif isinstance(subchild, tk.Button):
                        subchild.configure(bg=button_color)
            elif isinstance(child, tk.Label):
                child.configure(bg=base_color)
            elif isinstance(child, tk.Button):
                child.configure(bg=button_color)
    
    def _highlight_current_selection(self) -> None:
        """Aplica el destacado al elemento actualmente seleccionado"""
        current_type = self.state['current_selection']['type']
        current_index = self.state['current_selection']['index']
        highlight_color = self._get_highlight_color()
        icon_highlight_color = self._get_icon_highlight_color()

        if current_type == GroupScreenElement.TOP_BUTTONS.value:
            buttons = self.get_top_buttons()
            if 0 <= current_index < len(buttons):
                buttons[current_index].configure(bg=highlight_color)

        elif current_type == GroupScreenElement.GROUP_CARDS.value:
            cards = self.get_group_cards()
            if current_index < len(cards):
                self._highlight_card(cards[current_index], highlight_color)

        elif current_type == GroupScreenElement.ICONS.value:
            cards = self.get_group_cards()
            card_index = current_index // 2
            icon_index = current_index % 2

            if card_index < len(cards):
                card = cards[card_index]
                # Resaltar la tarjeta completa
                self._highlight_card(card, highlight_color)

                # Resaltar el icono espec√≠fico
                icons_frame = self._find_icons_frame(card)
                if icons_frame:
                    # Primero resetear todos los iconos al color base
                    for icon in icons_frame.winfo_children():
                        icon.configure(bg=highlight_color)
                    
                    # Luego resaltar el icono seleccionado
                    if icon_index < len(icons_frame.winfo_children()):
                        icons_frame.winfo_children()[icon_index].configure(bg=icon_highlight_color)

        # Forzar la actualizaci√≥n visual
        self.manager.root.update_idletasks()
    
    def _get_highlight_color(self) -> str:
        """Obtiene el color de resaltado seg√∫n el tema actual"""
        theme_type = 'dark' if self.manager.is_dark_mode else 'light'
        return self.state['highlight_colors'][theme_type]['normal']

    def _get_icon_highlight_color(self) -> str:
        """Obtiene el color de resaltado para iconos seg√∫n el tema actual"""
        theme_type = 'dark' if self.manager.is_dark_mode else 'light'
        return self.state['highlight_colors'][theme_type]['icon']
    
    def _find_icons_frame(self, card: tk.Frame) -> Optional[tk.Frame]:
        """Encuentra el frame de iconos en una tarjeta"""
        for child in card.winfo_children():
            if isinstance(child, tk.Frame) and len(child.winfo_children()) > 0:
                if all(isinstance(btn, tk.Button) for btn in child.winfo_children()):
                    return child
        return None

    def _activate_top_button(self, index: int) -> None:
        """Activa un bot√≥n superior"""
        buttons = self.get_top_buttons()
        if 0 <= index < len(buttons):
            buttons[index].invoke()

    def _activate_group_card(self, index: int) -> None:
        """Activa una tarjeta de grupo"""
        groups = list(self.manager.group_manager.groups.items())
        if index < len(groups):
            group_id, _ = groups[index]
            self.manager.group_manager.show_group_content(group_id)

    def _activate_icon(self, index: int) -> None:
        """Activa un icono"""
        card_index = index // 2
        icon_index = index % 2
        groups = list(self.manager.group_manager.groups.items())
        
        if card_index < len(groups):
            group_id, _ = groups[card_index]
            actions = {
                0: lambda: self.manager.group_manager.edit_group(group_id),
                1: lambda: self.manager.group_manager.delete_group(group_id)
            }
            if action := actions.get(icon_index):
                action()

    def ensure_visible(self) -> None:
        """Asegura que el elemento seleccionado est√© visible"""
        current_type = self.state['current_selection']['type']
        if current_type in [GroupScreenElement.GROUP_CARDS.value, GroupScreenElement.ICONS.value]:
            current_index = self.state['current_selection']['index']
            card_index = current_index // 2 if current_type == GroupScreenElement.ICONS.value else current_index
            cards = self.get_group_cards()
            
            if card_index < len(cards):
                card = cards[card_index]
                bbox = self.manager.group_manager.canvas.bbox("all")
                if bbox:
                    card_y = card.winfo_y()
                    canvas_height = self.manager.group_manager.canvas.winfo_height()
                    if card_y > 0:
                        self.manager.group_manager.canvas.yview_moveto(card_y / bbox[3])

    def get_top_buttons(self) -> List[tk.Button]:
        """Obtiene los botones superiores"""
        return [
            self.manager.group_manager.add_button,
            self.manager.group_manager.close_button
        ]

    def get_group_cards(self) -> List[tk.Frame]:
        """Obtiene las tarjetas de grupo"""
        return self.manager.group_manager.groups_frame.winfo_children()

    def get_cards_count(self) -> int:
        """Obtiene el n√∫mero de tarjetas"""
        return len(self.manager.group_manager.groups)

    def refresh_view(self) -> None:
        """Refresca la vista de grupos"""
        self.manager.group_manager.refresh_groups()
        self.update_highlights()

// Archivo: navigation_main_screen.py
from enum import Enum
import logging
from typing import Optional, Callable, Dict
from key_screen_config import ScreenKeyConfig

logger = logging.getLogger(__name__)

class MainScreenAction(Enum):
    """Enumera las acciones disponibles en la pantalla principal"""
    NAVIGATE_UP = "up"
    NAVIGATE_DOWN = "down"
    NAVIGATE_LEFT = "left"
    NAVIGATE_RIGHT = "right"
    ACTIVATE = "return"
    TOGGLE_FORMAT = "alt+f"
    SHOW_GROUPS = "alt+g"
    CLEAR_HISTORY = "alt+c"

class MainScreenKeyConfig(ScreenKeyConfig):
    def __init__(self, key_handler, manager):
        super().__init__(key_handler)
        self.manager = manager
        self.screen_name = "main"
        self.actions: Dict[MainScreenAction, Callable] = {}
        self.setup_keys()
        logger.debug("MainScreenKeyConfig initialized")

    def setup_keys(self) -> None:
        """Configura las teclas espec√≠ficas para la pantalla principal"""
        self.register_action(MainScreenAction.NAVIGATE_UP, 
                           lambda: self.handle_navigation('up'))
        self.register_action(MainScreenAction.NAVIGATE_DOWN, 
                           lambda: self.handle_navigation('down'))
        self.register_action(MainScreenAction.NAVIGATE_LEFT, 
                           lambda: self.handle_navigation('left'))
        self.register_action(MainScreenAction.NAVIGATE_RIGHT, 
                           lambda: self.handle_navigation('right'))
        self.register_action(MainScreenAction.ACTIVATE, 
                           self.handle_activation)

        
        # Atajos adicionales espec√≠ficos de la pantalla principal
        self.register_action(MainScreenAction.TOGGLE_FORMAT, 
                           self.manager.functions.toggle_paste_format)
        self.register_action(MainScreenAction.SHOW_GROUPS, 
                           self.manager.show_groups)
        self.register_action(MainScreenAction.CLEAR_HISTORY, 
                           self.manager.functions.clear_history)
        
        logger.debug("Main screen keys setup completed")

    def register_action(self, action: MainScreenAction, callback: Callable) -> None:
        """Registra una acci√≥n con su callback correspondiente"""
        self.actions[action] = callback
        if isinstance(action.value, str):
            self.register_hotkey(action.value, callback)
        logger.debug(f"Registered action: {action.name}")

    def handle_navigation(self, direction: str) -> None:
        """Maneja los eventos de navegaci√≥n"""
        event = type('Event', (), {'keysym': direction.capitalize()})()
        
        # Actualizar el estado de selecci√≥n en el manager
        current_selection = self.manager.navigation.current_strategy.state['current_selection']
        self.manager.current_selection = current_selection
        
        if direction in ['up', 'down']:
            self.manager.navigation.navigate_vertical(event)
        else:
            self.manager.navigation.navigate_horizontal(event)
        logger.debug(f"Main screen navigation: {direction}")
        
    def handle_activation(self):
        """Maneja la activaci√≥n del elemento seleccionado"""
        print("MainScreenKeyConfig: Handling activation")  # Debug
        self.manager.navigation.current_strategy.activate_selected()
        logger.debug("Main screen item activated")

    def activate(self) -> None:
        """Activa la configuraci√≥n de teclas para la pantalla principal"""
        super().activate()
        for action, callback in self.actions.items():
            if isinstance(action.value, str) and action.value.startswith('alt+'):
                self.key_handler.global_hotkeys.register_hotkey(action.value, callback)
        logger.info("Main screen key configuration activated")

    def deactivate(self) -> None:
        """Desactiva la configuraci√≥n de teclas de la pantalla principal"""
        super().deactivate()
        for action in self.actions:
            if isinstance(action.value, str) and action.value.startswith('alt+'):
                self.key_handler.global_hotkeys.unregister_hotkey(action.value)
        logger.info("Main screen key configuration deactivated")
# navigation_main_screen.py

from enum import Enum
from typing import List, Optional, Dict
import tkinter as tk
import logging

logger = logging.getLogger(__name__)

class MainScreenElement(Enum):
    TOP_BUTTONS = "top_buttons"
    MAIN_BUTTONS = "main_buttons"
    CARDS = "cards"
    ICONS = "icons"

class MainScreenNavigation:
    def __init__(self, manager):
        self.manager = manager
        self.navigation_state = {'enabled': True}
        self.navigation_order = [
            MainScreenElement.TOP_BUTTONS,
            MainScreenElement.MAIN_BUTTONS,
            MainScreenElement.CARDS
        ]
        self.current_element: Optional[MainScreenElement] = None
        self.current_index: int = 0
        self.state: Dict = self._initialize_state()
        logger.debug("MainScreenNavigation initialized")

    def _initialize_state(self) -> Dict:
        """Inicializa el estado de navegaci√≥n"""
        return {
            'current_selection': {'type': 'main_buttons', 'index': 0},
            'highlight_colors': {
                'dark': {'normal': '#444444', 'icon': '#666666'},
                'light': {'normal': '#cccccc', 'icon': '#aaaaaa'}
            }
        }
        
    def initialize_focus(self):
        """Inicializa el foco en la pantalla principal"""
        if self.get_cards_count() > 0:
            self.state['current_selection'] = {'type': 'cards', 'index': 0}
        else:
            self.state['current_selection'] = {'type': 'main_buttons', 'index': 0}
        
        self.navigation_state['enabled'] = True 
        self.update_highlights()
        logger.debug(f"Main screen focus initialized: {self.state['current_selection']}")

    def navigate_vertical(self, event) -> None:
        """Gestiona la navegaci√≥n vertical"""
        direction = 1 if event.keysym == 'Down' else -1
        self._update_selection_vertical(direction)
        self.update_highlights()
        self.ensure_visible()
        logger.debug(f"Vertical navigation: {event.keysym}")

    def _update_selection_vertical(self, direction: int) -> None:
        """Actualiza la selecci√≥n actual en direcci√≥n vertical"""
        current_type = self.state['current_selection']['type']
        current_index = self.state['current_selection']['index']
        
        print(f"Before navigation: type={current_type}, index={current_index}")  # Debug

        if direction > 0:  # Down
            if current_type == MainScreenElement.TOP_BUTTONS.value:
                self.state['current_selection'] = {
                    'type': MainScreenElement.MAIN_BUTTONS.value,
                    'index': 0
                }
            elif current_type == MainScreenElement.MAIN_BUTTONS.value:
                if self.get_cards_count() > 0:
                    self.state['current_selection'] = {
                        'type': MainScreenElement.CARDS.value,
                        'index': 0
                    }
            elif current_type == MainScreenElement.CARDS.value:
                if current_index < self.get_cards_count() - 1:
                    self.state['current_selection']['index'] = current_index + 1
        else:  # Up
            if current_type == MainScreenElement.CARDS.value:
                if current_index > 0:
                    self.state['current_selection']['index'] = current_index - 1
                else:
                    self.state['current_selection'] = {
                        'type': MainScreenElement.MAIN_BUTTONS.value,
                        'index': 0
                    }
            elif current_type == MainScreenElement.MAIN_BUTTONS.value:
                self.state['current_selection'] = {
                    'type': MainScreenElement.TOP_BUTTONS.value,
                    'index': 0
                }
        
        print(f"After navigation: type={self.state['current_selection']['type']}, index={self.state['current_selection']['index']}")  # Debug
        
        # Actualizar visualizaci√≥n
        self.update_highlights()
        self.ensure_visible()
    
    def navigate_horizontal(self, event) -> None:
        """Gestiona la navegaci√≥n horizontal"""
        print(f"MainScreenNavigation: Navigating horizontally {event.keysym}")  # Debug
        direction = 1 if event.keysym == 'Right' else -1
        self._update_selection_horizontal(direction)
        self.update_highlights()
        logger.debug(f"Horizontal navigation: {event.keysym}")

    def get_button_count(self, button_type: str) -> int:
        """Obtiene el n√∫mero de botones seg√∫n el tipo"""
        if button_type == MainScreenElement.TOP_BUTTONS.value:
            return 3  # theme_button, clear_button, close_button
        elif button_type == MainScreenElement.MAIN_BUTTONS.value:
            return 3  # button1, button2, button3
        return 0

    def _update_selection_horizontal(self, direction: int) -> None:
        """Actualiza la selecci√≥n actual en direcci√≥n horizontal"""
        current_type = self.state['current_selection']['type']
        current_index = self.state['current_selection']['index']
        
        print(f"Horizontal navigation - Before: type={current_type}, index={current_index}")  # Debug

        if direction > 0:  # Right
            if current_type in [MainScreenElement.TOP_BUTTONS.value, 
                            MainScreenElement.MAIN_BUTTONS.value]:
                button_count = self.get_button_count(current_type)
                self.state['current_selection']['index'] = (current_index + 1) % button_count
            elif current_type == MainScreenElement.CARDS.value:
                self.state['current_selection'] = {
                    'type': MainScreenElement.ICONS.value,
                    'index': current_index * 3
                }
            elif current_type == MainScreenElement.ICONS.value:
                if current_index % 3 < 2:  # Si no es el √∫ltimo icono
                    self.state['current_selection']['index'] = current_index + 1
        else:  # Left
            if current_type in [MainScreenElement.TOP_BUTTONS.value, 
                            MainScreenElement.MAIN_BUTTONS.value]:
                button_count = self.get_button_count(current_type)
                self.state['current_selection']['index'] = (current_index - 1) % button_count
            elif current_type == MainScreenElement.ICONS.value:
                if current_index % 3 > 0:  # Si no es el primer icono
                    self.state['current_selection']['index'] = current_index - 1
                else:
                    self.state['current_selection'] = {
                        'type': MainScreenElement.CARDS.value,
                        'index': current_index // 3
                    }
        
        print(f"Horizontal navigation - After: type={self.state['current_selection']['type']}, index={self.state['current_selection']['index']}")  # Debug
        
        # Actualizar visualizaci√≥n
        self.update_highlights()

    def activate_selected(self, event=None):
        """Activa el elemento seleccionado actualmente"""
        print(f"MainScreenNavigation: Attempting to activate selection")  # Debug
        print(f"Current selection state: {self.state['current_selection']}")  # Debug
        
        current_type = self.state['current_selection']['type']
        current_index = self.state['current_selection']['index']
        
        print(f"Activating: {current_type} at index {current_index}")  # Debug

        # Mapeo de tipos a funciones de activaci√≥n
        actions = {
            'main_buttons': self._activate_main_button,
            'top_buttons': self._activate_top_button,
            'cards': self._activate_card,
            'icons': self._activate_icon
        }

        if handler := actions.get(current_type):
            print(f"Executing handler for {current_type}")  # Debug
            handler(current_index)
        else:
            print(f"No handler found for type: {current_type}")  # Debug
            
    def update_highlights(self) -> None:
        """Actualiza los destacados visuales"""
        print("Updating highlights")  # Debug
        self._clear_all_highlights()
        
        current_type = self.state['current_selection']['type']
        current_index = self.state['current_selection']['index']
        highlight_color = self._get_highlight_color()
        icon_highlight_color = self._get_icon_highlight_color()
        
        if current_type == MainScreenElement.MAIN_BUTTONS.value:
            buttons = [self.manager.button1, self.manager.button2, self.manager.button3]
            if 0 <= current_index < len(buttons):
                buttons[current_index].configure(bg=highlight_color)
        
        elif current_type == MainScreenElement.TOP_BUTTONS.value:
            buttons = [self.manager.theme_button, self.manager.clear_button, self.manager.close_button]
            if 0 <= current_index < len(buttons):
                buttons[current_index].configure(bg=highlight_color)
        
        elif current_type == MainScreenElement.CARDS.value:
            cards = self.manager.cards_frame.winfo_children()
            if current_index < len(cards):
                self._highlight_card(cards[current_index], highlight_color)
        
        elif current_type == MainScreenElement.ICONS.value:
            card_index = current_index // 3
            icon_position = current_index % 3
            cards = self.manager.cards_frame.winfo_children()
            
            if card_index < len(cards):
                card = cards[card_index]
                icons_frame = self._find_icons_frame(card)
                
                if icons_frame and icon_position < len(icons_frame.winfo_children()):
                    self._highlight_card(card, highlight_color)
                    icons = icons_frame.winfo_children()
                    if 0 <= icon_position < len(icons):
                        icons[icon_position].configure(bg=icon_highlight_color)
        
        self.manager.root.update_idletasks()
        self.manager.root.after(10, self.manager.root.update)

    def handle_specific_keys(self, event) -> None:
        """Maneja teclas espec√≠ficas de la pantalla principal"""
        key_handlers = {
            'f5': self.refresh_view,
            'escape': self.manager.key_handler.hide_window
        }
        
        handler = key_handlers.get(event.keysym.lower())
        if handler:
            handler()
            
    def _move_up(self, current_type: str, current_index: int) -> None:
        """Maneja el movimiento hacia arriba"""
        if current_type in [MainScreenElement.CARDS.value, MainScreenElement.ICONS.value]:
            if current_index > 0:
                self.state['current_selection']['index'] = current_index - 1
            else:
                self.state['current_selection'] = {
                    'type': MainScreenElement.MAIN_BUTTONS.value, 
                    'index': 0
                }
        elif current_type == MainScreenElement.MAIN_BUTTONS.value:
            self.state['current_selection'] = {
                'type': MainScreenElement.TOP_BUTTONS.value, 
                'index': 0
            }
        logger.debug(f"Moved up to {self.state['current_selection']}")

    def _move_down(self, current_type: str, current_index: int) -> None:
        """Maneja el movimiento hacia abajo"""
        if current_type == MainScreenElement.TOP_BUTTONS.value:
            self.state['current_selection'] = {
                'type': MainScreenElement.MAIN_BUTTONS.value, 
                'index': 0
            }
        elif current_type == MainScreenElement.MAIN_BUTTONS.value:
            if self.get_cards_count() > 0:
                self.state['current_selection'] = {
                    'type': MainScreenElement.CARDS.value, 
                    'index': 0
                }
        elif current_type == MainScreenElement.CARDS.value:
            if current_index < self.get_cards_count() - 1:
                self.state['current_selection']['index'] = current_index + 1
        logger.debug(f"Moved down to {self.state['current_selection']}")

    def _move_left(self, current_type: str, current_index: int) -> None:
        """Maneja el movimiento hacia la izquierda"""
        if current_type in [MainScreenElement.TOP_BUTTONS.value, 
                        MainScreenElement.MAIN_BUTTONS.value]:
            button_count = self.get_button_count(current_type)
            self.state['current_selection']['index'] = (current_index - 1) % button_count
        elif current_type == MainScreenElement.ICONS.value:
            if current_index % 3 > 0:
                self.state['current_selection']['index'] = current_index - 1
            else:
                self.state['current_selection'] = {
                    'type': MainScreenElement.CARDS.value,
                    'index': current_index // 3
                }
        logger.debug(f"Moved left to {self.state['current_selection']}")

    def _move_right(self, current_type: str, current_index: int) -> None:
        """Maneja el movimiento hacia la derecha"""
        if current_type in [MainScreenElement.TOP_BUTTONS.value, 
                        MainScreenElement.MAIN_BUTTONS.value]:
            button_count = self.get_button_count(current_type)
            self.state['current_selection']['index'] = (current_index + 1) % button_count
        elif current_type == MainScreenElement.CARDS.value:
            self.state['current_selection'] = {
                'type': MainScreenElement.ICONS.value,
                'index': current_index * 3
            }
        elif current_type == MainScreenElement.ICONS.value:
            if current_index % 3 < 2:
                self.state['current_selection']['index'] = current_index + 1
        logger.debug(f"Moved right to {self.state['current_selection']}")

    def _activate_main_button(self, index: int) -> None:
        """Activa un bot√≥n principal"""
        actions = {
            0: ('groups', self.manager.show_groups),
            1: ('format', self.manager.functions.toggle_paste_format),
            2: ('clear', self.manager.functions.clear_history)
        }
        if action := actions.get(index):
            action_name, action_func = action
            action_func()
            logger.debug(f"Activated main button '{action_name}' at index {index}")
    
    def _activate_top_button(self, index: int) -> None:
        """Activa un bot√≥n superior"""
        actions = {
            0: ('theme', self.manager.theme_manager.toggle_theme),
            1: ('settings', self.manager.show_settings),
            2: ('exit', self.manager.functions.exit_app)
        }
        if action := actions.get(index):
            action_name, action_func = action
            action_func()
            logger.debug(f"Activated top button '{action_name}' at index {index}")
            
    def _activate_card(self, index: int) -> None:
        """Activa una tarjeta (pegar contenido)"""
        items = list(self.manager.clipboard_items.items())
        if index < len(items):
            item_id, item_data = items[index]
            clipboard_data = item_data['text']
            self.manager.key_handler.paste_content(clipboard_data)
            logger.debug(f"Activated card at index {index}")

    def _activate_icon(self, index):
        """Activa un icono de tarjeta"""
        print(f"Activating icon at index {index}")  # Debug
        items = list(self.manager.clipboard_items.keys())
        card_index = index // 3
        icon_position = index % 3
        
        print(f"Card index: {card_index}, Icon position: {icon_position}")  # Debug
        
        if card_index < len(items):
            item_id = items[card_index]
            actions = {
                0: ('arrow', lambda: self.manager.functions.on_arrow_click(item_id)),
                1: ('pin', lambda: self.manager.functions.toggle_pin(item_id)),
                2: ('delete', lambda: self.manager.functions.delete_item(item_id))
            }
            
            if action := actions.get(icon_position):
                action_name, action_func = action
                print(f"Executing {action_name} action for icon")  # Debug
                action_func()
            else:
                print(f"No action found for icon position {icon_position}")  # Debug
                    
    def get_cards_count(self) -> int:
        """Obtiene el n√∫mero de tarjetas en la pantalla principal"""
        return len(self.manager.cards_frame.winfo_children())
    
    
    def _get_highlight_color(self) -> str:
        """Obtiene el color de resaltado seg√∫n el tema actual"""
        theme_type = 'dark' if self.manager.is_dark_mode else 'light'
        return self.state['highlight_colors'][theme_type]['normal']

    def _get_icon_highlight_color(self) -> str:
        """Obtiene el color de resaltado para iconos seg√∫n el tema actual"""
        theme_type = 'dark' if self.manager.is_dark_mode else 'light'
        return self.state['highlight_colors'][theme_type]['icon']

    def _highlight_current_selection(self) -> None:
        """Aplica el destacado al elemento actualmente seleccionado"""
        current_type = self.state['current_selection']['type']
        current_index = self.state['current_selection']['index']
        highlight_color = self._get_highlight_color()
        icon_highlight_color = self._get_icon_highlight_color()

        if current_type == MainScreenElement.MAIN_BUTTONS.value:
            buttons = [
                self.manager.button1,
                self.manager.button2,
                self.manager.button3
            ]
            if 0 <= current_index < len(buttons):
                buttons[current_index].configure(bg=highlight_color)
        
        elif current_type == MainScreenElement.TOP_BUTTONS.value:
            buttons = [
                self.manager.theme_button,
                self.manager.clear_button,
                self.manager.close_button
            ]
            if 0 <= current_index < len(buttons):
                buttons[current_index].configure(bg=highlight_color)
        
        elif current_type == MainScreenElement.CARDS.value:
            cards = self.manager.cards_frame.winfo_children()
            if current_index < len(cards):
                self._highlight_card(cards[current_index], highlight_color)
        
        elif current_type == MainScreenElement.ICONS.value:
            cards = self.manager.cards_frame.winfo_children()
            card_index = current_index // 3
            icon_index = current_index % 3
            
            if card_index < len(cards):
                card = cards[card_index]
                # Resaltar la tarjeta completa
                self._highlight_card(card, highlight_color)
                
                # Resaltar el icono espec√≠fico
                icons_frame = self._find_icons_frame(card)
                if icons_frame and icon_index < len(icons_frame.winfo_children()):
                    # Resetear el color de todos los iconos primero
                    for icon in icons_frame.winfo_children():
                        icon.configure(bg=highlight_color)
                    # Resaltar el icono seleccionado
                    icons_frame.winfo_children()[icon_index].configure(bg=icon_highlight_color)

    def _highlight_card(self, card: tk.Frame, color: str) -> None:
        """Resalta una tarjeta espec√≠fica y sus elementos"""
        card.configure(bg=color)
        for child in card.winfo_children():
            if isinstance(child, tk.Frame):
                child.configure(bg=color)
                for subchild in child.winfo_children():
                    if isinstance(subchild, tk.Label):
                        subchild.configure(bg=color)
                    elif isinstance(subchild, tk.Button):
                        # No cambiar el color de los botones aqu√≠
                        # a menos que estemos en modo tarjeta
                        if self.state['current_selection']['type'] == MainScreenElement.CARDS.value:
                            subchild.configure(bg=color)
            elif isinstance(child, tk.Label):
                child.configure(bg=color)
            elif isinstance(child, tk.Button):
                if self.state['current_selection']['type'] == MainScreenElement.CARDS.value:
                    child.configure(bg=color)

    def _find_icons_frame(self, card: tk.Frame) -> Optional[tk.Frame]:
        """Encuentra el frame que contiene los iconos en una tarjeta"""
        for child in card.winfo_children():
            if isinstance(child, tk.Frame) and len(child.winfo_children()) > 0:
                if all(isinstance(btn, tk.Button) for btn in child.winfo_children()):
                    return child
        return None

    def _clear_all_highlights(self) -> None:
        """Limpia todos los destacados visuales"""
        theme = self.manager.theme_manager.colors['dark' if self.manager.is_dark_mode else 'light']
        base_color = theme['card_bg']
        button_color = theme['button_bg']
        
        # Limpiar botones superiores
        top_buttons = [
            self.manager.theme_button,
            self.manager.clear_button,
            self.manager.close_button
        ]
        for button in top_buttons:
            button.configure(bg=button_color)
        
        # Limpiar botones principales
        main_buttons = [
            self.manager.button1,
            self.manager.button2,
            self.manager.button3
        ]
        for button in main_buttons:
            button.configure(bg=button_color)
        
        # Limpiar tarjetas y sus iconos
        for card in self.manager.cards_frame.winfo_children():
            self._reset_card_colors(card, base_color, button_color)

    def _reset_card_colors(self, card: tk.Frame, base_color: str, button_color: str) -> None:
        """Resetea los colores de una tarjeta espec√≠fica y sus elementos"""
        card.configure(bg=base_color)
        for child in card.winfo_children():
            if isinstance(child, tk.Frame):
                child.configure(bg=base_color)
                for subchild in child.winfo_children():
                    if isinstance(subchild, tk.Label):
                        subchild.configure(bg=base_color)
                    elif isinstance(subchild, tk.Button):
                        subchild.configure(bg=button_color)
            elif isinstance(child, tk.Label):
                child.configure(bg=base_color)
            elif isinstance(child, tk.Button):
                child.configure(bg=button_color)

    def update_highlights(self) -> None:
        """Actualiza los destacados visuales"""
        print("Updating highlights")  # Debug
        self._clear_all_highlights()
        self._highlight_current_selection()
        
        # Forzar la actualizaci√≥n visual
        self.manager.root.update_idletasks()
    
    def ensure_visible(self) -> None:
        """Asegura que el elemento seleccionado est√© visible"""
        current_type = self.state['current_selection']['type']
        current_index = self.state['current_selection']['index']
        
        if current_type == 'cards':
            cards = self.manager.cards_frame.winfo_children()
            if current_index < len(cards):
                card = cards[current_index]
                bbox = self.manager.canvas.bbox("all")
                if bbox:
                    card_y = card.winfo_y()
                    canvas_height = self.manager.canvas.winfo_height()
                    if card_y > 0:
                        self.manager.canvas.yview_moveto(card_y / bbox[3])
    
    def _handle_activation(self):
        """Maneja espec√≠ficamente la activaci√≥n por Enter"""
        print("Handling Enter activation")  # Debug
        current_type = self.state['current_selection']['type']
        current_index = self.state['current_selection']['index']
        
        print(f"Activating: type={current_type}, index={current_index}")  # Debug
        
        activation_map = {
            'main_buttons': self._activate_main_button,
            'top_buttons': self._activate_top_button,
            'cards': self._activate_card,
            'icons': self._activate_icon
        }
        
        if handler := activation_map.get(current_type):
            handler(current_index)
            print(f"Activation handler executed for {current_type}")  # Debug
        else:
            print(f"No activation handler found for {current_type}")  # Debug

// Archivo: navigation_strategies.py
# navigation_strategies.py

from abc import ABC, abstractmethod

class NavigationStrategy(ABC):
    @abstractmethod
    def navigate_vertical(self, event):
        pass

    @abstractmethod
    def navigate_horizontal(self, event):
        pass

    @abstractmethod
    def activate_selected(self, event=None):
        pass

    @abstractmethod
    def update_highlights(self):
        pass

    @abstractmethod
    def initialize_focus(self):
        pass

# Nota: Las implementaciones concretas de MainScreenNavigation, GroupsScreenNavigation,
# y SettingsScreenNavigation ahora est√°n en archivos separados.

// Archivo: settings_manager.py
# settings_manager.py

import json
import os
import sys
import tkinter as tk
from tkinter import ttk

class SettingsManager:
    def __init__(self, master, clipboard_manager):
        self.master = master
        self.clipboard_manager = clipboard_manager
        self.settings_window = None
        self.settings = None      
          
    def initialize_settings(self):
        # Llama a este m√©todo despu√©s de que ClipboardManager haya inicializado completamente
        self.settings = self.clipboard_manager.settings
        
    def save_settings(self):
        groups, pinned_items, _ = self.clipboard_manager.data_manager.load_data()
        self.clipboard_manager.data_manager.save_data(groups, pinned_items, self.settings)
        
    def show_settings_window(self):
        if self.settings_window is None or not self.settings_window.winfo_exists():
            self.settings_window = tk.Toplevel(self.master)
            self.settings_window.title("Configuraciones")
            
            window_width = self.settings['width']
            window_height = self.settings['height']

            # Usa las coordenadas de la ventana principal o una posici√≥n predeterminada
            x = getattr(self.clipboard_manager, 'window_x', 0) 
            y = getattr(self.clipboard_manager, 'window_y', 0)
            
            self.settings_window.geometry(f"{window_width}x{window_height}+{x}+{y}")
            
            self.settings_window.overrideredirect(True)
            self.settings_window.configure(bg=self.clipboard_manager.theme_manager.colors['dark']['bg'])
            self.settings_window.attributes('-topmost', True)

            # Barra de t√≠tulo personalizada
            title_frame = tk.Frame(self.settings_window, bg=self.clipboard_manager.theme_manager.colors['dark']['bg'])
            title_frame.pack(fill=tk.X, padx=6, pady=(0, 0))

            title_label = tk.Label(title_frame, text="Configuraciones", font=('Segoe UI', 10, 'bold'), 
                                   bg=self.clipboard_manager.theme_manager.colors['dark']['bg'], 
                                   fg=self.clipboard_manager.theme_manager.colors['dark']['fg'])
            title_label.pack(side=tk.LEFT, padx=5)

            close_button = tk.Button(title_frame, text="‚ùå", command=self.close_settings_window, 
                                     font=('Segoe UI', 10, 'bold'), bd=0, padx=10, width=5, height=2,
                                     bg=self.clipboard_manager.theme_manager.colors['dark']['button_bg'],
                                     fg=self.clipboard_manager.theme_manager.colors['dark']['button_fg'])
            close_button.pack(side=tk.RIGHT)

            # Canvas para scroll y contenedor de configuraciones
            canvas = tk.Canvas(self.settings_window, bg=self.clipboard_manager.theme_manager.colors['dark']['bg'], bd=0, highlightthickness=0)
            canvas.pack(fill=tk.BOTH, expand=True, padx=2, pady=2)

            # Scrollbar oculto
            scrollbar = ttk.Scrollbar(self.settings_window, orient=tk.VERTICAL, command=canvas.yview)
            canvas.configure(yscrollcommand=scrollbar.set)

            # Frame contenedor dentro del canvas para el scroll
            self.settings_frame = tk.Frame(canvas, bg=self.clipboard_manager.theme_manager.colors['dark']['bg'])
            canvas_window = canvas.create_window((0, 0), window=self.settings_frame, anchor='nw', width=295)

            # Ajustar el ancho del frame contenedor al canvas
            def on_canvas_resize(event):
                canvas.itemconfig(canvas_window, width=event.width)

            canvas.bind("<Configure>", on_canvas_resize)

            # Configuraci√≥n de scroll
            def on_frame_configure(event):
                canvas.configure(scrollregion=canvas.bbox("all"))

            self.settings_frame.bind("<Configure>", on_frame_configure)

            # Funci√≥n para desplazamiento con la rueda del mouse
            def _on_mousewheel(event):
                canvas.yview_scroll(int(-1*(event.delta/120)), "units")

            canvas.bind_all("<MouseWheel>", _on_mousewheel)

            # Crear cards de configuraci√≥n
            subtitle = tk.Label(self.settings_frame, text="Tecla de activaci√≥n", 
                        font=('Segoe UI', 10, 'bold'),
                        bg=self.clipboard_manager.theme_manager.colors['dark']['bg'],
                        fg=self.clipboard_manager.theme_manager.colors['dark']['fg'],
                        anchor='w')
            subtitle.pack(fill=tk.X, padx=4, pady=(10, 5), anchor='w')
            self.create_setting_card("Alt+", self.settings['hotkey'])
            
            subtitle = tk.Label(self.settings_frame, text="Dimensiones de la app", 
                        font=('Segoe UI', 10, 'bold'),
                        bg=self.clipboard_manager.theme_manager.colors['dark']['bg'],
                        fg=self.clipboard_manager.theme_manager.colors['dark']['fg'],
                        anchor='w')
            subtitle.pack(fill=tk.X, padx=4, pady=(10, 5), anchor='w')
            self.create_setting_card("Alto", str(self.settings['height']))
            self.create_setting_card("Ancho", str(self.settings['width']))

            # Hacer la ventana arrastrable
            title_label.bind('<Button-1>', self.start_move)
            title_label.bind('<B1-Motion>', self.on_move)

        else:
            self.settings_window.lift()
            self.settings_window.attributes('-topmost', True)
            self.settings_window.after_idle(self.settings_window.attributes, '-topmost', False)

    def create_setting_card(self, setting_name, default_value):
        card = tk.Frame(self.settings_frame, bg=self.clipboard_manager.theme_manager.colors['dark']['card_bg'])
        card.pack(fill=tk.X, padx=4, pady=2)

        label = tk.Label(card, text=f"{setting_name}: {default_value}", 
                         bg=self.clipboard_manager.theme_manager.colors['dark']['card_bg'],
                         fg=self.clipboard_manager.theme_manager.colors['dark']['fg'],
                         anchor='w', padx=5, pady=5)
        label.pack(side=tk.LEFT, fill=tk.X, expand=True)

        edit_button = tk.Button(card, text="‚úèÔ∏è", 
                                command=lambda: self.toggle_edit_mode(card, label, edit_button, setting_name, default_value),
                                font=('Segoe UI', 10), bd=0,
                                bg=self.clipboard_manager.theme_manager.colors['dark']['button_bg'],
                                fg=self.clipboard_manager.theme_manager.colors['dark']['button_fg'])
        edit_button.pack(side=tk.RIGHT, padx=2, pady=2)

    def toggle_edit_mode(self, card, label, button, setting_name, current_value):
        if button['text'] == "‚úèÔ∏è":
            # Cambiar a modo edici√≥n
            entry = tk.Entry(card, bg=self.clipboard_manager.theme_manager.colors['dark']['button_bg'],
                             fg=self.clipboard_manager.theme_manager.colors['dark']['fg'],
                             insertbackground=self.clipboard_manager.theme_manager.colors['dark']['fg'])
            entry.insert(0, current_value)
            entry.pack(side=tk.LEFT, fill=tk.X, expand=True, padx=5, pady=5)
            label.pack_forget()
            button.configure(text="üíæ")
        else:
            # Guardar cambios
            entry = [child for child in card.winfo_children() if isinstance(child, tk.Entry)][0]
            new_value = entry.get()
            label.configure(text=f"{setting_name}: {new_value}")
            entry.destroy()
            label.pack(side=tk.LEFT, fill=tk.X, expand=True)
            button.configure(text="‚úèÔ∏è")
            
            # Actualizar configuraciones
            if setting_name == "Alto":
                self.settings['height'] = int(new_value)
            elif setting_name == "Ancho":
                self.settings['width'] = int(new_value)
            elif setting_name == "Alt+":
                old_hotkey = self.settings['hotkey']
                new_hotkey = 'alt+' + new_value
                self.settings['hotkey'] = new_value  # Guarda solo la letra
                self.clipboard_manager.key_handler.update_hotkey(f"alt+{old_hotkey}", new_hotkey)
                
            self.save_settings()
            self.restart_app()
            
    def restart_app(self):
        python = sys.executable
        os.execl(python, python, *sys.argv, "--show-settings")
            
    def start_move(self, event):
        self.x = event.x
        self.y = event.y

    def on_move(self, event):
        deltax = event.x - self.x
        deltay = event.y - self.y
        x = self.settings_window.winfo_x() + deltax
        y = self.settings_window.winfo_y() + deltay
        self.settings_window.geometry(f"+{x}+{y}")
        
    def close_settings_window(self):
        self.settings_window.destroy()
        self.clipboard_manager.show_main_screen()

// Archivo: structure.py
# structure.py

import sys
import tkinter as tk
from tkinter import ttk
import threading
import win32gui
import pyautogui

from functions import Functions
from keys_groups_screen import GroupsScreenKeyConfig
from navigation import Navigation
from theme_manager import ThemeManager
from groups_manager import GroupManager
from data_manager import DataManager
from settings_manager import SettingsManager
from key_handler import KeyHandler
from keys_main_screen import MainScreenKeyConfig
from navigation_main_screen import MainScreenNavigation


import logging

logger = logging.getLogger(__name__)

class ClipboardManager:
    def __init__(self, root, show_settings=False):
        self.root = root
        self.root.title("Portapapeles")

        self.data_manager = DataManager()
        groups, pinned_items, settings = self.data_manager.load_data()
        
        self.settings = settings
        self.settings_manager = SettingsManager(self.root, self)
        self.settings_manager.initialize_settings()

        self.window_width = settings['width']
        self.window_height = settings['height']
        self.window_x = 0
        self.window_y = 0

        self.root.overrideredirect(True)
        self.root.attributes('-topmost', True)
        self.root.protocol("WM_DELETE_WINDOW", self.on_close)  # Manejar el cierre de la ventana

        
        self.root.withdraw()
        self.is_visible = False

        self.previous_window = None

        self.clipboard_items = {}
        for item_id, item_data in pinned_items.items():
            if isinstance(item_data['text'], dict):
                self.clipboard_items[item_id] = item_data
            else:
                # Si el texto no es un diccionario, lo convertimos a la estructura esperada
                self.clipboard_items[item_id] = {
                    'text': {'text': item_data['text'], 'formatted': {}},
                    'pinned': item_data['pinned']
                }
                
        self.current_clipboard = ""
        self.selected_index = None
        self.current_selection = {'type': 'button', 'index': 0}
        self.is_dark_mode = True
        
        self.paste_with_format = False
        
        self.previous_window = None
        self.last_active_window = None
        self.selected_button = None
        self.selected_card = None
        self.selected_icon = None
        self.total_buttons = 6
        self.top_buttons = 3
        self.icons_per_card = 3
        
        self.hotkey = f"alt+{settings['hotkey']}"

        self.theme_manager = ThemeManager(self)
        self.functions = Functions(self)
        self.group_manager = GroupManager(self.root, self)
        self.key_handler = KeyHandler(self)
        self.setup_key_bindings()
        self.main_screen_keys = MainScreenKeyConfig(self.key_handler, self)
        self.groups_screen_keys = GroupsScreenKeyConfig(self.key_handler, self)
        self.main_screen_navigation = MainScreenNavigation(self)
        
        # Inicializaci√≥n del sistema de teclas y navegaci√≥n
        self.setup_keyboard_system() 
        
        self.root.bind('<Key>', self.key_handler.handle_key_press)
        
        self.group_manager.groups = groups
        
        self.create_gui()
        self.setup_button_bindings()  
        self.load_saved_data()
        
        self.navigation = Navigation(self)
        
        self.theme_manager.apply_theme()

        self.monitor_thread = threading.Thread(target=self.functions.monitor_clipboard, daemon=True)
        self.monitor_thread.start()
                        
        if show_settings:
            self.root.after(100, self.settings_manager.show_settings_window)
        
        self.root.after(1000, self.navigation.check_window_state)
        
        # scroll
        self.canvas.configure(yscrollcommand=self.scrollbar.set)
        self.canvas.bind('<Configure>', self.on_canvas_configure)
        self.cards_frame.bind('<Configure>', lambda e: self.canvas.configure(scrollregion=self.canvas.bbox("all")))
        
    def setup_key_bindings(self):
        self.key_handler.register_screen_hotkey('main', 'up', self.navigate_up)
        self.key_handler.register_screen_hotkey('main', 'down', self.navigate_down)
        self.key_handler.register_screen_hotkey('main', 'left', self.navigate_left)
        self.key_handler.register_screen_hotkey('main', 'right', self.navigate_right)
        self.key_handler.register_screen_hotkey('main', 'return', self.activate_selected)
        
    def navigate_up(self):
        self.main_screen_navigation.navigate_vertical(type('Event', (), {'keysym': 'Up'})())

    def navigate_down(self):
        self.main_screen_navigation.navigate_vertical(type('Event', (), {'keysym': 'Down'})())

    def navigate_left(self):
        self.main_screen_navigation.navigate_horizontal(type('Event', (), {'keysym': 'Left'})())

    def navigate_right(self):
        self.main_screen_navigation.navigate_horizontal(type('Event', (), {'keysym': 'Right'})())

    def activate_selected(self):
        self.main_screen_navigation.activate_selected()    
    
    def force_update(self):
        self.root.update_idletasks()
        self.root.update()
            
    def on_close(self):
        self.root.withdraw()
        self.is_visible = False

    def create_gui(self):
        self.main_frame = ttk.Frame(self.root, style='Main.TFrame')
        self.main_frame.pack(fill=tk.BOTH, expand=True)

        self.title_frame = tk.Frame(self.main_frame, bg=self.theme_manager.colors['dark']['bg'])
        self.title_frame.pack(fill=tk.X, padx=3, pady=(0,6))

        self.title_label = tk.Label(self.title_frame, text="Portapapeles", font=('Segoe UI', 10, 'bold'), bg=self.theme_manager.colors['dark']['bg'], fg=self.theme_manager.colors['dark']['fg'])
        self.title_label.pack(side=tk.LEFT, padx=5)

        buttons_frame = tk.Frame(self.title_frame, bg=self.theme_manager.colors['dark']['bg'])
        buttons_frame.pack(side=tk.RIGHT, padx=4)

        self.theme_button = tk.Button(buttons_frame, text="üåô", command=self.theme_manager.toggle_theme, font=('Segoe UI', 10), bd=0, padx=10, width=5, height=2)
        self.theme_button.pack(side=tk.LEFT)

        self.clear_button = tk.Button(buttons_frame, text="    üñ•Ô∏è", command=self.show_settings, font=('Segoe UI', 10), bd=0, padx=10, width=5, height=2)
        self.clear_button.pack(side=tk.LEFT)

        self.close_button = tk.Button(buttons_frame, text="‚ùå", command=self.functions.exit_app, font=('Segoe UI', 10, 'bold'), bd=0, padx=10, width=5, height=2)
        self.close_button.pack(side=tk.LEFT)

        main_buttons_frame = tk.Frame(self.main_frame, bg=self.theme_manager.colors['dark']['bg'])
        main_buttons_frame.pack(fill=tk.X, padx=6, pady=0)

        self.button1 = tk.Button(main_buttons_frame, text="Grupos", 
                                 command=self.show_groups, font=('Segoe UI', 10), 
                                 bg=self.theme_manager.colors['dark']['button_bg'], 
                                 fg=self.theme_manager.colors['dark']['button_fg'],
                                 relief=tk.FLAT,
                                 bd=0,
                                 highlightthickness=1,
                                 pady=8)
        self.button1.pack(side=tk.LEFT, fill=tk.X, expand=True, padx=1, pady=0)

        self.button2 = tk.Button(main_buttons_frame, text="Sin formato", 
                                 command=self.functions.toggle_paste_format, font=('Segoe UI', 10), 
                                 bg=self.theme_manager.colors['dark']['button_bg'], 
                                 fg=self.theme_manager.colors['dark']['button_fg'],
                                 relief=tk.FLAT,
                                 bd=0,
                                 highlightthickness=1,
                                 pady=8) 
        self.button2.pack(side=tk.LEFT, fill=tk.X, expand=True, padx=1, pady=0)

        self.button3 = tk.Button(main_buttons_frame, text="Borrar Todo", 
                                 command=self.functions.clear_history, font=('Segoe UI', 10), 
                                 bg=self.theme_manager.colors['dark']['button_bg'], 
                                 fg=self.theme_manager.colors['dark']['button_fg'],
                                 relief=tk.FLAT,
                                 bd=0,
                                 highlightthickness=1,
                                 pady=8)                               
        self.button3.pack(side=tk.LEFT, fill=tk.X, expand=True, padx=1, pady=0)

        self.canvas = tk.Canvas(self.main_frame, bd=0, highlightthickness=0)
        self.canvas.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)
        
        self.cards_frame = tk.Frame(self.canvas, bg=self.theme_manager.colors['dark']['bg'])
        self.canvas_window = self.canvas.create_window((0, 0), window=self.cards_frame, anchor='nw')

        self.scrollbar = ttk.Scrollbar(self.main_frame, orient=tk.VERTICAL, command=self.canvas.yview)
        self.canvas.configure(yscrollcommand=self.scrollbar.set)

        # Variables para el movimiento de la ventana
        self._drag_data = {"x": 0, "y": 0, "item": None}

        # Vincular eventos para mover la ventana
        self.title_label.bind('<Button-1>', self.start_move)
        self.title_label.bind('<ButtonRelease-1>', self.stop_move)
        self.title_label.bind('<B1-Motion>', self.on_move)
        
        # Vincula eventos de scroll
        self.canvas.bind('<Configure>', self.on_canvas_configure)
        self.cards_frame.bind('<Configure>', self.on_frame_configure)
        self.canvas.bind_all("<MouseWheel>", self.on_mousewheel)

    def scrollbar_set(self, start, end):
        # Este m√©todo se llama cuando el canvas actualiza su regi√≥n de scroll
        self.canvas.yview_moveto(float(start))

    def show_settings(self):
        self.settings_manager.show_settings_window()
        self.navigation.set_strategy('settings')
        self.root.withdraw()
        
    def refresh_main_screen(self):
        # Actualizar la regi√≥n de desplazamiento
        self.canvas.update_idletasks()
        self.canvas.configure(scrollregion=self.canvas.bbox("all"))
        
        # Volver a vincular eventos de scroll
        self.canvas.bind('<Configure>', self.on_canvas_configure)
        self.cards_frame.bind('<Configure>', self.on_frame_configure)
        self.canvas.bind_all("<MouseWheel>", self.on_mousewheel)
        
        # Asegurarse de que el canvas tenga el foco
        self.canvas.focus_set()
        
        # Refrescar las tarjetas
        self.functions.refresh_cards()

    def setup_keyboard_system(self):
        """Inicializa y configura el sistema de teclas y navegaci√≥n"""
        try:
            # Configurar navegaci√≥n
            self.navigation = Navigation(self)
            
            # Vincular eventos de teclado
            def handle_key(event):
                print(f"Root received key event: {event.keysym}")  # Debug
                if self.is_visible:
                    self.navigation.handle_keyboard_event(event)
            
            self.root.bind('<KeyPress>', handle_key)
            
            # Establecer estrategia inicial
            self.navigation.set_strategy('main')
            
            print("Keyboard system initialized")  # Debug
            
        except Exception as e:
            logger.error(f"Error setting up keyboard system: {e}")
            raise

    def _handle_keypress(self, event):
        """Manejador central de eventos de teclado"""
        print(f"Root received key event: {event.keysym}")  # Debug
        if self.is_visible:
            self.navigation.handle_keyboard_event(event)

    def _bind_keyboard_events(self):
        """Vincula los eventos de teclado a la ventana principal"""
        try:
            self.root.bind('<Key>', self.handle_keyboard_event)
            logger.debug("Keyboard events bound successfully")
        except Exception as e:
            logger.error(f"Error binding keyboard events: {e}")
            raise

    def _setup_screen_keys(self):
        """Configura las teclas espec√≠ficas de cada pantalla"""
        try:
            self.main_screen_keys = MainScreenKeyConfig(self.key_handler, self)
            self.main_screen_navigation = MainScreenNavigation(self)
            logger.debug("Screen keys configured successfully")
        except Exception as e:
            logger.error(f"Error setting up screen keys: {e}")
            raise
        
    def register_global_shortcuts(self):
        """Registra los atajos de teclado globales b√°sicos"""
        # Atajo principal de la aplicaci√≥n
        self.key_handler.global_hotkeys.register_hotkey(
            self.hotkey, 
            self.key_handler.toggle_window
        )
        
        # Otros atajos globales que quieras a√±adir
        # self.key_handler.global_hotkeys.register_hotkey('alt+q', self.functions.exit_app)
        # etc...

    def handle_keyboard_event(self, event):
        """Maneja los eventos de teclado seg√∫n la pantalla actual"""
        if self.is_visible:
            self.navigation.handle_keyboard_event(event)

    def show_groups(self):
        """Muestra la ventana de grupos y configura su navegaci√≥n"""
        self.group_manager.show_groups_window()
        self.navigation.set_strategy('groups')
        self.main_screen_keys.deactivate()
        self.groups_screen_keys.activate()  # Activar configuraci√≥n de teclas de grupos
        self.root.withdraw()

    def show_main_screen(self):
        """Muestra la pantalla principal y configura su navegaci√≥n"""
        self.navigation.set_strategy('main')
        self.groups_screen_keys.deactivate()  # Desactivar configuraci√≥n de teclas de grupos
        self.root.deiconify()
        self.root.lift()
        self.root.focus_force()
        self.refresh_main_screen()
        self.main_screen_keys.activate()  # Activa las teclas de la pantalla principal
        
    def load_saved_data(self):
        groups, pinned_items, _ = self.data_manager.load_data()
        self.group_manager.groups = groups
        self.clipboard_items.update(pinned_items)
        self.functions.refresh_cards()

    def on_main_window_map(self, event):
        if self.group_manager.groups_window and self.group_manager.groups_window.winfo_exists():
            self.group_manager.groups_window.deiconify()

    def on_main_window_unmap(self, event):
        if self.group_manager.groups_window and self.group_manager.groups_window.winfo_exists():
            self.group_manager.groups_window.withdraw()

    def start_move(self, event):
        self._drag_data["x"] = event.x
        self._drag_data["y"] = event.y

    def stop_move(self, event):
        self._drag_data["x"] = 0
        self._drag_data["y"] = 0
        self._drag_data["item"] = None

    def on_move(self, event):
        delta_x = event.x - self._drag_data["x"]
        delta_y = event.y - self._drag_data["y"]
        x = self.root.winfo_x() + delta_x
        y = self.root.winfo_y() + delta_y
        self.root.geometry(f"+{x}+{y}")
        self.window_x = x
        self.window_y = y

    def on_canvas_configure(self, event):
        self.canvas.configure(scrollregion=self.canvas.bbox("all"))
        width = event.width
        self.canvas.itemconfig(self.canvas_window, width=width)

    def on_frame_configure(self, event):
        self.canvas.configure(scrollregion=self.canvas.bbox("all"))

    def on_mousewheel(self, event):
        # Asegurarse de que el canvas tenga el foco
        self.canvas.focus_set()
        # Scroll
        self.canvas.yview_scroll(int(-1 * (event.delta / 120)), "units")
        
    def on_scroll(self, *args):
        # Este m√©todo se llama cuando se realiza un scroll
        if len(args) == 3 and isinstance(args[2], str):
            self.canvas.yview_moveto(args[0])
        elif len(args) == 2 and isinstance(args[0], str):
            self.canvas.yview_scroll(int(args[1]), args[0])
            
    def exit_app(self):
        self.root.quit()
        sys.exit()
        
    def setup_button_bindings(self) -> None:
        """Configura los enlaces de botones para clic y Enter"""
        # Botones principales
        self.button1.bind('<Button-1>', lambda e: self.activate_button('main_buttons', 0))
        self.button2.bind('<Button-1>', lambda e: self.activate_button('main_buttons', 1))
        self.button3.bind('<Button-1>', lambda e: self.activate_button('main_buttons', 2))

        # Botones superiores
        self.theme_button.bind('<Button-1>', lambda e: self.activate_button('top_buttons', 0))
        self.clear_button.bind('<Button-1>', lambda e: self.activate_button('top_buttons', 1))
        self.close_button.bind('<Button-1>', lambda e: self.activate_button('top_buttons', 2))

    def activate_button(self, button_type: str, index: int) -> None:
        """Activa un bot√≥n espec√≠fico"""
        self.navigation.current_strategy.state['current_selection'] = {
            'type': button_type,
            'index': index
        }
        self.navigation.current_strategy.activate_selected()

// Archivo: theme_manager.py
#theme_manager.py

import tkinter as tk
from tkinter import ttk

class ThemeManager:
    def __init__(self, manager):
        self.manager = manager
        self.colors = {
            'dark': {
                'bg': '#1e1e1e',
                'fg': '#ffffff',
                'button_bg': '#333333',
                'button_fg': '#ffffff',
                'listbox_bg': '#2d2d2d',
                'listbox_fg': '#ffffff',
                'active_bg': '#4E4E4E',  # A√±adido
                'active_fg': '#FFFFFF',  # A√±adido
                'card_bg': '#333333'
            },
            'light': {
                'bg': '#f0f0f0',
                'fg': '#000000',
                'button_bg': '#e0e0e0',
                'button_fg': '#000000',
                'listbox_bg': '#ffffff',
                'listbox_fg': '#000000',
                'active_bg': '#D0D0D0',  # A√±adido
                'active_fg': '#000000',  # A√±adido
                'card_bg': '#ffffff'
            }
        }

    def toggle_theme(self):
        self.manager.is_dark_mode = not self.manager.is_dark_mode
        self.manager.theme_button.config(text="üåô" if self.manager.is_dark_mode else "‚òÄÔ∏è")
        self.apply_theme()

    def apply_theme(self):
        theme = self.colors['dark'] if self.manager.is_dark_mode else self.colors['light']
        
        self.manager.root.configure(bg=theme['bg'])
        self.manager.main_frame.configure(style='Main.TFrame')
        self.manager.title_frame.configure(bg=theme['bg'])
        self.manager.title_label.configure(bg=theme['bg'], fg=theme['fg'])
        
        self.manager.clear_button.configure(
            bg=theme['button_bg'],
            fg=theme['button_fg'],
            activebackground=theme['button_bg'],
            activeforeground=theme['button_fg']
        )
        self.manager.theme_button.configure(
            bg=theme['button_bg'],
            fg=theme['button_fg'],
            activebackground=theme['button_bg'],
            activeforeground=theme['button_fg']
        )
        
        self.manager.close_button.configure(
            bg=theme['button_bg'],
            fg=theme['button_fg'],
            activebackground=theme['button_bg'],
            activeforeground=theme['button_fg']
        )

        self.manager.button1.configure(
            bg=theme['button_bg'],
            fg=theme['button_fg'],
            activebackground=theme['button_bg'],
            activeforeground=theme['button_fg']
        )

        self.manager.button2.configure(
            bg=theme['button_bg'],
            fg=theme['button_fg'],
            activebackground=theme['button_bg'],
            activeforeground=theme['button_fg']
        )

        self.manager.button3.configure(
            bg=theme['button_bg'],
            fg=theme['button_fg'],
            activebackground=theme['button_bg'],
            activeforeground=theme['button_fg']
        )

        self.manager.canvas.configure(bg=theme['bg'])
        self.manager.cards_frame.configure(bg=theme['bg'])
        
        self.manager.functions.refresh_cards()

        style = ttk.Style()  
        style.theme_use('clam')  
        style.configure('Main.TFrame', background=theme['bg'])

// Archivo: utils.py
# utils.py

import time

def measure_time(func):
    def wrapper(*args, **kwargs):
        start_time = time.time()
        result = func(*args, **kwargs)
        end_time = time.time()
        print(f"{func.__name__} tom√≥ {(end_time - start_time) * 1000:.2f} ms")
        return result
    return wrapper

def process_text(text_data, cant_lineas):
    """
    Procesa el texto para mostrarlo de forma limpia y ordenada
    """
    # Comprueba si text_data es un diccionario y extrae el texto
    if isinstance(text_data, dict):
        text = text_data.get('text', '')
    else:
        text = str(text_data)

    # Eliminamos espacios extras y tabulaciones al inicio y final
    text = text.strip()
    
    # Dividimos el texto en l√≠neas
    lines = text.splitlines()
    
    # Eliminamos l√≠neas vac√≠as consecutivas y espacios extras
    clean_lines = []
    prev_empty = False
    for line in lines:
        line = line.strip()
        
        # Si la l√≠nea est√° vac√≠a
        if not line:
            if not prev_empty:  # Solo mantenemos una l√≠nea vac√≠a
                clean_lines.append('')
                prev_empty = True
        else:
            clean_lines.append(line)
            prev_empty = False
    
    # Tomamos solo las primeras 'cant_lineas' para la vista previa
    preview_lines = clean_lines[:cant_lineas]
    
    # Si hay m√°s l√≠neas, indicamos cu√°ntas m√°s hay
    if len(clean_lines) > cant_lineas:
        remaining_lines = len(clean_lines) - cant_lineas
        preview_lines.append(f"+ {remaining_lines} l√≠neas m√°s")
        
    # Unimos las l√≠neas con saltos de l√≠nea
    return '\n'.join(preview_lines)
